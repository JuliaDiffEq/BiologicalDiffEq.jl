# [Network Analysis in Catalyst](@id network_analysis)

In this tutorial we introduce several of the Catalyst API functions for network
analysis. A complete summary of the exported functions is given in the API
section
[`Network-Analysis-and-Representations`](https://docs.sciml.ai/Catalyst/stable/api/catalyst_api/#Network-Analysis-and-Representations).

Note, currently API functions for network analysis and conservation law analysis
do not work with constant species (currently only generated by SBMLToolkit).

## Network representation of the Repressilator `ReactionSystem`
We first load Catalyst and construct our model of the repressilator
```@example s1
using Catalyst
repressilator = @reaction_network Repressilator begin
       hillr(P₃,α,K,n), ∅ --> m₁
       hillr(P₁,α,K,n), ∅ --> m₂
       hillr(P₂,α,K,n), ∅ --> m₃
       (δ,γ), m₁ <--> ∅
       (δ,γ), m₂ <--> ∅
       (δ,γ), m₃ <--> ∅
       β, m₁ --> m₁ + P₁
       β, m₂ --> m₂ + P₂
       β, m₃ --> m₃ + P₃
       μ, P₁ --> ∅
       μ, P₂ --> ∅
       μ, P₃ --> ∅
end
```
In the [Introduction to Catalyst](@ref introduction_to_catalyst)
tutorial we showed how the above network could be visualized as a
species-reaction graph. There, species are represented by the nodes of the graph
and edges show the reactions in which a given species is a substrate or product.
```julia
g = Graph(repressilator)
```
![Repressilator solution](../assets/repressilator.svg)

We also showed in the [Introduction to Catalyst](@ref introduction_to_catalyst) tutorial that
the reaction rate equation ODE model for the repressilator is
```math
\begin{aligned}
\frac{dm_1(t)}{dt} =& \frac{\alpha K^{n}}{K^{n} + \left( {P_3}\left( t \right) \right)^{n}} - \delta {m_1}\left( t \right) + \gamma \\
\frac{dm_2(t)}{dt} =& \frac{\alpha K^{n}}{K^{n} + \left( {P_1}\left( t \right) \right)^{n}} - \delta {m_2}\left( t \right) + \gamma \\
\frac{dm_3(t)}{dt} =& \frac{\alpha K^{n}}{K^{n} + \left( {P_2}\left( t \right) \right)^{n}} - \delta {m_3}\left( t \right) + \gamma \\
\frac{dP_1(t)}{dt} =& \beta {m_1}\left( t \right) - \mu {P_1}\left( t \right) \\
\frac{dP_2(t)}{dt} =& \beta {m_2}\left( t \right) - \mu {P_2}\left( t \right) \\
\frac{dP_3(t)}{dt} =& \beta {m_3}\left( t \right) - \mu {P_3}\left( t \right)
\end{aligned}
```

## Matrix-vector reaction rate equation representation
In general, reaction rate equation (RRE) ODE models for chemical reaction networks can
be represented as a first-order system of ODEs in a compact matrix-vector notation. Suppose
we have a reaction network with ``K`` reactions and ``M`` species, labelled by the state vector
```math
\mathbf{x}(t) = \begin{pmatrix} x_1(t) \\ \vdots \\ x_M(t)) \end{pmatrix}.
```
For the repressilator, ``\mathbf{x}(t)`` is just
```@example s1
x = species(repressilator)
```
The RRE ODEs satisfied by $\mathbf{x}(t)$ are then
```math
\frac{d\mathbf{x}}{dt} = N \mathbf{v}(\mathbf{x}(t),t),
```
where ``N`` is a constant ``M`` by ``K`` matrix with ``N_{m k}`` the net
stoichiometric coefficient of species ``m`` in reaction ``k``.
``\mathbf{v}(\mathbf{x}(t),t)`` is the rate law vector, with
``v_k(\mathbf{x}(t),t)`` the rate law for the ``k``th reaction. For example,
for the first reaction of the repressilator above, the rate law is
```math
v_1(\mathbf{x}(t),t) = \frac{\alpha K^{n}}{K^{n} + \left( P_3(t) \right)^{n}}.
```
We can calculate each of these in Catalyst via
```@example s1
N = netstoichmat(repressilator)
```
and by using the [`oderatelaw`](@ref) function
```@example s1
rxs = reactions(repressilator)
ν = oderatelaw.(rxs)
```
Note, as [`oderatelaw`](@ref) takes just one reaction as input we use
broadcasting to apply it to each element of `rxs`.

Let's check that this really gives the same ODEs as Catalyst. Here is what Catalyst
generates by converting to an `ODESystem`
```@example s1
osys = convert(ODESystem, repressilator)

# for display purposes we just pull out the right side of the equations
odes = [eq.rhs for eq in equations(osys)]
```
whereas our matrix-vector representation gives
```@example s1
odes2 = N * ν
```
Let's check these are equal symbolically
```@example s1
isequal(odes, odes2)
```

## [Reaction complex representation](@id network_analysis_reaction_complexes)
We now introduce a further decomposition of the RRE ODEs, which has been used to
facilitate analysis of a variety of reaction network properties. Consider a simple
reaction system like
```@example s1
rn = @reaction_network begin
 k*A, 2*A + 3*B --> A + 2*C + D
 b, C + D --> 2*A + 3*B
end
```
We can think of the first reaction as converting the *reaction complex*,
``2A+3B`` to the complex ``A+2C+D`` with rate ``kA``. Suppose we order our
species the same way as Catalyst does, i.e.
```math
\begin{pmatrix}
x_1(t)\\
x_2(t)\\
x_3(t)\\
x_4(t)
\end{pmatrix} =
\begin{pmatrix}
A(t)\\
B(t)\\
C(t)\\
D(t)
\end{pmatrix},
```
which should be the same as
```@example s1
species(rn)
```
We can describe a given reaction complex by the stoichiometric coefficients of
each species within the complex. For the reactions in `rn` these vectors would
be
```math
\begin{align*}
2A+3B = \begin{pmatrix}
2\\
3\\
0\\
0
\end{pmatrix}, &&
A+2C+D = \begin{pmatrix}
1\\
0\\
2\\
1
\end{pmatrix},
 &&
C+D = \begin{pmatrix}
0\\
0\\
1\\
1
\end{pmatrix}
\end{align*}
```
Catalyst can calculate these representations as the columns of the complex
stoichiometry matrix,
```@example s1
Z = complexstoichmat(rn)
```
If we have ``C`` complexes, ``Z`` is a ``M`` by ``C`` matrix with ``Z_{m c}``
giving the stoichiometric coefficient of species ``m`` within complex ``c``.

We can use this representation to provide another representation of the RRE
ODEs. The net stoichiometry matrix can be factored as ``N = Z B``, where ``B``
is called the incidence matrix of the reaction network,
```@example s1
B = incidencemat(rn)
```
Here ``B`` is a ``C`` by ``K`` matrix with ``B_{c k} = 1`` if complex ``c``
appears as a product of reaction ``k``, and ``B_{c k} = -1`` if complex ``c`` is a
substrate of reaction ``k``.

Using our decomposition of ``N``, the RRE ODEs become
```math
\frac{dx}{dt} = Z B \mathbf{v}(\mathbf{x}(t),t).
```
Let's verify that ``N = Z B``,
```@example s1
N = netstoichmat(rn)
N == Z*B
```

Reaction complexes give an alternative way to visualize a reaction network
graph. Catalyst's [`complexgraph`](@ref) command will calculate the complexes of
a network and then show how they are related. For example,
```julia
complexgraph(rn)
```
gives

![Simple example complex graph](../assets/simple_complexgraph.svg)

while for the repressilator we find
```julia
complexgraph(repressilator)
```

![Repressilator complex](../assets/repressilator_complexgraph.svg)

Here ∅ represents the empty complex, black arrows show reactions converting
substrate complexes into product complexes where the rate is just a number or
parameter, and red arrows indicate the conversion of substrate complexes into
product complexes where the rate is an expression involving chemical species.

## Aspects of reaction network structure
The reaction complex representation can be exploited via [Chemical Reaction
Network Theory](https://en.wikipedia.org/wiki/Chemical_reaction_network_theory)
to provide insight into possible steady state and time-dependent properties of
RRE ODE models and stochastic chemical kinetics models. We'll now illustrate
some of the types of network properties that Catalyst can determine, using the
reaction complex representation in these calculations.

Consider the following reaction network.
```@example s1
rn = @reaction_network begin
    (k1,k2), A + B <--> C
    k3, C --> D+E
    (k4,k5), D+E <--> F
    (k6,k7), 2A <--> B+G
    k8, B+G --> H
    k9, H --> 2A
end
```
with graph
```julia
complexgraph(rn)
```

![network_1](../assets/complex_rn.svg)

#### Linkage classes and sub-networks of the reaction network
The preceding reaction complex graph shows that `rn` is composed of two
disconnected sub-graphs, one containing the complexes ``A+B``, ``C``, ``D+E``, and
``F``, the other containing the complexes ``2A``, ``B + G``, and ``H``. These sets,
``\{A+B, C, D+E, F\}`` and ``\{2A, B + G,H\}`` are called the "linkage classes"
of the reaction network. The function [`linkageclasses`](@ref) will calculate
these for a given network, returning a vector of the integer indices of reaction
complexes participating in each set of linkage-classes. Note, indices of
reaction complexes can be determined from the ordering returned by
[`reactioncomplexes`](@ref).
```@example s1
# we must first calculate the reaction complexes -- they are cached in rn
reactioncomplexes(rn)

# now we can calculate the linkage classes
lcs = linkageclasses(rn)
```
It can often be convenient to obtain the disconnected sub-networks as distinct
`ReactionSystem`s, which are returned by the [`subnetworks`](@ref) function:
```@example s1
subnets = subnetworks(rn)

# check the reactions in each subnetwork
reactions.(subnets)
```
The graphs of the reaction complexes in the two sub-networks are then
```julia
  complexgraph(subnets[1])
```

![subnetwork_1](../assets/complex_subnets1.svg)

and,
```julia
 complexgraph(subnets[2])
```

![subnetwork_2](../assets/complex_subnets2.svg)

#### [Deficiency of the network](@id network_analysis_deficiency)
A famous theorem in Chemical Reaction Network Theory, the Deficiency Zero
Theorem [^1], allows us to use knowledge of the net stoichiometry matrix and the
linkage classes of a *mass action* RRE ODE system to draw conclusions about the
system's possible steady states. In this section we'll see how Catalyst can
calculate a network's deficiency.

The rank, ``r``, of a reaction network is defined as the dimension of the
subspace spanned by the net stoichiometry vectors of the reaction-network [^1],
i.e. the span of the columns of the net stoichiometry matrix `N`. It corresponds
to the number of independent species in a chemical reaction network. That is, if
we calculate the linear conservation laws of a network, and use them to
eliminate the dependent species of the network, we will have ``r`` independent
species remaining. For our current example the conservation laws are given by
```@example s1
# first we calculate the conservation laws -- they are cached in rn
conservationlaws(rn)

# then we display them as equations for the dependent variables
conservedequations(rn)
show(stdout, MIME"text/plain"(), ans) # hide
```
Here the parameters `Γ[i]` represent the constants of the three
conservation laws, and we see that there are three dependent species that could
be eliminated. As
```@example s1
numspecies(rn)
```
we find that there are five independent species. Let's check this is correct:
```@example s1
using LinearAlgebra
rank(netstoichmat(rn)) == 5
```
So we know that the rank of our reaction network is five.

The deficiency, ``\delta``, of a reaction network is defined as
```math
\delta = \textrm{(number of complexes)} - \textrm{(number of linkage classes)} - \textrm{(rank)}.
```
For our network this is ``7 - 2 - 5 = 0``, which we can calculate in Catalyst as
```@example s1
# first we calculate the reaction complexes of rn and cache them in rn
reactioncomplexes(rn)

# then we can calculate the deficiency
δ = deficiency(rn)
```
Quoting Feinberg [^1]
> Deficiency zero networks are ones for which the reaction vectors [i.e. net
> stoichiometry vectors] are as independent as the partition of complexes into
> linkage classes will allow.

#### Reversibility of the network
A reaction network is *reversible* if the "arrows" of the reactions are
symmetric so that every reaction is accompanied by its reverse reaction.
Catalyst's API provides the [`isreversible`](@ref) function to determine whether
a reaction network is reversible. As an example, consider
```@example s1
rn = @reaction_network begin
  (k1,k2),A <--> B
  (k3,k4),A + C <--> D
  (k5,k6),D <--> B+E
  (k7,k8),B+E <--> A+C
end

# calculate the set of reaction complexes
reactioncomplexes(rn)

# test if the system is reversible
isreversible(rn)
```
Consider another example,
```@example s1
rn = @reaction_network begin
  (k1,k2),A <--> B
  k3, A + C --> D
  k4, D --> B+E
  k5, B+E --> A+C
end
reactioncomplexes(rn)
isreversible(rn)
```
```julia
complexgraph(rn)
```

![reversibility](../assets/complex_reversibility.svg)

It is evident from the preceding graph that the network is not reversible.
However, it satisfies a weaker property in that there is a path from each
reaction complex back to itself within its associated subgraph. This is known as
*weak reversibility*. One can test a network for weak reversibility by using
the [`isweaklyreversible`](@ref) function:
```@example s1
# need subnetworks from the reaction network first
subnets = subnetworks(rn)
isweaklyreversible(rn, subnets)
```
Every reversible network is also weakly reversible, but not every weakly
reversible network is reversible.

#### Deficiency Zero Theorem
Knowing the deficiency and weak reversibility of a mass action chemical reaction
network ODE model allows us to make inferences about the corresponding
steady state behavior. Before illustrating how this works for one example, we
need one last definition.

Recall that in the matrix-vector representation for the RRE ODEs, the entries,
``N_{m k}``, of the stoichiometry matrix, ``N``, give the net change in species
``m`` due to reaction ``k``. If we let ``\mathbf{N}_k`` denote the ``k``th
column of this matrix, this vector corresponds to the change in the species
state vector, ``\mathbf{x}(t)``, due to reaction ``k``, i.e. when reaction ``k``
occurs ``\mathbf{x}(t) \to \mathbf{x}(t) + \mathbf{N}_k``. Moreover, by
integrating the ODE
```math
\frac{d\mathbf{x}}{dt} = N \mathbf{v}(\mathbf{x}(t)) = \sum_{k=1}^{K} v_k(\mathbf{x}(t)) \, \mathbf{N}_k
```
we find
```math
\mathbf{x}(t) = \mathbf{x}(0) + \sum_{k=1}^K \left(\int_0^t v_k(\mathbf{x})(s) \, ds\right) \mathbf{N}_k,
```
which demonstrates that ``\mathbf{x}(t) - \mathbf{x}(0)`` is always given by a
linear combination of the stoichiometry vectors, i.e.
```math
\mathbf{x}(t) - \mathbf{x}(0) \in \operatorname{span}\{\mathbf{N}_k \}.
```
In particular, this says that ``\mathbf{x}(t)`` lives in the translation of the
``\operatorname{span}\{\mathbf{N}_k \}`` by ``\mathbf{x}(0)`` which we write as
``(\mathbf{x}(0) + \operatorname{span}\{\mathbf{N}_k\})``. In fact, since the
solution should stay non-negative, if we let $\bar{\mathbb{R}}_+^{M}$ denote the
subset of vectors in $\mathbb{R}^{M}$ with non-negative components, the possible
physical values for the solution, ``\mathbf{x}(t)``, must be in the set
```math
(\mathbf{x}(0) + \operatorname{span}\{\mathbf{N}_k\}) \cap \bar{\mathbb{R}}_+^{M}.
```
This set is called the stoichiometric compatibility class of ``\mathbf{x}(t)``.
The key property of stoichiometric compatibility classes is that they are
invariant under the RRE ODE's dynamics, i.e. a solution will always remain
within the subspace given by the stoichiometric compatibility class. Finally, we
note that the *positive* stoichiometric compatibility class generated by
$\mathbf{x}(0)$ is just ``(\mathbf{x}(0) + \operatorname{span}\{\mathbf{N}_k\})
\cap \mathbb{R}_+^{M}``, where ``\mathbb{R}_+^{M}`` denotes the vectors in
``\mathbb{R}^M`` with strictly positive components.

With these definitions we can now see how knowing the deficiency and weak
reversibility of the network can tell us about its steady state behavior.
Consider the previous example, which we know is weakly reversible. Its
deficiency is
```@example s1
deficiency(rn)
```
We also verify that the system is purely mass action (though it is apparent
from the network's definition):
```@example s1
all(rx -> ismassaction(rx, rn), reactions(rn))
```
We can therefore apply the Deficiency Zero Theorem to draw conclusions about the
system's steady state behavior. The Deficiency Zero Theorem (roughly) says that
a mass action network with deficiency zero satisfies
1. If the network is weakly reversible, then independent of the reaction rate
   constants the RRE ODEs have exactly one equilibrium solution within each
   positive stoichiometric compatibility class. That equilibrium is locally
   asymptotically stable.
2. If the network is not weakly reversible, then the RRE ODEs cannot admit a
   positive equilibrium solution.

See [^1] for a more precise statement, proof, and additional examples.

We can therefore conclude that for any initial condition that is positive, and
hence in some positive stoichiometric compatibility class, `rn` will have
exactly one equilibrium solution which will be positive and locally
asymptotically stable.

As a final example, consider the following network from [^1]
```@example s1
rn = @reaction_network begin
  (k1,k2),A <--> 2B
  (k3,k4), A + C <--> D
  k5, B+E --> C + D
end
reactioncomplexes(rn)
subnets = subnetworks(rn)
isma = all(rx -> ismassaction(rx,rn), reactions(rn))
def = deficiency(rn)
iswr = isweaklyreversible(rn, subnets)
isma,def,iswr
```
which we see is mass action and has deficiency zero, but is not weakly
reversible. As such, we can conclude that for any choice of rate constants the
RRE ODEs cannot have a positive equilibrium solution.

## Caching of Network Properties in `ReactionSystems`
When calling many of the network API functions, Catalyst calculates and caches
in `rn` a variety of information. For example the first call to
```julia
rcs,B = reactioncomplexes(rn)
```
calculates, caches, and returns the reaction complexes, `rcs`, and the incidence
matrix, `B`, of `rn`. Subsequent calls simply return `rcs` and `B` from the
cache.

Similarly, the first call to
```julia
N = netstoichmat(rn)
```
calculates, caches and returns the net stoichiometry matrix. Subsequent calls
then simply return the cached value of `N`. Caching such information means users
do not need to manually know which subsets of network properties are needed for
a given calculation (like the deficiency). Generally only
```julia
rcs,B = reactioncomplexes(rn)    # must be called once to cache rcs and B
any_other_network_property(rn)
```
should work to calculate a desired network property, with the API doc strings
indicating when `reactioncomplexes(rn)` must be called at least once before a
given function is used.

Because of the caching of network properties, subsequent calls to most API
functions will be fast, simply returning the previously calculated and cached
values. In some cases it may be desirable to reset the cache and recalculate
these properties. This can be done by calling
```julia
Catalyst.reset_networkproperties!(rn)
```
Network property functions will then recalculate their associated properties and
cache the new values the next time they are called.

---
## References
[^1]: [Feinberg, M. *Foundations of Chemical Reaction Network Theory*, Applied Mathematical Sciences 202, Springer (2019).](https://link.springer.com/book/10.1007/978-3-030-03858-8?noAccess=true)
