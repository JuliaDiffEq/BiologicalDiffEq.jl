<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Catalyst and Julia for New Julia users · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/introduction_to_catalyst/catalyst_for_new_julia_users/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li class="is-active"><a class="tocitem" href>Introduction to Catalyst and Julia for New Julia users</a><ul class="internal"><li><a class="tocitem" href="#Basic-Julia-usage"><span>Basic Julia usage</span></a></li><li><a class="tocitem" href="#Installing-and-activating-packages"><span>Installing and activating packages</span></a></li><li><a class="tocitem" href="#Simulating-a-basic-Catalyst-model"><span>Simulating a basic Catalyst model</span></a></li><li><a class="tocitem" href="#Additional-modelling-example"><span>Additional modelling example</span></a></li><li><a class="tocitem" href="#Feedback"><span>Feedback</span></a></li></ul></li><li><a class="tocitem" href="../introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Functionality</span><ul><li><a class="tocitem" href="../../catalyst_functionality/dsl_description/">The Reaction DSL</a></li><li><a class="tocitem" href="../../catalyst_functionality/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../catalyst_functionality/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../catalyst_functionality/network_analysis/">Network Analysis in Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Applications</span><ul><li><a class="tocitem" href="../../catalyst_applications/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../catalyst_applications/advanced_simulations/">Advanced Simulation Options</a></li><li><a class="tocitem" href="../../catalyst_applications/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../catalyst_applications/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../catalyst_applications/parameter_estimation/">Parameter Estimation</a></li></ul></li><li><span class="tocitem">Example Networks</span><ul><li><a class="tocitem" href="../../example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../example_networks/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../example_networks/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/catalyst_api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Introduction to Catalyst</a></li><li class="is-active"><a href>Introduction to Catalyst and Julia for New Julia users</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to Catalyst and Julia for New Julia users</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/introduction_to_catalyst/catalyst_for_new_julia_users.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="catalyst_for_new_julia_users"><a class="docs-heading-anchor" href="#catalyst_for_new_julia_users">Introduction to Catalyst and Julia for New Julia users</a><a id="catalyst_for_new_julia_users-1"></a><a class="docs-heading-anchor-permalink" href="#catalyst_for_new_julia_users" title="Permalink"></a></h1><p>The Catalyst tool for the modelling of chemical reaction networks is based in the Julia programming language. While experience in Julia programming is advantageous for using Catalyst, it is not necessary for accessing some of its basic features. This tutorial serves as an introduction to Catalyst for those unfamiliar with Julia, also introducing some basic Julia concepts. Anyone who plans on using Catalyst extensively is recommended to familiarise oneself more thoroughly with the Julia programming language. A collection of resources for learning Julia can be found <a href="https://julialang.org/learning/">here</a>, and a full documentation is available <a href="https://docs.julialang.org/en/v1/">here</a>.</p><p>Julia can be downloaded <a href="https://julialang.org/downloads/">here</a>.</p><p><em>Users who are already familiar with Julia can skip to the <a href="../introduction_to_catalyst/#introduction_to_catalyst">Introduction to Catalyst</a> tutorial.</em></p><h2 id="Basic-Julia-usage"><a class="docs-heading-anchor" href="#Basic-Julia-usage">Basic Julia usage</a><a id="Basic-Julia-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Julia-usage" title="Permalink"></a></h2><p>On the surface, Julia has many similarities to languages like MATLAB, Python, and R.</p><p><em>Values</em> can be assigned to <em>variables</em> through the use of a <code>=</code> sign. Values (possibly stored in variables) can be used for most basic computations.</p><pre><code class="language-julia hljs">length = 2.0
width = 4.0
area = length*width</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8.0</code></pre><p><em>Functions</em> take one or more inputs (enclosed by <code>()</code>) and return some output. E.g. the <code>min</code> function returns the minimum of two values</p><pre><code class="language-julia hljs">min(1.0, 3.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><p>A line of Julia code is not required to end with <code>;</code>, however, if it does, the output of that line is not displayed.</p><pre><code class="language-julia hljs">min(1.0, 3.0);</code></pre><p>Each Julia variable has a specific <em>type</em>, designating what type of value it is. While not directly required to use Catalyst, this is useful to be aware of. To learn the type of a specific variable, use the <code>typeof</code> function. More information about types can be <a href="https://docs.julialang.org/en/v1/manual/types/">found here</a>.</p><pre><code class="language-julia hljs">typeof(1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Float64</code></pre><p>Here, <code>Float64</code> denotes decimal-valued numbers. Integer-valued numbers instead are of the <code>Int64</code> type.</p><pre><code class="language-julia hljs">typeof(1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Int64</code></pre><p>Finally, we note that the first time some code is run in Julia, it has to be <em>compiled</em>. However, this is only required once per Julia session. Hence, the second time the same code is run, it runs much faster. E.g. try running this line of code first one time, and then one additional time. You will note that the second run is much faster.</p><pre><code class="language-julia hljs">rand(100, 100)^3.5;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100×100 Matrix{ComplexF64}:
 8311.97-2.18793im   9011.78-1.04679im    …  8878.49+3.96114im
 7643.28-3.39065im   8275.08-0.271925im      8161.63+4.70257im
 7966.14-3.26859im   8633.38+0.967436im      8502.45+4.30257im
 8432.36-3.61459im   9125.92+0.682905im      8993.83+5.05028im
 8929.18+0.245193im  9689.68-0.807854im      9528.72+0.67185im
 8872.99+2.17659im   9620.37-1.65657im    …  9474.43-2.77896im
 8876.28+0.823048im  9618.22+0.389862im      9468.47-0.612395im
 8469.23-2.05483im   9179.17+1.56543im       9044.85+3.31939im
 8333.88-1.006im     9046.31-0.0580805im      8899.4+3.07482im
 7537.07-6.1807im    8159.95+1.28605im       8051.08+8.25733im
        ⋮                                 ⋱  
 8658.81+0.650884im  9390.85+0.18497im       9233.28-1.01444im
 8701.89+2.587im     9435.79-0.479055im      9293.31-4.10926im
 8198.82-1.40237im   8884.28+0.434419im      8737.88+2.68005im
 7605.13-0.736209im  8236.89-0.0319097im      8115.5+0.910106im
 8405.47-1.43812im   9106.15+2.57451im    …  8964.23+1.19563im
 8124.92+0.87004im   8815.09+1.21532im       8673.48-2.01636im
 7960.31-1.89999im   8623.53+0.363062im      8501.75+2.451im
 7997.47-1.86123im   8660.38+1.39331im        8549.6+2.90295im
 8378.71-3.85519im   9075.29+2.03759im       8938.87+4.80862im</code></pre><p>(This code creates a random 100x100 matrix, and take it to the power of 3.5)</p><p>This is useful to know when you e.g. declare, simulate, or plot, a Catalyst model. The first time you run a command there might be a slight delay. However, subsequent runs will execute much quicker. This holds even if you do minor adjustments before the second run (such as changing simulation initial conditions).</p><h2 id="Installing-and-activating-packages"><a class="docs-heading-anchor" href="#Installing-and-activating-packages">Installing and activating packages</a><a id="Installing-and-activating-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Installing-and-activating-packages" title="Permalink"></a></h2><p>Except for some base Julia packages (such as <code>Pkg</code>, the package manager) that are available by default, Julia packages must be installed locally before they can be used. Most packages are registered with Julia, and can be added through the <code>Pkg.add(&quot;DesiredPackage&quot;)</code> command (where <code>DesiredPackage</code> is the name of the package you wish to install). We can thus install Catalyst:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;Catalyst&quot;)</code></pre><p>Here, the command <code>using Pkg</code> is required to activate the Pkg` package manager.</p><p>Next, we also wish to add the <code>DifferentialEquations</code> and <code>Plots</code> packages (for numeric simulation of models, and plotting, respectively).</p><pre><code class="language-julia hljs">Pkg.add(&quot;DifferentialEquations&quot;)
Pkg.add(&quot;Plots&quot;)</code></pre><p>Once a package has been installed through the <code>Pkg.add</code> command, this command does not have to be repeated in further Julia sessions on the same machine.</p><p>Installing a Julia package is, however, not enough to use it. Before a package&#39;s features are used in a Julia session, it has to be loaded through the <code>using DesiredPackage</code> command (where <code>DesiredPackage</code> is the name of the package you wish to activate). This command has to be repeated whenever a Julia session is restarted.</p><p>We thus activate our three desired packages:</p><pre><code class="language-julia hljs">using Catalyst
using DifferentialEquations
using Plots</code></pre><p>For a more detailed introduction to Julia packages, please read <a href="https://docs.julialang.org/en/v1/stdlib/Pkg/">the Pkg documentation</a>.</p><h2 id="Simulating-a-basic-Catalyst-model"><a class="docs-heading-anchor" href="#Simulating-a-basic-Catalyst-model">Simulating a basic Catalyst model</a><a id="Simulating-a-basic-Catalyst-model-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-a-basic-Catalyst-model" title="Permalink"></a></h2><p>Now that we have some basic familiarity with Julia, and have installed and activated the required packages, we will create and simulate a basic chemical reaction network model through Catalyst.</p><p>Catalyst models are created through the <code>@reaction_network</code>  <em>macro</em>. For more information on macros, please read <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#man-macros">the Julia documentation on macros</a>. This documentation is, however, rather advanced (and not required to use Catalyst). We instead recommend that you simply familiarise yourself with the Catalyst syntax, without studying in detail how macros work and what they are.</p><p>The <code>@reaction_network</code> command is followed by the <code>begin</code> keyword, which is followed by one line for each <em>reaction</em> of the model. Each reaction consists of a <em>reaction rate</em>, followed by the reaction itself. The reaction itself contains a set of <em>substrates</em> and a set of <em>products</em> (what is consumed and produced by the reaction, respectively). These are separated by a <code>--&gt;</code> arrow. Finally, the model ends with the <code>end</code> keyword.</p><p>Here, we create a simple <em>birth-death</em> model, where a single species (<em>X</em>) is created at rate <em>b</em>, and degraded at rate <em>d</em>. The model is stored in the variable <code>rn</code>.</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    b, 0 --&gt; X
    d, X --&gt; 0
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightleftharpoons[d]{b} \mathrm{X}  
 \end{align*}
 \]</p><p>For more information on how to use the Catalyst model creator (also known as the Catalyst DSL), please read <a href="https://docs.sciml.ai/Catalyst/stable/catalyst_functionality/dsl_description/">the corresponding documentation</a>.</p><p>Next, we wish to simulate our model. To do this, we need to provide some additional information to the simulator. This is</p><ul><li>The initial condition. That is, the concentration or numbers of each species at the start of the simulation.</li><li>The timespan. That is, the timeframe over which we wish to run the simulation.</li><li>The parameter values. That is, the values of the model&#39;s parameters for this simulation.</li></ul><p>The initial condition is given as a <em>Vector</em>. This is a type which collects several different values. To declare a vector, the values are specific within brackets, <code>[]</code>, and separated by <code>,</code>. Since we only have one species, the vector holds a single element. In this element, we set the value of <em>X</em> using the <code>:X =&gt; 1.0</code> syntax. Here, we first denote the name of the species (with a <code>:</code> pre-appended), next follows a <code>=&gt;</code> and then the value of <em>X</em>. Since we wish to simulate the <em>concentration</em> of X over time, we will let the initial condition be decimal valued.</p><pre><code class="language-julia hljs">u0 = [:X =&gt; 1.0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Pair{Symbol, Float64}}:
 :X =&gt; 1.0</code></pre><p>The timespan sets the time point at which we start the simulation (typically <code>0.0</code> is used) and the final time point of the simulation. These are combined into a two-valued <em>Tuple</em>. Tuples are similar to vectors, but are enclosed by <code>()</code> and not <code>[]</code>. Again, we will let both time points be decimal valued.</p><pre><code class="language-julia hljs">tspan = (0.0, 10.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.0, 10.0)</code></pre><p>Finally, the parameter values are, like the initial conditions, given as a vector. Since we have two parameters (<em>b</em> and <em>d</em>), the parameter vector has two values. We use a similar notation for setting the parameter values as the initial condition (first the parameter, then an arrow, then the value).</p><pre><code class="language-julia hljs">params = [:b =&gt; 1.0, :d =&gt; 0.2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Pair{Symbol, Float64}}:
 :b =&gt; 1.0
 :d =&gt; 0.2</code></pre><p>Please read here for more information on <a href="https://docs.julialang.org/en/v1/manual/arrays/">Vectors</a> and <a href="https://docs.julialang.org/en/v1/manual/types/#Tuple-Types">Tuples</a>.</p><p>Next, before we can simulate our model, we bundle all the required information together in a so-called <code>ODEProblem</code>. Note that the order in which the input (the model, the initial condition, the timespan, and the parameter values) is provided to the ODEProblem matters. E.g. the parameter values cannot be provided as the first argument, but have to be the fourth argument. Here, we save our <code>ODEProblem</code> in the <code>oprob</code> variable.</p><pre><code class="language- hljs">oprob = ODEProblem(rn, u0, tspan, params)</code></pre><p>We can now simulate our model. We do this by providing the <code>ODEProblem</code> to the <code>solve</code> function. We save the output to the <code>sol</code> variable.</p><pre><code class="language- hljs">sol = solve(oprob)</code></pre><p>Finally, we can plot the solution through the <code>plot</code> function.</p><pre><code class="language- hljs">plot(sol)</code></pre><p>Here, the plot shows the time evolution of the concentration of the species <em>X</em> from its initial condition.</p><p>For more information about the numerical simulation package, please see the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations documentation</a>. For more information about the plotting package, please see the <a href="https://docs.juliaplots.org/stable/">Plots documentation</a>.</p><h2 id="Additional-modelling-example"><a class="docs-heading-anchor" href="#Additional-modelling-example">Additional modelling example</a><a id="Additional-modelling-example-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-modelling-example" title="Permalink"></a></h2><p>To make this introduction more comprehensive, we here provide another example, using a more complicated model. In addition, instead of simulating our model as concentrations evolve over time, we will simulate the individual reaction events through the <a href="https://en.wikipedia.org/wiki/Gillespie_algorithm">Gillespie algorithm</a>. This is a way to add <em>noise</em> to our model.</p><p>Remember, unless we have restarted Julia, we do not need to activate our packages (through the <code>using</code> command) again.</p><p>This time, we will declare the so-called <a href="https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology#The_SIR_model">SIR model for an infectious disease</a>. Note that even if this model does not describe a set of chemical reactions, it can be modelled using the same dynamics. The model consists of 3 species:</p><ul><li><em>S</em>, the amount of <em>susceptible</em> individuals.</li><li><em>I</em>, the amount of <em>infected</em> individuals.</li><li><em>R</em>, the amount of <em>recovered</em> (or <em>removed</em>) individuals.</li></ul><p>It also has 2 reaction events:</p><ul><li>Infection, where a susceptible individual meets an infected individual and also becomes infected.</li><li>Recovery, where an infected individual recovers.</li></ul><p>Each reaction is also associated with a specific rate (corresponding to a parameter).</p><ul><li><em>b</em>, the infection rate.</li><li><em>k</em>, the recovery rate.</li></ul><p>We declare the model using the <code>@reaction_network</code> macro, and store it in the <code>sir_model</code> variable.</p><pre><code class="language-julia hljs">sir_model = @reaction_network begin
    b, S + I --&gt; 2I
    k, I --&gt; R
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{S} + \mathrm{I} &amp;\xrightarrow{b} 2 \mathrm{I} \\
\mathrm{I} &amp;\xrightarrow{k} \mathrm{R}  
 \end{align*}
 \]</p><p>Note that the first reaction contains two different substrates (separated by a <code>+</code> sign). While there is only a single product (<em>I</em>), two copies of <em>I</em> are produced. The <em>2</em> in front of the product <em>I</em> denotes this.</p><p>Next, we declare our initial condition, time span, and parameter values. Since we want to simulate the individual reaction events, that discretely change the state of our model, we want our initial conditions to be integer-valued. We will start with a mostly susceptible population, but where a single individual has been infected through some means.</p><pre><code class="language-julia hljs">u0 = [:S =&gt; 50, :I =&gt; 1, :R =&gt; 0.0]
tspan = (0.0, 10.0)
params = [:b =&gt; 0.2, :k =&gt; 1.0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Pair{Symbol, Float64}}:
 :b =&gt; 0.2
 :k =&gt; 1.0</code></pre><p>Previously we have bundled this information into an <code>ODEProblem</code> (denoting a deterministic <em>ordinary differential equation</em>). Now we wish to simulate our model as a jump process (where each reaction event denotes a single jump in the state of the system). We do this by first creating a <code>DiscreteProblem</code>, and then using this as an input to a <code>JumpProblem</code>.</p><pre><code class="language- hljs">dprob = DiscreteProblem(sir_model, u0, tspan, params)
jprob = JumpProblem(sir_model, dprob, Direct())</code></pre><p>Again, the order in which the inputs are given to the <code>DiscreteProblem</code> and the <code>JumpProblem</code> is important. The last argument to the <code>JumpProblem</code> (<code>Direct()</code>) denotes which simulation method we wish to use. For now, we recommend the user simply use the <code>Direct()</code> option, and then consider alternative ones (see the <a href="https://docs.sciml.ai/JumpProcesses/stable/">JumpProcesses.jl docs</a>) when they are more familiar with modelling in Catalyst and Julia.</p><p>Finally, we can simulate our model using the <code>solve</code> function, and plot the solution using the <code>plot</code> function. Here, the <code>solve</code> function also has a second argument (<code>SSAStepper()</code>). This is a time stepping algorithm that calls the <code>Direct</code> solver to advance a simulation. Again, we recommend at this stage you simply use this option, and then explore exactly what this means at a later stage.</p><pre><code class="language- hljs">sol = solve(jprob, SSAStepper())
sol = solve(jprob, SSAStepper(); seed=1234) # hide
plot(sol)</code></pre><p><strong>Exercise:</strong> Try simulating the model several times. Note that the epidemic doesn&#39;t always take off, but sometimes dies out without spreading through the population. Try changing the infection rate (<em>b</em>), determining how this value affects the probability that the epidemic goes through the population.</p><hr/><h2 id="Feedback"><a class="docs-heading-anchor" href="#Feedback">Feedback</a><a id="Feedback-1"></a><a class="docs-heading-anchor-permalink" href="#Feedback" title="Permalink"></a></h2><p>If you are a new Julia user who has used this tutorial, and there was something you struggled with or would have liked to have explained better, please <a href="https://github.com/SciML/Catalyst.jl/issues">raise an issue</a>. That way, we can continue improving this tutorial.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../introduction_to_catalyst/">Introduction to Catalyst »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 17 September 2023 22:36">Sunday 17 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
