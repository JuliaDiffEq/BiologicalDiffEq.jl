<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Simulation Options · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/catalyst_applications/advanced_simulations/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Functionality</span><ul><li><a class="tocitem" href="../../catalyst_functionality/dsl_description/">The Reaction DSL</a></li><li><a class="tocitem" href="../../catalyst_functionality/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../catalyst_functionality/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../catalyst_functionality/network_analysis/">Network Analysis in Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Applications</span><ul><li><a class="tocitem" href="../simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li class="is-active"><a class="tocitem" href>Advanced Simulation Options</a><ul class="internal"><li><a class="tocitem" href="#Monte-Carlo-simulations-using-EnsembleProblems"><span>Monte Carlo simulations using <code>EnsembleProblem</code>s</span></a></li><li><a class="tocitem" href="#advanced_simulations_callbacks"><span>Event handling using callbacks</span></a></li><li><a class="tocitem" href="#Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations"><span>Scaling the noise magnitude in the chemical Langevin equations</span></a></li><li><a class="tocitem" href="#Useful-plotting-options"><span>Useful plotting options</span></a></li></ul></li><li><a class="tocitem" href="../homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter Estimation</a></li></ul></li><li><span class="tocitem">Example Networks</span><ul><li><a class="tocitem" href="../../example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../example_networks/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../example_networks/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/catalyst_api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Catalyst Applications</a></li><li class="is-active"><a href>Advanced Simulation Options</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced Simulation Options</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/catalyst_applications/advanced_simulations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="advanced_simulations"><a class="docs-heading-anchor" href="#advanced_simulations">Advanced Simulation Options</a><a id="advanced_simulations-1"></a><a class="docs-heading-anchor-permalink" href="#advanced_simulations" title="Permalink"></a></h1><p>Throughout the preceding tutorials, we have shown the basics of how to solve ODE, SDE, and jump process models generated from Catalyst <code>ReactionSystem</code>s. In this tutorial we&#39;ll illustrate some more advanced functionality that can be useful in many modeling contexts, and that provide conveniences for common workflows. For a comprehensive overview of solver properties, parameters, and manipulating solution objects, please read the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">documentation of the DifferentialEquations package</a>, which Catalyst uses for all simulations.</p><h2 id="Monte-Carlo-simulations-using-EnsembleProblems"><a class="docs-heading-anchor" href="#Monte-Carlo-simulations-using-EnsembleProblems">Monte Carlo simulations using <code>EnsembleProblem</code>s</a><a id="Monte-Carlo-simulations-using-EnsembleProblems-1"></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo-simulations-using-EnsembleProblems" title="Permalink"></a></h2><p>In many contexts one needs to run multiple simulations of a model, for example to collect statistics of SDE or jump process solutions, or to systematically vary parameter values within a model. While it is always possible to manually run such ensembles of simulations via a <code>for</code> loop, DifferentialEquations.jl provides the <code>EnsembleProblem</code> as a convenience to manage structured collections of simulations. <code>EnsembleProblem</code>s provide a simple interface for modifying a problem between individual simulations, and offers several options for batching and/or parallelizing simulation runs. For a more thorough description, please read <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/ensemble/#ensemble">the Parallel Ensemble Simulations section of the DifferentialEquations documentation</a>. Here, we will give a brief introduction to the use of <code>EnsembleProblem</code>s from Catalyst-generated models.</p><p>Let&#39;s look at a single-component bistable self-activation model:</p><pre><code class="language- hljs">using Catalyst, DifferentialEquations, Plots

rn = @reaction_network begin
    v0 + hill(X,v,K,n), ∅ --&gt; X
    deg, X --&gt; ∅
end
u0 = [:X =&gt; 0.0]
tspan = (0.0,1000.0)
p = [:v0 =&gt; 0.1, :v =&gt; 2.5, :K =&gt; 75.0, :n =&gt; 2.0, :deg =&gt; 0.01];
sprob = SDEProblem(rn, u0, tspan, p)
nothing # hide</code></pre><p>we can then use our <code>SDEProblem</code> as input to an <code>EnsembleProblem</code>:</p><pre><code class="language- hljs">eprob = EnsembleProblem(sprob)</code></pre><p>The <code>EnsembleProblem</code> can now be used as input to the <code>solve</code> command. It has the same options as when simulating the <code>SDEProblem</code> directly, however, it has an additional argument <code>trajectories</code> to determine how many simulations should be performed.</p><pre><code class="language- hljs">esol = solve(eprob; trajectories=5)</code></pre><p>This simulation is automatically multithreaded over all available threads. Please read <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/ensemble/#EnsembleAlgorithms">this documentation</a> for more information on parallelisation alternatives. The ensemble simulations can be plotted using the <code>plot</code> function, which by default displays all trajectories:</p><pre><code class="language- hljs">plot(esol)</code></pre><p>Sometimes when performing a large number of ensemble simulations, the plots get very dense. In these cases, the plot argument <code>linealpha</code> (which sets trajectory transparency) may be useful:</p><pre><code class="language- hljs">esol = solve(eprob; trajectories = 100)
plot(esol; linealpha = 0.5)</code></pre><p>Sometimes, one wishes to perform the same simulation a large number of times, while making minor modifications to the problem each time. This can be done by giving a problem function, <code>prob_func</code>, argument to the <code>EnsembleProblem</code>. Let us consider ODE simulations of a simple birth/death process:</p><pre><code class="language- hljs">rn = @reaction_network begin
    (b,1.0), ∅ &lt;--&gt; X
end
u0 = [:X =&gt; 1.0]
tspan = (0.0, 1.0)
p = [:b =&gt; 1.];
oprob = ODEProblem(rn, u0, tspan, p)
nothing # hide</code></pre><p>We wish to simulate this model for a large number of values of <code>b</code>. We do this by creating a <code>prob_func</code> that will make a modification to the problem at the start of each Monte Carlo simulation:</p><pre><code class="language-julia hljs">b_values = 1.0:0.1:2.0
function prob_func(prob, i, repeat)
    @unpack b = prob.f.sys    # Fetches the b parameter to be used in the local scope.
    remake(prob; p = [b =&gt; b_values[i]])
end</code></pre><p>Here, <code>prob_func</code> takes three arguments:</p><ul><li><code>prob</code>: The problem given to our <code>EnsembleProblem</code>, this is the problem that <code>prob_func</code> modifies in each iteration.</li><li><code>i</code>: The number of this specific Monte Carlo iteration in the interval <code>1:trajectories</code>.</li><li><code>repeat</code>: The repeat of this specific Monte Carlo simulation (We will ignore</li></ul><p>this argument in this brief overview). In our case, for each Monte Carlo simulation, our <code>prob_func</code> takes our original <code>ODEProblem</code> and uses the <code>remake</code> function to change the parameter vector. Here, for the <code>i</code>th Monte Carlo simulation, the value of <code>b</code> is also the <code>i</code>th value of our <code>b_values</code> vector. Finally, we can simulate and plot our problem:</p><pre><code class="language- hljs">eprob = EnsembleProblem(oprob; prob_func = prob_func)
esol = solve(eprob; trajectories = length(b_values))
plot(esol)</code></pre><p>Note that plot legends are disabled when plotting ensemble solutions. These can be re-enabled using the <code>legend</code> plotting keyword. However, when plotting a large number of trajectories, each will generate a label. Sometimes the best approach is to remove these and add a label manually:</p><pre><code class="language- hljs">p = plot(esol; label = nothing)
plot!(p, Float64[], Float64[]; label = &quot;X&quot;, legend = :topleft)</code></pre><h2 id="advanced_simulations_callbacks"><a class="docs-heading-anchor" href="#advanced_simulations_callbacks">Event handling using callbacks</a><a id="advanced_simulations_callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#advanced_simulations_callbacks" title="Permalink"></a></h2><p>Sometimes one wishes to add discrete events during simulations. Examples could include:</p><ul><li>A chemical system where an amount of some species is added at a time point after the simulation&#39;s initiation.</li><li>A simulation of a circadian rhythm, where light is turned on/off every 12 hours.</li><li>A cell divides when some size variable reaches a certain threshold, randomly allocating all species to two daughter cells.</li></ul><p>In simple cases events such as these can be modelled symbolically, as described in the <a href="../../catalyst_functionality/constraint_equations/#constraint_equations">Constraint Equations and Events</a> tutorial. A more flexible, but low-level, interface is also available via the callback functionality of DifferentialEquations.jl. A callback is a function that is passed to the <code>solve()</code> command, combing an <code>affect!</code> function (defining how the callback changes the system) with a <code>condition</code> function (a condition for triggering a callback). For a thorough introduction, please read <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/">the section about callbacks in the DifferentialEquations.jl documentation</a>.</p><p>There exist three types of callbacks, <code>PresetTimeCallback</code>s <code>DiscreteCallback</code>s, and <code>ContinuousCallback</code>s. Here, we will limit ourselves to introducing the <code>PresetTimeCallback</code>. For our example, we are going to use a simple network where a single component, <code>X</code>, degrades linearly.</p><pre><code class="language-julia hljs">using Catalyst
degradation_model = @reaction_network begin
    d, X --&gt; 0
end</code></pre><p>we can simulate the model without using a callback:</p><pre><code class="language- hljs">using DifferentialEquations, Plots
u0 = [:X =&gt; 10.0]
tspan = (0.0, 10.0)
p = [:d =&gt; 1.0]

oprob = ODEProblem(degradation_model, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><p>We now wish to modify our simulation so that at the times <code>t = 3.0</code> and <code>t = 7.0</code> we add <code>5</code> units of <code>X</code> to the system. For this we create a <code>PresetTimeCallback</code>:</p><pre><code class="language-julia hljs">condition = [3.0, 7.0]
function affect!(integrator)
    integrator[:X] += 5.0
end
ps_cb = PresetTimeCallback(condition, affect!)</code></pre><p>Here, <code>condition</code> is simply a vector with all the time points during which we want the callback to trigger. The <code>affect!</code> function determines what happens to the simulation when the callback is triggered. It takes a single object, an <code>integrator</code> and makes some modification to it (please read more about integrators <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/">here</a>). Here, we access the system&#39;s state <code>X</code> through the <code>integrator</code>, and add <code>5.0</code> to its amount. We can now simulate our system using the callback:</p><pre><code class="language- hljs">sol = solve(oprob; callback = ps_cb)
plot(sol)</code></pre><p>Next, we can also use a callback to change the parameters of a system. The following code plots the concentration of a two-state system, as we change the equilibrium constant between the two states:</p><pre><code class="language- hljs">rn = @reaction_network begin
    (k,1), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0, :X2 =&gt; 0.0]
tspan = (0.0, 20.0)
p = [:k =&gt; 1.0]
oprob = ODEProblem(rn, u0, tspan, p)

condition = [5.0]
affect!(integrator) = integrator[:k] = 5.0
ps_cb = PresetTimeCallback(condition, affect!)

sol = solve(oprob; callback = ps_cb)
plot(sol)</code></pre><p>The result looks as expected. However, what happens if we attempt to run the simulation again?</p><pre><code class="language- hljs">sol = solve(oprob; callback = ps_cb)
plot(sol)</code></pre><p>The plot looks different, even though we simulate the same problem. Furthermore, the callback does not seem to have any effect on the system. If we check our <code>ODEProblem</code></p><pre><code class="language- hljs">oprob.p</code></pre><p>we note that <code>k = 5.0</code>, rather than <code>k = 1.0</code> as we initially specified. This is because the callback modifies our <code>ODEProblem</code> during the simulation, and this modification remains during the second simulation. An improved workflow to avoid this issue is:</p><pre><code class="language- hljs">rn = @reaction_network begin
    (k,1), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0,:X2 =&gt; 0.0]
tspan = (0.0, 20.0)
p = [:k =&gt; 1.0]
oprob = ODEProblem(rn, u0, tspan, p)

condition = [5.0]
affect!(integrator) = integrator[:k] = 5.0
ps_cb = PresetTimeCallback(condition, affect!)

sol = solve(deepcopy(oprob); callback = ps_cb)
plot(sol)</code></pre><p>where we parse a copy of our <code>ODEProblem</code> to the solver (using <code>deepcopy</code>). We can now run</p><pre><code class="language- hljs">sol = solve(deepcopy(oprob); callback = ps_cb)
plot(sol)</code></pre><p>and get the expected result.</p><p>It is possible to give several callbacks to the <code>solve()</code> command. To do so, one has to bundle them together in a <code>CallbackSet</code>, here follows one example:</p><pre><code class="language- hljs">rn = @reaction_network begin
    (k,1), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0,:X2 =&gt; 0.0]
tspan = (0.0, 20.0)
p = [:k =&gt; 1.0]
oprob = ODEProblem(rn, u0, tspan, p)

ps_cb_1 = PresetTimeCallback([3.0, 7.0], integ -&gt; integ[:X1] += 5.0)
ps_cb_2 = PresetTimeCallback([5.0], integ -&gt; integ[:k] = 5.0)

sol = solve(deepcopy(oprob); callback=CallbackSet(ps_cb_1, ps_cb_2))
plot(sol)</code></pre><p>The difference between the <code>PresetTimeCallback</code>s and the <code>DiscreteCallback</code>s and <code>ContiniousCallback</code>s is that the latter two allow the condition to be a function, permitting the user to give more general conditions for the callback to be triggered. An example could be a callback that triggers whenever a species surpasses some threshold value.</p><h3 id="advanced_simulations_ssa_callbacks"><a class="docs-heading-anchor" href="#advanced_simulations_ssa_callbacks">Callbacks during SSA simulations</a><a id="advanced_simulations_ssa_callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#advanced_simulations_ssa_callbacks" title="Permalink"></a></h3><p>An assumption of (most) SSA simulations is that the state of the system is unchanged between reaction events. However, callbacks that affect the system&#39;s state can violate this assumption. To prevent erroneous simulations, users must inform a SSA solver when the state has been updated in a callback. This allows the solver to reinitialize any internal state information that may have changed. This can be done through the <code>reset_aggregated_jumps!</code> function, see the following example:</p><pre><code class="language- hljs">rn = @reaction_network begin
    (k,1), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0,:X2 =&gt; 0.0]
tspan = (0.0, 20.0)
p = [:k =&gt; 1.0]
dprob = DiscreteProblem(rn, u0, tspan, p)
jprob = JumpProblem(rn, dprob, Direct())

condition = [5.0]
function affect!(integrator)
    integrator[:X1] += 5.0
    integrator[:k] += 2.0
    reset_aggregated_jumps!(integrator)
    nothing
end
cb = PresetTimeCallback(condition, affect!)

sol = solve(deepcopy(jprob), SSAStepper(); callback=cb)
plot(sol)</code></pre><h2 id="Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations"><a class="docs-heading-anchor" href="#Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations">Scaling the noise magnitude in the chemical Langevin equations</a><a id="Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations" title="Permalink"></a></h2><p>When using the CLE to generate SDEs from a CRN, it can sometimes be desirable to scale the magnitude of the noise terms. This can be done by introducing a <em>noise scaling parameter</em>. First, we simulate a simple two-state CRN model using the CLE:</p><pre><code class="language- hljs">using Catalyst, StochasticDiffEq, Plots

rn_1 = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0, :X2 =&gt; 10.0]
tspan = (0.0, 10.0)
p_1 = [:k1 =&gt; 1.0, :k2 =&gt; 1.0]

sprob_1 = SDEProblem(rn_1, u0, tspan, p_1)
sol_1 = solve(sprob_1)
plot(sol_1; idxs = :X1, ylimit = (0.0, 20.0))</code></pre><p>Here we can see that the <code>X</code> concentration fluctuations around a steady state of <em>X≈10.0</em>.</p><p>Next, we wish to introduce a noise scaling parameter ,<code>η</code>. This will scale the noise magnitude so that for <em>η≈0.0</em> the system lacks noise (and its SDE simulations are identical to its ODE simulations) and for <em>η≈1.0</em> noise is not scaled (and SDE simulations are identical to as if no noise scaling was used). Setting <em>η&lt;1.0</em> will reduce noise and <em>η&gt;1.0</em> will increase noise. The syntax for setting a noise scaling parameter <code>η</code> is</p><pre><code class="language- hljs">rn_2 = @reaction_network begin
    @parameters η
    (k1,k2), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0, :X2 =&gt; 10.0]
tspan = (0.0, 10.0)
p_2 = [:k1 =&gt; 1.0, :k2 =&gt; 1.0, :η =&gt; 0.1]

sprob_2 = SDEProblem(rn_2, u0, tspan, p_2; noise_scaling = (@parameters η)[1])</code></pre><p>Here, we first need to add <code>η</code> as a parameter to the system using the <code>@parameters η</code> option. Next, we pass the <code>noise_scaling = (@parameters η)[1]</code> argument to the <code>SDEProblem</code>. We can now simulate our system and confirm that noise is reduced:</p><pre><code class="language- hljs">sol_2 = solve(sprob_2)
plot(sol_2; idxs = :X1, ylimit = (0.0, 20.0))</code></pre><p>Finally, it is possible to set individual noise scaling parameters for each reaction of the system. Our model has two reactions (<code>X1 --&gt; X2</code> and <code>X2 --&gt; X1</code>) so we will use two noise scaling parameters, <code>η1</code> and <code>η2</code>. We use the following syntax:</p><pre><code class="language- hljs">rn_3 = @reaction_network begin
    @parameters η1 η2
    (k1,k2), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0, :X2 =&gt; 10.0]
tspan = (0.0, 10.0)
p_3 = [:k1 =&gt; 1.0, :k2 =&gt; 1.0, :η1 =&gt; 0.1, :η2 =&gt; 1.0]

sprob_3 = SDEProblem(rn_3, u0, tspan, p_3; noise_scaling = @parameters η1 η2)</code></pre><p>plotting the results, we see that we have less fluctuation than for the first simulation, but more as compared to the second one (which is as expected):</p><pre><code class="language- hljs">sol_3 = solve(sprob_3)
plot(sol_3; idxs = :X1, ylimit = (0.0, 20.0))</code></pre><h2 id="Useful-plotting-options"><a class="docs-heading-anchor" href="#Useful-plotting-options">Useful plotting options</a><a id="Useful-plotting-options-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-plotting-options" title="Permalink"></a></h2><p>Catalyst, just like DifferentialEquations, uses the Plots package for all plotting. For a detailed description of differential equation plotting, see <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/plot/">DifferentialEquations documentation on the subject</a>. Furthermore, the <a href="https://docs.juliaplots.org/stable/">Plots package documentation</a> contains additional information and describes <a href="https://docs.juliaplots.org/stable/attributes/">a large number of plotting options</a>. Here follows a very short tutorial with a few useful options.</p><p>Let us consider the Brusselator model:</p><pre><code class="language- hljs">using Catalyst, DifferentialEquations, Plots

brusselator = @reaction_network begin
    A, ∅ → X
    1, 2X + Y → 3X
    B, X → Y
    1, X → ∅
end
u0 = [:X =&gt; 1.0, :Y =&gt; 0.0]
tspan = (0.0, 50.0)
p = [:A =&gt; 1.0, :B =&gt; 4.0]

oprob = ODEProblem(brusselator, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><p>If we want to plot only the <code>X</code> species, we can use the <code>idxs</code> command:</p><pre><code class="language- hljs">plot(sol; idxs = [:X])</code></pre><p>If we wish to plot a single species (such as we do in this case), vector notation is not required and we could simply write <code>plot(sol; idxs=:X)</code>.</p><p>Next, if we wish to plot a solution in phase space (instead of across time) we again use the <code>idxs</code> notation, but use <code>()</code> instead of <code>[]</code> when designating the species we wish to plot. Here, we plot the solution in <code>(X,Y)</code> space:</p><pre><code class="language- hljs">plot(sol; idxs=(:X, :Y))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simulation_structure_interfacing/">« Interfacing problems, integrators, and solutions</a><a class="docs-footer-nextpage" href="../homotopy_continuation/">Finding Steady States through Homotopy Continuation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 17 September 2023 22:36">Sunday 17 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
