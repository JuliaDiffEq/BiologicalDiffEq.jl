var documenterSearchIndex = {"docs":
[{"location":"catalyst_functionality/dsl_description/#dsl_description","page":"The Reaction DSL","title":"The Reaction DSL","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"This tutorial describes the syntax for building chemical reaction network models using Catalyst's domain-specific language (DSL). Examples showing how to both construct and solve ODE, SDE, and jump models are provided in Basic Chemical Reaction Network Examples. To learn more about the symbolic ReactionSystems generated by the DSL, and how to use them directly, see the tutorial on Programmatic Construction of Symbolic Reaction Systems.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"We first load the Catalyst package, which is required for the code in this tutorial to run","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"using Catalyst","category":"page"},{"location":"catalyst_functionality/dsl_description/#basic_examples","page":"The Reaction DSL","title":"Basic syntax","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The @reaction_network macro allows the (symbolic) specification of reaction networks with a simple format. Its input is a set of chemical reactions, and from them it generates a symbolic ReactionSystem reaction network object. The ReactionSystem can be used as input to ModelingToolkit ODEProblem, NonlinearProblem, SteadyStateProblem, SDEProblem, JumpProblem, and more. ReactionSystems can also be incrementally extended as needed, allowing for programmatic construction of networks and network composition.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The basic syntax is:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, X + Y --> XY\n  1.0, XY --> Z1 + Z2\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"where each line of the @reaction_network macro corresponds to a chemical reaction. Each reaction consists of a reaction rate (the expression on the left-hand side of  ,), a set of substrates (the expression in-between , and -->), and a set of products (the expression on the right-hand side of -->). The substrates and the products may contain one or more reactants, separated by +. The naming convention for these is the same as for normal variables in Julia.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The chemical reaction model is generated by the @reaction_network macro and stored in the rn variable (a normal Julia variable, which does not need to be called rn). It corresponds to a ReactionSystem, a symbolic representation of the chemical network.  The generated ReactionSystem can be converted to a symbolic differential equation model via","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"osys  = convert(ODESystem, rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"We can then convert the symbolic ODE model into a compiled, optimized representation for use in the SciML ODE solvers by constructing an ODEProblem. Creating an ODEProblem also requires our specifying the initial conditions for the model. We do this by creating a mapping from each symbolic variable representing a chemical species to its initial value","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"# define the symbolic variables\n@variables t\n@species X(t) Y(t) Z(t) XY(t) Z1(t) Z2(t)\n\n# create the mapping\nu0 = [X => 1.0, Y => 1.0, XY => 1.0, Z1 => 1.0, Z2 => 1.0]","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Alternatively, we can create a mapping using Julia Symbols for each variable, and then convert them to a mapping involving symbolic variables like","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"u0 = symmap_to_varmap(rn, [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0])","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Given the mapping, we can then create an ODEProblem from our symbolic ODESystem","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"tspan = (0.0, 1.0)  # the time interval to solve on\noprob = ODEProblem(osys, u0, tspan, [])","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Catalyst provides a shortcut to avoid having to explicitly convert to an ODESystem and/or use symmap_to_varmap, allowing direct construction of the ODEProblem like","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"u0 = [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0]\noprob = ODEProblem(rn, u0, tspan, [])","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"For more detailed examples, see the Basic Chemical Reaction Network Examples.","category":"page"},{"location":"catalyst_functionality/dsl_description/#Defining-parameters-and-species","page":"The Reaction DSL","title":"Defining parameters and species","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Numeric parameter values do not need to be set when the model is created, i.e. Catalyst supports symbolic parameters too:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  k1, X --> Y\n  k2, Y --> X\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"All symbols that do not appear as a substrate or product in a reaction are designated by Catalyst as a parameter (i.e. all symbols appearing only within rate expressions and/or as stoichiometric coefficients). In this example X and Y appear as a substrates and products, but neither k1 nor k2. Hence k1 and k2 are designated as parameters. Later in this tutorial, we will describe how to manually specify what should be considered a species or parameter.","category":"page"},{"location":"catalyst_functionality/dsl_description/#Production,-Destruction,-and-Stoichiometry","page":"The Reaction DSL","title":"Production, Destruction, and Stoichiometry","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Sometimes reactants are produced/destroyed from/to nothing. This can be designated using either 0 or ∅:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, 0 --> X\n  1.0, X --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"If several molecules of the same reactant are involved in a reaction, the stoichiometry of a reactant in a reaction can be set using a number. Here, two molecules of species X form the dimer X2:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, 2X --> Y\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"this corresponds to the differential equation:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"convert(ODESystem, rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Other numbers than 2 can be used, and parenthesis can be used to reuse the same stoichiometry for several reactants:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X + 2(Y + Z) --> W\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Note, one can explicitly multiply by integer coefficients too, i.e.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X + 2*(Y + Z) --> W\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/#Arrow-variants","page":"The Reaction DSL","title":"Arrow variants","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"A variety of Unicode arrows are accepted by the DSL in addition to -->. All of these work:  >, → ↣, ↦, ⇾, ⟶, ⟼, ⥟, ⥟, ⇀, ⇁. Backwards arrows can also be used to write the reaction in the opposite direction. For example, these reactions are equivalent:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X + Y --> XY\n  1.0, X + Y → XY\n  1.0, XY ← X + Y\n  1.0, XY <-- X + Y\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/#Bi-directional-arrows-for-reversible-reactions","page":"The Reaction DSL","title":"Bi-directional arrows for reversible reactions","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Bi-directional arrows, including bidirectional Unicode arrows like ↔, can be used to designate a reversible reaction. For example, these two models are equivalent:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, X + Y --> XY\n  2.0, X + Y <-- XY\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn2 = @reaction_network begin\n  (2.0,2.0), X + Y <--> XY\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"If the reaction rates in the backward and forward directions are different, they can be designated in the following way:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  (2.0,1.0), X + Y <--> XY\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"which is identical to","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, X + Y --> XY\n  1.0, X + Y <-- XY\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/#Combining-several-reactions-in-one-line","page":"The Reaction DSL","title":"Combining several reactions in one line","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Several similar reactions can be combined in one line by providing a tuple of reaction rates and/or substrates and/or products. If several tuples are provided, they must all be of identical length. These pairs of reaction networks are all identical.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Pair 1:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  1.0, S --> (P1,P2)\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn2 = @reaction_network begin\n  1.0, S --> P1\n  1.0, S --> P2\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Pair 2:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  (1.0,2.0), (S1,S2) --> P\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn2 = @reaction_network begin\n  1.0, S1 --> P\n  2.0, S2 --> P\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Pair 3:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  (1.0,2.0,3.0), (S1,S2,S3) --> (P1,P2,P3)\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn2 = @reaction_network begin\n  1.0, S1 --> P1\n  2.0, S2 --> P2\n  3.0, S3 --> P3\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"This can also be combined with bi-directional arrows, in which case separate tuples can be provided for the backward and forward reaction rates. These reaction networks are identical","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n (1.0,(1.0,2.0)), S <--> (P1,P2)\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn2 = @reaction_network begin\n  1.0, S --> P1\n  1.0, S --> P2\n  1.0, P1 --> S\n  2.0, P2 --> S\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/#Variable-reaction-rates","page":"The Reaction DSL","title":"Variable reaction rates","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Reaction rates do not need to be a single parameter or a number, but can also be expressions depending on time or the current amounts of system species (when, for example, one species can activate the production of another). For instance, this is a valid notation:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X --> ∅\n  k*X, Y --> ∅\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"corresponding to the ODE model","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"convert(ODESystem,rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"With respect to the corresponding mass action ODE model, this is actually equivalent to the reaction system","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X --> ∅\n  k, X + Y --> X\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"convert(ODESystem,rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"note: Note\nWhile the ODE models corresponding to the preceding two reaction systems are identical, in the latter example the Reaction stored in rn will be classified as ismassaction while in the former it will not, which can impact optimizations used in generating JumpSystems. For this reason, it is recommended to use the latter representation when possible.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Most expressions and functions are valid reaction rates, e.g.:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"using SpecialFunctions\nrn = @reaction_network begin\n  2.0*X^2, 0 --> X + Y\n  t*gamma(Y), X --> ∅\n  pi*X/Y, Y --> ∅\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"where here t always denotes Catalyst's time variable. Please note that many user-defined functions can be called directly, but others will require registration with Symbolics.jl (see the faq).","category":"page"},{"location":"catalyst_functionality/dsl_description/#dsl_description_explicit_species","page":"The Reaction DSL","title":"Explicit specification of network species and parameters","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Recall that the @reaction_network macro automatically designates symbols used in the macro as either parameters or species, with symbols that appear as a substrate or product being species, and all other symbols becoming parameters (i.e. those that only appear within a rate expression and/or as stoichiometric coefficients). Sometimes, one might want to manually override this default behavior for a given symbol. E.g one might want something to be considered as a species, even if it only appears within a rate expression. In the following network","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  k*X, Y --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"X (as well as k) will be considered a parameter.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"By using the @species and @parameters options within the @reaction_network macro, one can manually declare that specified symbols should be considered a species or parameter. E.g in:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  @species X(t) Y(t)\n  k*X, Y --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"X and Y are set as species. Please note that when declaring species using the @species option, their dependant variable (almost always t) also needs to be designated. Similarly in","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  @parameters k\n  k*X, Y --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"both X and k will be considered as parameters. It is also possible to use both options simultaneously, allowing users to fully specify which symbols are species and/or parameters:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  @species X(t) Y(t)\n  @parameters k\n  k*X, Y --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Here, X and Y are designated as species and k as a parameter.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The lists provided to the @species and @parameters options do not need to be extensive. Any symbol that appears in neither list will use the default option as determined by the macro. E.g. in the previous example, where we only want to change the default designation of X (making it a species rather than a parameter), we can simply write:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  @species X(t)\n  k*X, Y --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Finally, note that the @species and @parameters options can also be used in begin ... end block form, allowing more formatted lists of species/parameters:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  @parameters begin\n      d1\n      d2\n  end\n  @species begin\n      X1(t)\n      X2(t)\n  end\n  d2, X2 --> 0\n  d1, X1 --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"This can be especially useful when declaring default values for clarity of model specification (see the next section).","category":"page"},{"location":"catalyst_functionality/dsl_description/#dsl_description_defaults","page":"The Reaction DSL","title":"Setting default values for initial conditions and parameters","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"When using the @species and @parameters macros to declare species and/or parameters, one can also provide default initial conditions for each species and values for each parameter:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  @species X(t)=1.0\n  @parameters p=1.0 d=0.1\n  p, 0 --> X\n  d, X --> ∅\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"This system can now be simulated without providing initial condition or parameter vectors to the DifferentialEquations.jl solvers:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"using DifferentialEquations, Plots\nu0 = []\ntspan = (0.0, 10.0)\np = []\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"When providing default values, it is possible to do so for only a subset of the species or parameters, in which case the rest can be specified when constructing the problem type to solve:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  @species X(t)\n  @parameters p=1.0 d\n  p, 0 --> X\n  d, X --> 0\nend\n\nu0 = [:X => 1.0]\ntspan = (0.0, 10.0)\np = [:d => .1]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Finally, default values can be overridden by passing mapping vectors to the DifferentialEquations.jl problem being constructed. Only those initial conditions or parameters for which we want to change their value from the default will need to be passed","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"u0 = [:X => 1.0]\ntspan = (0.0, 10.0)\np = [:p => 2.0, :d => .1]   # we change p to 2.0\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"catalyst_functionality/dsl_description/#Constant/fixed-species","page":"The Reaction DSL","title":"Constant/fixed species","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"It is possible to fix the amount of a species in a reaction. Without fixing a species, a reaction could look like","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n    k, X + Y --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"ode_sys = convert(ODESystem, rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"equations(ode_sys)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Fixing a species could either be achieved by modifying the reaction specification and specifying constant species explicitly as species as described above, i.e.,","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n    @species X(t)\n    k * X, Y --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"ode_sys = convert(ODESystem, rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"equations(ode_sys)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The species can of course also just be used as parameter - using the same modification of the reaction, i.e.,","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n    k * X, Y --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"ode_sys = convert(ODESystem, rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"equations(ode_sys)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The same result can also be achieved by declaring a species as fixed/constant without having to change the reaction itself, i.e.,","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n    @parameters X [isconstantspecies = true]\n    k, X + Y --> 0\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"ode_sys = convert(ODESystem, rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"equations(ode_sys)","category":"page"},{"location":"catalyst_functionality/dsl_description/#dsl_description_parametric_initial_conditions","page":"The Reaction DSL","title":"Setting initial conditions that depend on parameters","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"It is possible to set the initial condition of one (or several) species so that they depend on some system parameter. This is done in a similar way as default initial conditions, but giving the parameter instead of a value. When doing this, we also need to ensure that the initial condition parameter is a variable of the system:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  @parameters X0\n  @species X(t)=X0\n  p, 0 --> X\n  d, X --> ∅\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"We can now simulate the network without providing any initial conditions:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"u0 = []\ntspan = (0.0, 10.0)\np = [:p => 2.0, :d => .1, :X0 => 1.0]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"catalyst_functionality/dsl_description/#Naming-the-generated-ReactionSystem","page":"The Reaction DSL","title":"Naming the generated ReactionSystem","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"ModelingToolkit uses system names to allow for compositional and hierarchical models. To specify a name for the generated ReactionSystem via the @reaction_network macro, just place the name before begin:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network production_degradation begin\n  p, ∅ --> X\n  d, X --> ∅\nend\nModelingToolkit.nameof(rn) == :production_degradation","category":"page"},{"location":"catalyst_functionality/dsl_description/#Pre-defined-functions","page":"The Reaction DSL","title":"Pre-defined functions","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Hill functions and a Michaelis-Menten function are pre-defined and can be used as rate laws. Below, the pair of reactions within rn1 are equivalent, as are the pair of reactions within rn2:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  hill(X,v,K,n), ∅ --> X\n  v*X^n/(X^n+K^n), ∅ --> X\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn2 = @reaction_network begin\n  mm(X,v,K), ∅ --> X\n  v*X/(X+K), ∅ --> X\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Repressor Hill (hillr) and Michaelis-Menten (mmr) functions are also provided:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  hillr(X,v,K,n), ∅ --> X\n  v*K^n/(X^n+K^n), ∅ --> X\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn2 = @reaction_network begin\n  mmr(X,v,K), ∅ --> X\n  v*K/(X+K), ∅ --> X\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Please see the API Rate Laws section for more details.","category":"page"},{"location":"catalyst_functionality/dsl_description/#Including-non-species-variables","page":"The Reaction DSL","title":"Including non-species variables","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Non-species state variables can be specified in the DSL using the @variables macro. These are declared similarly to species. For example,","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn_with_volume = @reaction_network begin\n  @variables V(t)\n  k*V, 0 --> A\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"creates a network with one species","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"species(rn_with_volume)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"and one non-species","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"nonspecies(rn_with_volume)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"giving two state variables, always internally ordered by species and then nonspecies:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"states(rn_with_volume)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn_with_volume could then be extended with constraint equations for how V(t) evolves in time, see the associated tutorial.","category":"page"},{"location":"catalyst_functionality/dsl_description/#Specifying-alternative-time-variables-and/or-extra-independent-variables","page":"The Reaction DSL","title":"Specifying alternative time variables and/or extra independent variables","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"While the DSL defaults to allowing t as the time variable, one can use the @ivs macro to specify an alternative independent variable. For example, to make s the default time variable one can say","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn_with_s = @reaction_network begin\n    @ivs s\n    @variables V(s)\n    @species B(s)\n    k, A + V*B --> C\nend\nshow(stdout, MIME\"text/plain\"(), rn_with_s)  # hide","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"where we see all states are now functions of s.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Similarly, if one wants states to be functions of more than one independent variable, for example to encode a spatial problem, one can list more than one variable, i.e. @ivs t x y. Here the first listed independent variable is always chosen to represent time. For example,","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn_with_many_ivs = @reaction_network begin\n    @ivs s x\n    @variables V1(s) V2(s,x)\n    @species A(s) B(s,x)\n    k, V1*A --> V2*B + C\nend\nshow(stdout, MIME\"text/plain\"(), rn_with_many_ivs)  # hide","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Here again s will be the time variable, and any inferred species, C in this case, are made functions of both variables, i.e. C(s, x).","category":"page"},{"location":"catalyst_functionality/dsl_description/#dsl_description_interpolation_of_variables","page":"The Reaction DSL","title":"Interpolation of Julia variables","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The DSL allows Julia variables to be interpolated for the network name, within rate constant expressions, or for species/stoichiometry within reactions. Using the lower-level symbolic interface we can then define symbolic variables and parameters outside of the macro, which can then be used within expressions in the DSL (see the Programmatic Construction of Symbolic Reaction Systems tutorial for details on the lower-level symbolic interface). For example,","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"@parameters k α\n@variables t\n@species A(t)\nspec = A\npar = α\nrate = k*A\nname = :network\nrn = @reaction_network $name begin\n    $rate*B, 2*$spec + $par*B --> $spec + C\n  end","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"As the parameters k and α were pre-defined and appeared via interpolation, we did not need to declare them within the @reaction_network macro, i.e. they are automatically detected as parameters:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"parameters(rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"as are the species coming from interpolated variables","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"species(rn)","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"note: Note\nWhen using interpolation, expressions like 2$spec won't work; the multiplication symbol must be explicitly included like 2*$spec.","category":"page"},{"location":"catalyst_functionality/dsl_description/#Including-observables","page":"The Reaction DSL","title":"Including observables","text":"","category":"section"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Sometimes, one might want to include observable variables. These are variables that can be computed directly from the other system variables (rather than having their values implicitly given through some differential equation). These can be introduced through the @observables option.","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Let us consider a simple example where two species (X and Y) are produced and degraded at constant rates. They can also bind, forming a complex (XY). If we want to access the total amount of X in the system we can create an observable that denotes this quantity (Xtot = X + XY). Here, we create observables for the total amount of X and Y:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"using Catalyst # hide\nrn = @reaction_network begin\n  @observables begin\n    Xtot ~ X + XY\n    Ytot ~ Y + XY\n  end\n  (pX,dX), 0 <--> X\n  (pY,dY), 0 <--> Y\n  (kB,kD), X + Y <--> XY\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The @observables option is followed by one line for each observable formula (enclosed by a begin ... end block). The left-hand sides indicate the observables' names, and the right-hand sides how their values are computed. The two sides are separated by a ~. ","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"If we now simulate our model:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"using DifferentialEquations # hide\nu0 = [:X => 0.0, :Y => 0.0, :XY => 0.0]\ntspan = (0.0, 10.0)\nps = [:pX => 1.0, :dX => 0.2, :pY => 1.0, :dY => 0.5, :kB => 1.0, :kD => 0.2]\noprob = ODEProblem(rn, u0, tspan, ps)\nsol = solve(oprob)\nnothing # hide","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"we can index the solution using our observables (just like for other variables). E.g. we can receive a vector with all Xtot values using","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"sol[:Xtot]","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"similarly, we can plot the values of Xtot and Ytot using","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"plot(sol; idxs=[:Xtot, :Ytot], label=[\"Total X\" \"Total Y\"])","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"If we only wish to provide a single observable, the begin ... end block is note required. E.g., to record only the total amount of X we can use:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"using Catalyst # hide\nrn = @reaction_network begin\n  @observables Xtot ~ X + XY\n  (pX,dX), 0 <--> X\n  (pY,dY), 0 <--> Y\n  (kB,kD), X + Y <--> XY\nend","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Finally, some general rules for creating observables:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Observables can depend on any species, parameters, or variables, but not on other observables.\nAll observables components appearing on the right side of the ~ must be declared somewhere (i.e., they cannot only appear as a part of the observables formula).\nOnly a single @observables option block can be used in each @reaction_network call.\nThe left-hand side of the observables expression must be a single symbol, indicating the observable's name.\nMetadata can, however, be provided, e.g through @observables (Xtot, [description=\"Total amount of X\"]) ~ X + XY.\nThe right-hand side of the observables expression can be any valid algebraic expression.\nObservables are (by default, but this can be changed) considered variables (and not species). This can be changed by e.g. pre-declaring them using the @species option:","category":"page"},{"location":"catalyst_functionality/dsl_description/","page":"The Reaction DSL","title":"The Reaction DSL","text":"using Catalyst # hide\nrn = @reaction_network begin\n  @species Xtot(t)\n  @observables Xtot ~ X1 + X2\n  (k1,k2), X1 <--> X2\nend\nnothing # hide","category":"page"},{"location":"api/catalyst_api/#Catalyst.jl-API","page":"API","title":"Catalyst.jl API","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"CurrentModule = Catalyst","category":"page"},{"location":"api/catalyst_api/#Reaction-network-generation-and-representation","page":"API","title":"Reaction network generation and representation","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"Catalyst provides the @reaction_network macro for generating a complete network, stored as a ReactionSystem, which in turn is composed of Reactions. ReactionSystems can be converted to other ModelingToolkit.AbstractSystems, including a ModelingToolkit.ODESystem, ModelingToolkit.SDESystem, or ModelingToolkit.JumpSystem.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"When using the @reaction_network macro, Catalyst will automatically attempt to detect what is a species and what is a parameter. Everything that appear as a substrate or product in some reaction will be treated as a species, while all remaining symbols will be considered parameters (corresponding to those symbols that only appear within rate expressions and/or as stoichiometric coefficients). I.e. in","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"rn = @reaction_network begin\n    k*X, Y --> W\nend","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"Y and W will all be classified as chemical species, while k and X will be classified as parameters.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"The ReactionSystem generated by the @reaction_network macro is a ModelingToolkit.AbstractSystem that symbolically represents a system of chemical reactions. In some cases it can be convenient to bypass the macro and directly generate a collection of symbolic Reactions and a corresponding ReactionSystem encapsulating them. Below we illustrate with a simple SIR example how a system can be directly constructed, and demonstrate how to then generate from the ReactionSystem and solve corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"using Catalyst, DifferentialEquations, Plots\n@parameters β γ\n@variables t\n@species S(t) I(t) R(t)\n\nrxs = [Reaction(β, [S,I], [I], [1,1], [2])\n       Reaction(γ, [I], [R])]\n@named rs = ReactionSystem(rxs, t)\n\nu₀map    = [S => 999.0, I => 1.0, R => 0.0]\nparammap = [β => 1/10000, γ => 0.01]\ntspan    = (0.0, 250.0)\n\n# solve as ODEs\nodesys = convert(ODESystem, rs)\noprob = ODEProblem(odesys, u₀map, tspan, parammap)\nsol = solve(oprob, Tsit5())\np1 = plot(sol, title = \"ODE\")\n\n# solve as SDEs\nsdesys = convert(SDESystem, rs)\nsprob = SDEProblem(sdesys, u₀map, tspan, parammap)\nsol = solve(sprob, EM(), dt=.01)\np2 = plot(sol, title = \"SDE\")\n\n# solve as jump process\njumpsys = convert(JumpSystem, rs)\nu₀map    = [S => 999, I => 1, R => 0]\ndprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)\njprob = JumpProblem(jumpsys, dprob, Direct())\nsol = solve(jprob, SSAStepper())\np3 = plot(sol, title = \"jump\")\n\nplot(p1, p2, p3; layout = (3,1))","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"@reaction_network\nmake_empty_network\n@reaction\nReaction\nReactionSystem","category":"page"},{"location":"api/catalyst_api/#Catalyst.@reaction_network","page":"API","title":"Catalyst.@reaction_network","text":"@reaction_network\n\nGenerates a ReactionSystem that encodes a chemical reaction network.\n\nSee The Reaction DSL documentation for details on parameters to the macro.\n\nExamples:\n\n# a basic SIR model, with name SIR\nsir_model = @reaction_network SIR begin\n    c1, s + i --> 2i\n    c2, i --> r\nend\n\n# a basic SIR model, with random generated name\nsir_model = @reaction_network begin\n    c1, s + i --> 2i\n    c2, i --> r\nend\n\n# an empty network with name empty\nemptyrn = @reaction_network empty\n\n# an empty network with random generated name\nemptyrn = @reaction_network\n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.make_empty_network","page":"API","title":"Catalyst.make_empty_network","text":"make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))\n\nConstruct an empty ReactionSystem. iv is the independent variable, usually time, and name is the name to give the ReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.@reaction","page":"API","title":"Catalyst.@reaction","text":"@reaction\n\nGenerates a single Reaction object.\n\nExamples:\n\nrx = @reaction k*v, A + B --> C + D\n\n# is equivalent to\n@parameters k v\n@variables t\n@species A(t) B(t) C(t) D(t)\nrx == Reaction(k*v, [A,B], [C,D])\n\nHere k and v will be parameters and A, B, C and D will be variables. Interpolation of existing parameters/variables also works\n\n@parameters k b\n@variables t\n@species A(t)\nex = k*A^2 + t\nrx = @reaction b*$ex*$A, $A --> C\n\nNotes:\n\nAny symbols arising in the rate expression that aren't interpolated are treated as parameters. In the reaction part (α*A + B --> C + D), coefficients are treated as parameters, e.g. α, and rightmost symbols as species, e.g. A,B,C,D.\nWorks with any single arrow types supported by @reaction_network.\nInterpolation of Julia variables into the macro works similar to the @reaction_network macro. See The Reaction DSL tutorial for more details.\n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.Reaction","page":"API","title":"Catalyst.Reaction","text":"struct Reaction{R, S, T}\n\nOne chemical reaction.\n\nFields\n\nrate: The rate function (excluding mass action terms).\nsubstrates: Reaction substrates.\nproducts: Reaction products.\nsubstoich: The stoichiometric coefficients of the reactants.\nprodstoich: The stoichiometric coefficients of the products.\nnetstoich: The net stoichiometric coefficients of all species changed by the reaction.\nonly_use_rate: false (default) if rate should be multiplied by mass action terms to give the rate law. true if rate represents the full reaction rate law.\n\nmetadata: Contain additional data, such whenever the reaction have a specific noise-scaling expression for the chemical Langevin equation.\n\nExamples\n\nusing Catalyst\n@parameters k[1:20]\n@variables t\n@species A(t) B(t) C(t) D(t)\nrxs = [Reaction(k[1], nothing, [A]),            # 0 -> A\n       Reaction(k[2], [B], nothing),            # B -> 0\n       Reaction(k[3],[A],[C]),                  # A -> C\n       Reaction(k[4], [C], [A,B]),              # C -> A + B\n       Reaction(k[5], [C], [A], [1], [2]),      # C -> A + A\n       Reaction(k[6], [A,B], [C]),              # A + B -> C\n       Reaction(k[7], [B], [A], [2], [1]),      # 2B -> A\n       Reaction(k[8], [A,B], [A,C]),            # A + B -> A + C\n       Reaction(k[9], [A,B], [C,D]),            # A + B -> C + D\n       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -> C + D\n       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -> A + B\n       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -> 2C + 3D\n       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -> 0\n       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -> 2A\n       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -> 0 with custom rate\n       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -> B with custom rate.\n       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -> D with non constant rate.\n       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -> 2B with non constant rate.\n       Reaction(k[19]*t, [A], [B]),                                # A -> B with non constant rate.\n       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -> 2C with non constant rate.\n  ]\n\nNotes:\n\nnothing can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to nothing.\nThe three-argument form assumes all reactant and product stoichiometric coefficients are one.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Catalyst.ReactionSystem","page":"API","title":"Catalyst.ReactionSystem","text":"struct ReactionSystem{V<:Catalyst.NetworkProperties} <: AbstractTimeDependentSystem\n\nA system of chemical reactions.\n\nFields\n\neqs: The equations (reactions and algebraic/differential) defining the system.\nrxs: The Reactions defining the system.\niv: Independent variable (usually time).\nsivs: Spatial independent variables\nstates: All dependent (state) variables, species and non-species. Must not contain the independent variable.\nspecies: Dependent state variables representing species\nps: Parameter variables. Must not contain the independent variable.\nvar_to_name: Maps Symbol to corresponding variable.\nobserved: Equations for observed variables.\nname: The name of the system\nsystems: Internal sub-systems\ndefaults: The default values to use when initial conditions and/or parameters are not supplied in ODEProblem.\n\nconnection_type: Type of the system\nnetworkproperties: NetworkProperties object that can be filled in by API functions. INTERNAL – not considered part of the public API.\ncombinatoric_ratelaws: Sets whether to use combinatoric scalings in rate laws. true by default.\ncontinuous_events: continuous_events: A Vector{SymbolicContinuousCallback} that model events. The integrator will use root finding to guarantee that it steps at each zero crossing.\n\ndiscrete_events: discrete_events: A Vector{SymbolicDiscreteCallback} that models events. Symbolic analog to SciMLBase.DiscreteCallback that executes an affect when a given condition is true at the end of an integration step.\n\ncomplete: complete: if a model sys is complete, then sys.x no longer performs namespacing.\n\nExample\n\nContinuing from the example in the Reaction definition:\n\n# simple constructor that infers species and parameters\n@named rs = ReactionSystem(rxs, t)\n\n# allows specification of species and parameters\n@named rs = ReactionSystem(rxs, t, [A,B,C,D], k)\n\nKeyword Arguments:\n\nobserved::Vector{Equation}, equations specifying observed variables.\nsystems::Vector{AbstractSystems}, vector of sub-systems. Can be ReactionSystems, ODESystems, or NonlinearSystems.\nname::Symbol, the name of the system (must be provided, or @named must be used).\ndefaults::Dict, a dictionary mapping parameters to their default values and species to their default initial values.\nchecks = true, boolean for whether to check units.\nnetworkproperties = NetworkProperties(), cache for network properties calculated via API functions.\ncombinatoric_ratelaws = true, sets the default value of combinatoric_ratelaws used in calls to convert or calling various problem types with the ReactionSystem.\nbalanced_bc_check = true, sets whether to check that BC species appearing in reactions are balanced (i.e appear as both a substrate and a product with the same stoichiometry).\n\nNotes:\n\nReactionSystems currently do rudimentary unit checking, requiring that all species have the same units, and all reactions have rate laws with units of (species units) / (time units). Unit checking can be disabled by passing the keyword argument checks=false.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#api_accessor_functions","page":"API","title":"ModelingToolkit and Catalyst accessor functions","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"A ReactionSystem is an instance of a ModelingToolkit.AbstractTimeDependentSystem, and has a number of fields that can be accessed using the Catalyst API and the ModelingToolkit.jl Abstract System Interface. Below we overview these components.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"There are three basic sets of convenience accessors that will return information either from a top-level system, the top-level system and all sub-systems that are also ReactionSystems (i.e. the full reaction-network), or the top-level system, all subs-systems, and all constraint systems (i.e. the full model). To retrieve info from just a base ReactionSystem rn, ignoring sub-systems of rn, one can use the ModelingToolkit accessors (these provide direct access to the corresponding internal fields of the ReactionSystem)","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"ModelingToolkit.get_states(rn) is a vector that collects all the species defined within rn, ordered by species and then non-species variables.\nCatalyst.get_species(rn) is a vector of all the species variables in the system. The entries in get_species(rn) correspond to the first length(get_species(rn)) components in get_states(rn).\nModelingToolkit.get_ps(rn) is a vector that collects all the parameters defined within reactions in rn.\nModelingToolkit.get_eqs(rn) is a vector that collects all the Reactions and Symbolics.Equation defined within rn, ordering all Reactions before Equations.\nCatalyst.get_rxs(rn) is a vector of all the Reactions in rn, and corresponds to the first length(get_rxs(rn)) entries in get_eqs(rn).\nModelingToolkit.get_iv(rn) is the independent variable used in the system (usually t to represent time).\nModelingToolkit.get_systems(rn) is a vector of all sub-systems of rn.\nModelingToolkit.get_defaults(rn) is a dictionary of all the default values for parameters and species in rn.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"The preceding accessors do not allocate, directly accessing internal fields of the ReactionSystem.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"To retrieve information from the full reaction network represented by a system rn, which corresponds to information within both rn and all sub-systems, one can call:","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"ModelingToolkit.states(rn) returns all species and variables across the system, all sub-systems, and all constraint systems. Species are ordered before non-species variables in states(rn), with the first numspecies(rn) entires in states(rn) being the same as species(rn).\nspecies(rn) is a vector collecting all the chemical species within the system and any sub-systems that are also ReactionSystems.\nModelingToolkit.parameters(rn) returns all parameters across the system, all sub-systems, and all constraint systems.\nreactionparams(rn) is a vector of all the parameters within the system and any sub-systems that are also ReactionSystems. These include all parameters that appear within some Reaction.\nModelingToolkit.equations(rn) returns all Reactions and all Symbolics.Equations defined across the system, all sub-systems, and all constraint systems. Reactions are ordered ahead of Equations with the first numreactions(rn) entries in equations(rn) being the same as reactions(rn).\nreactions(rn) is a vector of all the Reactions within the system and any sub-systems that are also ReactionSystems.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"These accessors will generally allocate new arrays to store their output unless there are no subsystems. In the latter case the usually return the same vector as the corresponding get_* function.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"Below we list the remainder of the Catalyst API accessor functions mentioned above.","category":"page"},{"location":"api/catalyst_api/#Basic-system-properties","page":"API","title":"Basic system properties","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"See Programmatic Construction of Symbolic Reaction Systems for examples and ModelingToolkit and Catalyst Accessor Functions for more details on the basic accessor functions.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"species\nnonspecies\nreactionparams\nreactions\nnumspecies\nnumparams\nnumreactions\nnumreactionparams\nspeciesmap\nparamsmap\nreactionparamsmap\nisspecies\nCatalyst.isconstant\nCatalyst.isbc","category":"page"},{"location":"api/catalyst_api/#Catalyst.species","page":"API","title":"Catalyst.species","text":"species(network)\n\nGiven a ReactionSystem, return a vector of all species defined in the system and any subsystems that are of type ReactionSystem. To get the species and non-species variables in the system and all subsystems, including non-ReactionSystem subsystems, uses states(network).\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is non-empty will allocate.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.nonspecies","page":"API","title":"Catalyst.nonspecies","text":"nonspecies(network)\n\nReturn the non-species variables within the network, i.e. those states for which isspecies == false.\n\nNotes:\n\nAllocates a new array to store the non-species variables.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactionparams","page":"API","title":"Catalyst.reactionparams","text":"reactionparams(network)\n\nGiven a ReactionSystem, return a vector of all parameters defined within the system and any subsystems that are of type ReactionSystem. To get the parameters in the system and all subsystems, including non-ReactionSystem subsystems, use parameters(network).\n\nNotes:\n\nAllocates and has to calculate these dynamically by comparison for each reaction.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactions","page":"API","title":"Catalyst.reactions","text":"reactions(network)\n\nGiven a ReactionSystem, return a vector of all Reactions in the system.\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is not empty, will allocate.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numspecies","page":"API","title":"Catalyst.numspecies","text":"numspecies(network)\n\nReturn the total number of species within the given ReactionSystem and subsystems that are ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numparams","page":"API","title":"Catalyst.numparams","text":"numparams(network)\n\nReturn the total number of parameters within the given system and all subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numreactions","page":"API","title":"Catalyst.numreactions","text":"numreactions(network)\n\nReturn the total number of reactions within the given ReactionSystem and subsystems that are ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numreactionparams","page":"API","title":"Catalyst.numreactionparams","text":"numreactionparams(network)\n\nReturn the total number of parameters within the given ReactionSystem and subsystems that are ReactionSystems.\n\nNotes\n\nIf there are no subsystems this will be fast.\nAs this calls reactionparams, it can be slow and will allocate if there are any subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.speciesmap","page":"API","title":"Catalyst.speciesmap","text":"speciesmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping species that participate in Reactions to their index within species(network).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.paramsmap","page":"API","title":"Catalyst.paramsmap","text":"paramsmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping from all parameters that appear within the system to their index within parameters(network).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactionparamsmap","page":"API","title":"Catalyst.reactionparamsmap","text":"reactionparamsmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping from parameters that appear within Reactions to their index within reactionparams(network).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.isspecies","page":"API","title":"Catalyst.isspecies","text":"isspecies(s)\n\nTests if the given symbolic variable corresponds to a chemical species.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.isconstant","page":"API","title":"Catalyst.isconstant","text":"Catalyst.isconstant(s)\n\nTests if the given symbolic variable corresponds to a constant species.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.isbc","page":"API","title":"Catalyst.isbc","text":"Catalyst.isbc(s)\n\nTests if the given symbolic variable corresponds to a boundary condition species.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Basic-reaction-properties","page":"API","title":"Basic reaction properties","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"ismassaction\ndependents\ndependants\nsubstoichmat\nprodstoichmat\nnetstoichmat\nreactionrates\nget_metadata_dict\nhas_metadata\nget_metadata","category":"page"},{"location":"api/catalyst_api/#Catalyst.ismassaction","page":"API","title":"Catalyst.ismassaction","text":"ismassaction(rx, rs; rxvars = get_variables(rx.rate),\n                              haveivdep = nothing,\n                              stateset = Set(states(rs)),\n                              ivset = nothing)\n\nTrue if a given reaction is of mass action form, i.e. rx.rate does not depend on any chemical species that correspond to states of the system, and does not depend explicitly on the independent variable (usually time).\n\nArguments\n\nrx, the Reaction.\nrs, a ReactionSystem containing the reaction.\nOptional: rxvars, Variables which are not in rxvars are ignored as possible dependencies.\nOptional: haveivdep, true if the Reaction rate field explicitly depends on any independent variable (i.e. t or for spatial systems x,y,etc). If not set, will be automatically calculated.\nOptional: stateset, set of states which if the rxvars are within mean rx is non-mass action.\nOptional: ivset, a Set of the independent variables of the system. If not provided and the system is spatial, i.e. isspatial(rs) == true, it will be created with all the spatial variables and the time variable. If the rate expression contains any element of ivset, then ismassaction(rx,rs) == false. Pass a custom set to control this behavior.\n\nNotes:\n\nNon-integer stoichiometry is treated as non-mass action. This includes symbolic variables/terms or floating point numbers for stoichiometric coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.dependents","page":"API","title":"Catalyst.dependents","text":"dependents(rx, network)\n\nGiven a Reaction and a ReactionSystem, return a vector of the non-constant species and variables the reaction rate law depends on. e.g., for\n\nk*W, 2X + 3Y --> 5Z + W\n\nthe returned vector would be [W(t),X(t),Y(t)].\n\nNotes:\n\nAllocates\nDoes not check for dependents within any subsystems.\nConstant species are not considered dependents since they are internally treated as parameters.\nIf the rate expression depends on a non-species state variable that will be included in the dependents, i.e. in\n@parameters k\n@variables t V(t)\n@species A(t) B(t) C(t)\nrx = Reaction(k*V, [A, B], [C])\n@named rs = ReactionSystem([rx], t)\nissetequal(dependents(rx, rs), [A,B,V]) == true\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.dependants","page":"API","title":"Catalyst.dependants","text":"dependents(rx, network)\n\nSee documentation for dependents.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.substoichmat","page":"API","title":"Catalyst.substoichmat","text":"substoichmat(rn; sparse=false)\n\nReturns the substrate stoichiometry matrix, S, with S_i j the stoichiometric coefficient of the ith substrate within the jth reaction.\n\nNote:\n\nSet sparse=true for a sparse matrix representation\nNote that constant species are not considered substrates, but just components that modify the associated rate law.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.prodstoichmat","page":"API","title":"Catalyst.prodstoichmat","text":"prodstoichmat(rn; sparse=false)\n\nReturns the product stoichiometry matrix, P, with P_i j the stoichiometric coefficient of the ith product within the jth reaction.\n\nNote:\n\nSet sparse=true for a sparse matrix representation\nNote that constant species are not treated as products, but just components that modify the associated rate law.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.netstoichmat","page":"API","title":"Catalyst.netstoichmat","text":"netstoichmat(rn, sparse=false)\n\nReturns the net stoichiometry matrix, N, with N_i j the net stoichiometric coefficient of the ith species within the jth reaction.\n\nNotes:\n\nSet sparse=true for a sparse matrix representation\nCaches the matrix internally within rn so subsequent calls are fast.\nNote that constant species are not treated as reactants, but just components that modify the associated rate law. As such they do not contribute to the net stoichiometry matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactionrates","page":"API","title":"Catalyst.reactionrates","text":"reactionrates(network)\n\nGiven a ReactionSystem, returns a vector of the symbolic reaction rates for each reaction.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.get_metadata_dict","page":"API","title":"Catalyst.get_metadata_dict","text":"get_metadata_dict(reaction::Reaction)\n\nRetrives the ImmutableDict containing all of the metadata associated with a specific reaction.\n\nArguments:\n\nreaction: The reaction for which we wish to retrive all metadata.\n\nExample:\n\nreaction = @reaction k, 0 --> X, [description=\"Production reaction\"]\nget_metadata_dict(reaction)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.has_metadata","page":"API","title":"Catalyst.has_metadata","text":"has_metadata(reaction::Reaction, md_key::Symbol)\n\nChecks if a Reaction have a certain metadata field. If it does, returns true (else returns false).\n\nArguments:\n\nreaction: The reaction for which we wish to check if a specific metadata field exist.\nmd_key: The metadata for which we wish to check existence of.\n\nExample:\n\nreaction = @reaction k, 0 --> X, [description=\"Production reaction\"]\nhas_metadata(reaction, :description)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.get_metadata","page":"API","title":"Catalyst.get_metadata","text":"get_metadata(reaction::Reaction, md_key::Symbol)\n\nRetrives a certain metadata value from a Reaction. If the metadata does not exists, throws an error.\n\nArguments:\n\nreaction: The reaction for which we wish to retrive a specific metadata value.\nmd_key: The metadata for which we wish to retrive.\n\nExample:\n\nreaction = @reaction k, 0 --> X, [description=\"Production reaction\"]\nget_metadata(reaction, :description)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#api_network_extension_and_modification","page":"API","title":"Functions to extend or modify a network","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"ReactionSystems can be programmatically extended using @add_reactions, addspecies!, addparam! and addreaction!, or using ModelingToolkit.extend and ModelingToolkit.compose.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"@add_reactions\naddspecies!\naddparam!\naddreaction!\nsetdefaults!\nModelingToolkit.extend\nModelingToolkit.compose\nCatalyst.flatten\nmerge!(network1::ReactionSystem, network2::ReactionSystem)\nreorder_states!","category":"page"},{"location":"api/catalyst_api/#Catalyst.@add_reactions","page":"API","title":"Catalyst.@add_reactions","text":"@add_reactions\n\nAdds the reactions declared to a preexisting ReactionSystem. Note, mutates the original network.\n\nNotes:\n\nTo instead generate a new network by combining two existing networks use ModelingToolkit.extend.\n\nExample:\n\nrn = @reaction_network begin\n    @parameters G\n    π, 2*A --> B\n    end\n\n# add this reaction into rn\n@add_reactions rn begin\n    k*A, C --> D\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.addspecies!","page":"API","title":"Catalyst.addspecies!","text":"addspecies!(network::ReactionSystem, s::Symbolic; disablechecks=false)\n\nGiven a ReactionSystem, add the species corresponding to the variable s to the network (if it is not already defined). Returns the integer id of the species within the system.\n\nNotes:\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\naddspecies!(network::ReactionSystem, s::Num; disablechecks=false)\n\nGiven a ReactionSystem, add the species corresponding to the variable s to the network (if it is not already defined). Returns the integer id of the species within the system.\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.addparam!","page":"API","title":"Catalyst.addparam!","text":"addparam!(network::ReactionSystem, p::Symbolic; disablechecks=false)\n\nGiven a ReactionSystem, add the parameter corresponding to the variable p to the network (if it is not already defined). Returns the integer id of the parameter within the system.\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\naddparam!(network::ReactionSystem, p::Num; disablechecks=false)\n\nGiven a ReactionSystem, add the parameter corresponding to the variable p to the network (if it is not already defined). Returns the integer id of the parameter within the system.\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.addreaction!","page":"API","title":"Catalyst.addreaction!","text":"addreaction!(network::ReactionSystem, rx::Reaction)\n\nAdd the passed in reaction to the ReactionSystem. Returns the integer id of rx in the list of Reactions within network.\n\nNotes:\n\nAny new species or parameters used in rx should be separately added to   network using addspecies! and addparam!.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.setdefaults!","page":"API","title":"Catalyst.setdefaults!","text":"setdefaults!(rn, newdefs)\n\nSets the default (initial) values of parameters and species in the ReactionSystem, rn.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsetdefaults!(sir, [:S => 999.0, :I => 1.0, :R => 1.0, :β => 1e-4, :ν => .01])\n\n# or\n@parameter β ν\n@variables t\n@species S(t) I(t) R(t)\nsetdefaults!(sir, [S => 999.0, I => 1.0, R => 0.0, β => 1e-4, ν => .01])\n\ngives initial/default values to each of S, I and β\n\nNotes:\n\nCan not be used to set default values for species, variables or parameters of subsystems or constraint systems. Either set defaults for those systems directly, or flatten to collate them into one system before setting defaults.\nDefaults can be specified in any iterable container of symbols to value pairs or symbolics to value pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.extend","page":"API","title":"ModelingToolkit.extend","text":"extend(\n    sys::ModelingToolkit.AbstractSystem,\n    basesys::ModelingToolkit.AbstractSystem;\n    name,\n    gui_metadata\n) -> ReactionSystem{Catalyst.NetworkProperties{Int64, V}} where V<:SymbolicUtils.BasicSymbolic{Real}\n\n\nextend the basesys with sys, the resulting system would inherit sys's name by default.\n\n\n\n\n\nModelingToolkit.extend(sys::AbstractSystem, rs::ReactionSystem; name::Symbol=nameof(sys))\n\nExtends the indicated ReactionSystem with another AbstractSystem.\n\nNotes:\n\nThe AbstractSystem being added in must be an ODESystem, NonlinearSystem, or ReactionSystem currently.\nReturns a new ReactionSystem and does not modify rs.\nBy default, the new ReactionSystem will have the same name as sys.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.compose","page":"API","title":"ModelingToolkit.compose","text":"compose(sys, systems; name)\n\n\ncompose multiple systems together. The resulting system would inherit the first system's name.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.flatten","page":"API","title":"ModelingToolkit.flatten","text":"Catalyst.flatten(rs::ReactionSystem)\n\nMerges all subsystems of the given ReactionSystem up into rs.\n\nNotes:\n\nReturns a new ReactionSystem that represents the flattened system.\nAll Reactions within subsystems are namespaced and merged into the list of Reactions of rs. The merged list is then available as reactions(rs).\nAll algebraic and differential equations are merged in the equations of rs.\nCurrently only ReactionSystems, NonlinearSystems and ODESystems are supported as sub-systems when flattening.\nrs.networkproperties is reset upon flattening.\nThe default value of combinatoric_ratelaws will be the logical or of all ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Base.merge!-Tuple{ReactionSystem, ReactionSystem}","page":"API","title":"Base.merge!","text":"merge!(network1::ReactionSystem, network2::ReactionSystem)\n\nMerge network2 into network1.\n\nNotes:\n\nDuplicate reactions between the two networks are not filtered out.\nReactions are not deepcopied to minimize allocations, so both networks will share underlying data arrays.\nSubsystems are not deepcopied between the two networks and will hence be shared.\nReturns network1.\ncombinatoric_ratelaws is the value of network1.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Catalyst.reorder_states!","page":"API","title":"Catalyst.reorder_states!","text":"reorder_states!(rn, neworder)\n\nGiven a ReactionSystem and a vector neworder, reorders the states of rn, i.e. get_states(rn), according to neworder.\n\nNotes:\n\nCurrently only supports ReactionSystems without subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Network-analysis-and-representations","page":"API","title":"Network analysis and representations","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"conservationlaws\nconservedquantities\nconservedequations\nconservationlaw_constants\nReactionComplexElement\nReactionComplex\nreactioncomplexmap\nreactioncomplexes\nincidencemat\ncomplexstoichmat\ncomplexoutgoingmat\nincidencematgraph\nlinkageclasses\ndeficiency\nsubnetworks\nlinkagedeficiencies\nisreversible\nisweaklyreversible\nreset_networkproperties!","category":"page"},{"location":"api/catalyst_api/#Catalyst.conservationlaws","page":"API","title":"Catalyst.conservationlaws","text":"conservationlaws(netstoichmat::AbstractMatrix)::Matrix\n\nGiven the net stoichiometry matrix of a reaction system, computes a matrix of conservation laws, each represented as a row in the output.\n\n\n\n\n\nconservationlaws(rs::ReactionSystem)\n\nReturn the conservation law matrix of the given ReactionSystem, calculating it if it is not already stored within the system, or returning an alias to it.\n\nNotes:\n\nThe first time being called it is calculated and cached in rn, subsequent calls should be fast.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.conservedquantities","page":"API","title":"Catalyst.conservedquantities","text":"conservedquantities(state, cons_laws)\n\nCompute conserved quantities for a system with the given conservation laws.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.conservedequations","page":"API","title":"Catalyst.conservedequations","text":"conservedequations(rn::ReactionSystem)\n\nCalculate symbolic equations from conservation laws, writing dependent variables as functions of independent variables and the conservation law constants.\n\nNotes:\n\nCaches the resulting equations in rn, so will be fast on subsequent calls.\n\nExamples:\n\nrn = @reaction_network begin\n    k, A + B --> C\n    k2, C --> A + B\n    end\nconservedequations(rn)\n\ngives\n\n2-element Vector{Equation}:\n B(t) ~ A(t) + Γ[1]\n C(t) ~ Γ[2] - A(t)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.conservationlaw_constants","page":"API","title":"Catalyst.conservationlaw_constants","text":"conservationlaw_constants(rn::ReactionSystem)\n\nCalculate symbolic equations from conservation laws, writing the conservation law constants in terms of the dependent and independent variables.\n\nNotes:\n\nCaches the resulting equations in rn, so will be fast on subsequent calls.\n\nExamples:\n\nrn = @reaction_network begin\n    k, A + B --> C\n    k2, C --> A + B\n    end\nconservationlaw_constants(rn)\n\ngives\n\n2-element Vector{Equation}:\n Γ[1] ~ B(t) - A(t)\n Γ[2] ~ A(t) + C(t)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.ReactionComplexElement","page":"API","title":"Catalyst.ReactionComplexElement","text":"struct ReactionComplexElement{T}\n\nOne reaction complex element\n\nFields\n\nspeciesid: The integer id of the species representing this element.\nspeciesstoich: The stoichiometric coefficient of this species.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Catalyst.ReactionComplex","page":"API","title":"Catalyst.ReactionComplex","text":"struct ReactionComplex{V<:Integer} <: AbstractArray{Catalyst.ReactionComplexElement{V<:Integer}, 1}\n\nOne reaction complex.\n\nFields\n\nspeciesids: The integer ids of all species participating in this complex.\nspeciesstoichs: The stoichiometric coefficients of all species participating in this complex.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Catalyst.reactioncomplexmap","page":"API","title":"Catalyst.reactioncomplexmap","text":"reactioncomplexmap(rn::ReactionSystem)\n\nFind each ReactionComplex within the specified system, constructing a mapping from the complex to vectors that indicate which reactions it appears in as substrates and products.\n\nNotes:\n\nEach ReactionComplex is mapped to a vector of pairs, with each pair having the form reactionidx => ± 1, where -1 indicates the complex appears as a substrate and +1 as a product in the reaction with integer label reactionidx.\nConstant species are ignored as part of a complex. i.e. if species A is constant then the reaction A + B --> C + D is considered to consist of the complexes B and C + D. Likewise A --> B would be treated as the same as 0 --> B.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactioncomplexes","page":"API","title":"Catalyst.reactioncomplexes","text":"reactioncomplexes(network::ReactionSystem; sparse=false)\n\nCalculate the reaction complexes and complex incidence matrix for the given ReactionSystem.\n\nNotes:\n\nreturns a pair of a vector of ReactionComplexs and the complex incidence matrix.\nAn empty ReactionComplex denotes the null (∅) state (from reactions like ∅ -> A or A -> ∅).\nConstant species are ignored in generating a reaction complex. i.e. if A is constant then A –> B consists of the complexes ∅ and B.\nThe complex incidence matrix, B, is number of complexes by number of reactions with\n\nB_i j = begincases\n-1 textif the ith complex is the substrate of the jth reaction\n1 textif the ith complex is the product of the jth reaction\n0 textotherwise\nendcases\n\nSet sparse=true for a sparse matrix representation of the incidence matrix\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.incidencemat","page":"API","title":"Catalyst.incidencemat","text":"incidencemat(rn::ReactionSystem; sparse=false)\n\nCalculate the incidence matrix of rn, see reactioncomplexes.\n\nNotes:\n\nIs cached in rn so that future calls, assuming the same sparsity, will also be fast.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.complexstoichmat","page":"API","title":"Catalyst.complexstoichmat","text":"complexstoichmat(network::ReactionSystem; sparse=false)\n\nGiven a ReactionSystem and vector of reaction complexes, return a matrix with positive entries of size number of species by number of complexes, where the non-zero positive entries in the kth column denote stoichiometric coefficients of the species participating in the kth reaction complex.\n\nNotes:\n\nSet sparse=true for a sparse matrix representation\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.complexoutgoingmat","page":"API","title":"Catalyst.complexoutgoingmat","text":"complexoutgoingmat(network::ReactionSystem; sparse=false)\n\nGiven a ReactionSystem and complex incidence matrix, B, return a matrix of size num of complexes by num of reactions that identifies substrate complexes.\n\nNotes:\n\nThe complex outgoing matrix, Delta, is defined by\n\nDelta_i j = begincases\n    = 0    textif  B_i j = 1 \n    = B_i j textotherwise\nendcases\n\nSet sparse=true for a sparse matrix representation\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.incidencematgraph","page":"API","title":"Catalyst.incidencematgraph","text":"incidencematgraph(rn::ReactionSystem)\n\nConstruct a directed simple graph where nodes correspond to reaction complexes and directed edges to reactions converting between two complexes.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\ncomplexes,incidencemat = reactioncomplexes(sir)\nincidencematgraph(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.linkageclasses","page":"API","title":"Catalyst.linkageclasses","text":"linkageclasses(rn::ReactionSystem)\n\nGiven the incidence graph of a reaction network, return a vector of the connected components of the graph (i.e. sub-groups of reaction complexes that are connected in the incidence graph).\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\ncomplexes,incidencemat = reactioncomplexes(sir)\nlinkageclasses(sir)\n\ngives\n\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [3, 4]\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.deficiency","page":"API","title":"Catalyst.deficiency","text":"deficiency(rn::ReactionSystem)\n\nCalculate the deficiency of a reaction network.\n\nHere the deficiency, delta, of a network with n reaction complexes, ell linkage classes and a rank s stoichiometric matrix is\n\ndelta = n - ell - s\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nrcs,incidencemat = reactioncomplexes(sir)\nδ = deficiency(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.subnetworks","page":"API","title":"Catalyst.subnetworks","text":"subnetworks(rn::ReactionSystem)\n\nFind subnetworks corresponding to each linkage class of the reaction network.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\ncomplexes,incidencemat = reactioncomplexes(sir)\nsubnetworks(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.linkagedeficiencies","page":"API","title":"Catalyst.linkagedeficiencies","text":"linkagedeficiencies(network::ReactionSystem)\n\nCalculates the deficiency of each sub-reaction network within network.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nrcs,incidencemat = reactioncomplexes(sir)\nlinkage_deficiencies = linkagedeficiencies(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.isreversible","page":"API","title":"Catalyst.isreversible","text":"isreversible(rn::ReactionSystem)\n\nGiven a reaction network, returns if the network is reversible or not.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nrcs,incidencemat = reactioncomplexes(sir)\nisreversible(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.isweaklyreversible","page":"API","title":"Catalyst.isweaklyreversible","text":"isweaklyreversible(rn::ReactionSystem, subnetworks)\n\nDetermine if the reaction network with the given subnetworks is weakly reversible or not.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nrcs,incidencemat = reactioncomplexes(sir)\nsubnets = subnetworks(rn)\nisweaklyreversible(rn, subnets)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reset_networkproperties!","page":"API","title":"Catalyst.reset_networkproperties!","text":"reset_networkproperties!(rn::ReactionSystem)\n\nClears the cache of various properties (like the netstoichiometry matrix). Use if such properties need to be recalculated for some reason.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Network-comparison","page":"API","title":"Network comparison","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"==(rn1::Reaction, rn2::Reaction)\nisequivalent\n==(rn1::ReactionSystem, rn2::ReactionSystem)","category":"page"},{"location":"api/catalyst_api/#Base.:==-Tuple{Reaction, Reaction}","page":"API","title":"Base.:==","text":"==(rx1::Reaction, rx2::Reaction)\n\nTests whether two Reactions are identical.\n\nNotes:\n\nIgnores the order in which stoichiometry components are listed.\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Catalyst.isequivalent","page":"API","title":"Catalyst.isequivalent","text":"isequivalent(rn1::ReactionSystem, rn2::ReactionSystem; ignorenames = true)\n\nTests whether the underlying species, parameters and reactions are the same in the two ReactionSystems. Ignores the names of the systems in testing equality.\n\nNotes:\n\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\nDoes not include defaults in determining equality.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Base.:==-Tuple{ReactionSystem, ReactionSystem}","page":"API","title":"Base.:==","text":"==(rn1::ReactionSystem, rn2::ReactionSystem)\n\nTests whether the underlying species, parameters and reactions are the same in the two ReactionSystems. Requires the systems to have the same names too.\n\nNotes:\n\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\nDoes not include defaults in determining equality.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Network-visualization","page":"API","title":"Network visualization","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"Latexify can be used to convert networks to LaTeX equations by","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"using Latexify\nlatexify(rn)","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"An optional argument, form allows using latexify to display a reaction network's ODE (as generated by the reaction rate equation) or SDE (as generated by the chemical Langevin equation) form:","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"latexify(rn; form=:ode)","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"latexify(rn; form=:sde)","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"(As of writing this, an upstream bug causes the SDE form to be erroneously displayed as the ODE form)","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"Finally, another optional argument (expand_functions=true) automatically expands functions defined by Catalyst (such as mm). To disable this, set expand_functions=false.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"If Graphviz is installed and commandline accessible, it can be used to create and save network diagrams using Graph and savegraph.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"Graph\ncomplexgraph\nsavegraph","category":"page"},{"location":"api/catalyst_api/#Catalyst.Graph","page":"API","title":"Catalyst.Graph","text":"Graph(rn::ReactionSystem)\n\nConverts a ReactionSystem into a Graphviz graph. Reactions correspond to small green circles, and species to blue circles.\n\nNotes:\n\nBlack arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.\nBlack arrows from reactions to species indicate products, and are labelled with their output stoichiometry.\nRed arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction k*A, B --> C, there would be a red arrow from A to the reaction node. In k*A, A+B --> C, there would be red and black arrows from A to the reaction node.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Catalyst.complexgraph","page":"API","title":"Catalyst.complexgraph","text":"complexgraph(rn::ReactionSystem; complexdata=reactioncomplexes(rn))\n\nCreates a Graphviz graph of the ReactionComplexs in rn. Reactions correspond to arrows and reaction complexes to blue circles.\n\nNotes:\n\nBlack arrows from complexes to complexes indicate reactions whose rate is a parameter or a Number. i.e. k, A --> B.\nRed dashed arrows from complexes to complexes indicate reactions whose rate depends on species. i.e. k*C, A --> B for C a species.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.savegraph","page":"API","title":"Catalyst.savegraph","text":"savegraph(g::Graph, fname, fmt=\"png\")\n\nGiven a Graph generated by Graph, save the graph to the file with name fname and extension fmt.\n\nNotes:\n\nfmt=\"png\" is the default output format.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#api_rate_laws","page":"API","title":"Rate laws","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"As the underlying ReactionSystem is comprised of ModelingToolkit expressions, one can directly access the generated rate laws, and using ModelingToolkit tooling generate functions or Julia Exprs from them.","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"oderatelaw\njumpratelaw\nmm\nmmr\nhill\nhillr\nhillar","category":"page"},{"location":"api/catalyst_api/#Catalyst.oderatelaw","page":"API","title":"Catalyst.oderatelaw","text":"oderatelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the symbolic reaction rate law used in generated ODEs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X(t)^2*Y(t)*Z(t). For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe expression that is returned will be k * (X(t)^2/2) * (Y(t)^3/6).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses factorial scaling factors in calculating the   rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If   combinatoric_ratelaw=false then the ratelaw is k*S^2, i.e. the scaling   factor is ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.jumpratelaw","page":"API","title":"Catalyst.jumpratelaw","text":"jumpratelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the symbolic reaction rate law used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X^2*Y*Z. For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe expression that is returned will be k * binomial(X,2) * binomial(Y,3).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaw=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.mm","page":"API","title":"Catalyst.mm","text":"mm(X,v,K) = v*X / (X + K)\n\nA Michaelis-Menten rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.mmr","page":"API","title":"Catalyst.mmr","text":"mmr(X,v,K) = v*K / (X + K)\n\nA repressive Michaelis-Menten rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.hill","page":"API","title":"Catalyst.hill","text":"hill(X,v,K,n) = v*(X^n) / (X^n + K^n)\n\nA Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.hillr","page":"API","title":"Catalyst.hillr","text":"hillr(X,v,K,n) = v*(K^n) / (X^n + K^n)\n\nA repressive Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.hillar","page":"API","title":"Catalyst.hillar","text":"hillar(X,Y,v,K,n) = v*(X^n) / (X^n + Y^n + K^n)\n\nAn activation/repressing Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Transformations","page":"API","title":"Transformations","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"Base.convert\nModelingToolkit.structural_simplify","category":"page"},{"location":"api/catalyst_api/#Base.convert","page":"API","title":"Base.convert","text":"Base.convert(::Type{<:ODESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.ODESystem.\n\nKeyword args and default values:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\n\n\n\n\n\nBase.convert(::Type{<:NonlinearSystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.NonlinearSystem.\n\nKeyword args and default values:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\n\n\n\n\n\nBase.convert(::Type{<:SDESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.SDESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\nDoes not currently support ReactionSystems that include coupled algebraic or differential equations.\n\n\n\n\n\nBase.convert(::Type{<:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)\n\nConvert a ReactionSystem to an ModelingToolkit.JumpSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaws=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nDoes not currently support ReactionSystems that include coupled algebraic or differential equations.\nDoes not currently support continuous events as these are not supported by ModelingToolkit.JumpSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.structural_simplify","page":"API","title":"ModelingToolkit.structural_simplify","text":"structural_simplify(sys; ...)\nstructural_simplify(sys, io; simplify, kwargs...)\n\n\nStructurally simplify algebraic equations in a system and compute the topological sort of the observed equations. When simplify=true, the simplify function will be applied during the tearing process. It also takes kwargs allow_symbolic=false and allow_parameter=true which limits the coefficient types during tearing.\n\nThe optional argument io may take a tuple (inputs, outputs). This will convert all inputs to parameters and allow them to be unconnected, i.e., simplification will allow models where n_states = n_equations - n_inputs.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Chemistry-related-functionalities","page":"API","title":"Chemistry-related functionalities","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"Various functionalities primarily relevant to modelling of chemical systems (but potentially also in biology). ","category":"page"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"@compound\n@compounds\niscompound\ncomponents\ncoefficients\ncomponent_coefficients","category":"page"},{"location":"api/catalyst_api/#Catalyst.@compound","page":"API","title":"Catalyst.@compound","text":"@compound\n\nMacro that creates a compound species, which is composed of smaller component species.\n\nExample:\n\n@variables t\n@species C(t) O(t)\n@compound CO2(t) ~ C + 2O\n\nNotes: \n\nThe component species must be defined before using the @compound macro.\n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.@compounds","page":"API","title":"Catalyst.@compounds","text":"@compounds\n\nMacro that creates several compound species, which each is composed of smaller component species. Uses the same syntax as @compound, but with one compound species one each line.\n\nExample:\n\n@variables t\n@species C(t) H(t) O(t) \n@compounds\n    CH4(t) = C + 4H\n    O2(t) = 2O\n    CO2(t) = C + 2O\n    H2O(t) = 2H + O\nend\n\nNotes: \n\nThe component species must be defined before using the @compound macro.\n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.iscompound","page":"API","title":"Catalyst.iscompound","text":"iscompound(s)\n\nReturns true if the input is a compound species (else false).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.components","page":"API","title":"Catalyst.components","text":"components(s)\n\nReturns a vector with a list of all the components of a compound species (created using e.g. the @compound macro).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.coefficients","page":"API","title":"Catalyst.coefficients","text":"coefficients(s)\n\nReturns a vector with a list of all the stoichiometric coefficients of the components of a compound species (created using e.g. the @compound macro).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.component_coefficients","page":"API","title":"Catalyst.component_coefficients","text":"component_coefficients(s)\n\nReturns a Vector{Pari{Symbol,Int64}}, listing a compounds species (created using e.g. the @compound macro) all the coefficients and their stoichiometric coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Unit-validation","page":"API","title":"Unit validation","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"validate(rx::Reaction; info::String = \"\")\nvalidate(rs::ReactionSystem, info::String=\"\")","category":"page"},{"location":"api/catalyst_api/#ModelingToolkit.validate-Tuple{Reaction}","page":"API","title":"ModelingToolkit.validate","text":"validate(rx::Reaction; info::String = \"\")\n\nCheck that all substrates and products within the given Reaction have the same units, and that the units of the reaction's rate expression are internally consistent (i.e. if the rate involves sums, each term in the sum has the same units).\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#ModelingToolkit.validate","page":"API","title":"ModelingToolkit.validate","text":"validate(rs::ReactionSystem, info::String=\"\")\n\nCheck that all species in the ReactionSystem have the same units, and that the rate laws of all reactions reduce to units of (species units) / (time units).\n\nNotes:\n\nDoes not check subsystems, constraint equations, or non-species variables.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Utility-functions","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/catalyst_api/","page":"API","title":"API","text":"symmap_to_varmap","category":"page"},{"location":"api/catalyst_api/#Catalyst.symmap_to_varmap","page":"API","title":"Catalyst.symmap_to_varmap","text":"symmap_to_varmap(sys, symmap)\n\nGiven a system and map of Symbols to values, generates a map from corresponding symbolic variables/parameters to the values that can be used to pass initial conditions and parameter mappings.\n\nFor example,\n\nsir = @reaction_network sir begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsubsys = @reaction_network subsys begin\n    k, A --> B\nend\n@named sys = compose(sir, [subsys])\n\ngives\n\nModel sys with 3 equations\nStates (5):\n  S(t)\n  I(t)\n  R(t)\n  subsys₊A(t)\n  subsys₊B(t)\nParameters (3):\n  β\n  ν\n  subsys₊k\n\nto specify initial condition and parameter mappings from symbols we can use\n\nsymmap = [:S => 1.0, :I => 1.0, :R => 1.0, :subsys₊A => 1.0, :subsys₊B => 1.0]\nu0map  = symmap_to_varmap(sys, symmap)\npmap   = symmap_to_varmap(sys, [:β => 1.0, :ν => 1.0, :subsys₊k => 1.0])\n\nu0map and pmap can then be used as input to various problem types.\n\nNotes:\n\nAny Symbol, sym, within symmap must be a valid field of sys. i.e. sys.sym must be defined.\n\n\n\n\n\n","category":"function"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/#hodgkin_huxley_equation","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"","category":"section"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"This tutorial shows how to programmatically construct a Catalyst ReactionSystem that is coupled to a constraint ODE, corresponding to the Hodgkin–Huxley model for an excitable cell. The Hodgkin–Huxley model is a mathematical model that describes how action potentials in neurons are initiated and propagated. It is a continuous-time dynamical system given by a coupled system of nonlinear differential equations that model the electrical characteristics of excitable cells such as neurons and muscle cells.","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We begin by importing some necessary packages.","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"using ModelingToolkit, Catalyst, NonlinearSolve\nusing DifferentialEquations, Symbolics\nusing Plots","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We'll build a simple Hodgkin-Huxley model for a single neuron, with the voltage, V(t), included as a constraint ODE. We first specify the transition rates for three gating variables, m(t), n(t) and h(t).","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"s xleftrightarrowbeta_s(V(t))alpha_s(V(t)) s quad s in mnh","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Here each gating variable is used in determining the fraction of active (i.e. open) or inactive (m = 1 - m, n = 1 -n, h = 1 - h) sodium (m and h) and potassium (n) channels.","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"The transition rate functions, which depend on the voltage, V(t), are given by","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"function αₘ(V)\n    theta = (V + 45) / 10\n    ifelse(theta == 0.0, 1.0, theta/(1 - exp(-theta)))\nend\nβₘ(V) = 4*exp(-(V + 70)/18)\n\nαₕ(V) = .07 * exp(-(V + 70)/20)\nβₕ(V) = 1/(1 + exp(-(V + 40)/10))\n\nfunction αₙ(V)\n    theta = (V + 60) / 10\n    ifelse(theta == 0.0, .1, .1*theta / (1 - exp(-theta)))\nend\nβₙ(V) = .125 * exp(-(V + 70)/80)\nnothing # hide","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We now declare the symbolic variable, V(t), that will represent the transmembrane potential","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"@variables t V(t)\nnothing # hide","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"and a ReactionSystem that models the opening and closing of receptors","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"hhrn = @reaction_network hhmodel begin\n    (αₙ($V), βₙ($V)), n′ <--> n\n    (αₘ($V), βₘ($V)), m′ <--> m\n    (αₕ($V), βₕ($V)), h′ <--> h\nend\nnothing # hide","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Next we create a ModelingToolkit.ODESystem to store the equation for dV/dt","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"@parameters C=1.0 ḡNa=120.0 ḡK=36.0 ḡL=.3 ENa=45.0 EK=-82.0 EL=-59.0 I₀=0.0\nI = I₀ * sin(2*pi*t/30)^2\n\n# get the gating variables to use in the equation for dV/dt\n@unpack m,n,h = hhrn\n\nDₜ = Differential(t)\neqs = [Dₜ(V) ~ -1/C * (ḡK*n^4*(V-EK) + ḡNa*m^3*h*(V-ENa) + ḡL*(V-EL)) + I/C]\n@named voltageode = ODESystem(eqs, t)\nnothing # hide","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Notice, we included an applied current, I, that we will use to perturb the system and create action potentials. For now we turn this off by setting its amplitude, I₀, to zero.","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Finally, we add this ODE into the reaction model as","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"@named hhmodel = extend(voltageode, hhrn)\nnothing # hide","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"hhmodel is now a ReactionSystem that is coupled to an internal constraint ODE for dVdt. Let's now solve to steady-state, as we can then use these resting values as an initial condition before applying a current to create an action potential.","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"tspan = (0.0, 50.0)\nu₀ = [:V => -70, :m => 0.0, :h => 0.0, :n => 0.0,\n\t  :m′ => 1.0, :n′ => 1.0, :h′ => 1.0]\noprob = ODEProblem(hhmodel, u₀, tspan)\nhhsssol = solve(oprob, Rosenbrock23())\nnothing # hide","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"From the artificial initial condition we specified, the solution approaches the physiological steady-state via firing one action potential:","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"plot(hhsssol, idxs = V)","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We now save this steady-state to use as the initial condition for simulating how a resting neuron responds to an applied current.","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"u_ss = hhsssol.u[end]\nnothing # hide","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Finally, starting from this resting state let's solve the system when the amplitude of the stimulus is non-zero and see if we get action potentials","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"tspan = (0.0, 50.0)\n@unpack I₀ = hhmodel\noprob = ODEProblem(hhmodel, u_ss, tspan, [I₀ => 10.0])\nsol = solve(oprob)\nplot(sol, vars = V, legend = :outerright)","category":"page"},{"location":"catalyst_functionality/example_networks/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We observe three action potentials due to the steady applied current.","category":"page"},{"location":"inverse_problems/structural_identifiability/#structural_identifiability","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"During parameter fitting, parameter values are inferred from data. Parameter identifiability refers to whether inferring parameter values for a given model is mathematically feasible. Ideally, parameter fitting should always be accompanied with an identifiability analysis of the problem. ","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Identifiability can be divided into structural and practical identifiability[1]. Structural identifiability considers only the mathematical model, and which parameters are and are not inherently identifiable due to model structure. Practical identifiability also considers the available data, and determines what system quantities can be inferred from it. In the idealised case of an infinite amount of non-noisy data, practical identifiability converges to structural identifiability. Generally, structural identifiability is assessed before parameters are fitted, while practical identifiability is assessed afterwards.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Structural identifiability (which is what this tutorial considers) can be illustrated by the following differential equation: dx over dt = p1*p2*x(t) where, however much data is collected on x, it is impossible to determine the distinct values of p1 and p2. Hence, these parameters are non-identifiable (however, their product, p1*p2, is identifiable).","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Catalyst contains a special extension for carrying out structural identifiability analysis of generated reaction rate equation ODE models using the StructuralIdentifiability.jl package. This enables StructuralIdentifiability's assess_identifiability, assess_local_identifiability, and find_identifiable_functions functions to be called directly on Catalyst ReactionSystems. It also implements specialised routines to make these more efficient when applied to reaction network models (e.g. by improving runtimes). How to use these functions is described in the following tutorial, with StructuralIdentifiability providing a more extensive documentation. ","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Structural identifiability can be divided into local and global identifiability. If a model quantity is locally identifiable, it means that its true value can be determined down to a finite-number of possible options. This also means that there is some limited region around the quantity's true value where this true value is the only possible value (and hence, within this region, the quantity is fully identifiable). Globally identifiable quantities' values, on the other hand, can be uniquely determined. Again, while identifiability can be confirmed structurally for a quantity, it does not necessarily mean that it is practically identifiable for some given data.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Generally, there are three types of quantities for which identifiability can be assessed.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Parameters (e.g. p1 and p2).\nFull variable trajectories (e.g. x(t)).\nVariable initial conditions (e.g. x(0)). ","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"StructuralIdentifiability currently assesses identifiability for the first two only (however, if x(t) is identifiable, then x(0) will be as well).","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"note: Note\nCurrently, the StructuralIdentifiability.jl extension only considers structural identifiability for the ODE generated by the reaction rate equation. It is possible that for the SDE model (generated by the chemical Langevin equation) and the jump model (generated by stochastic chemical kinetics) the identifiability of model quantities is different.","category":"page"},{"location":"inverse_problems/structural_identifiability/#Global-identifiability-analysis","page":"Structural Identifiability Analysis","title":"Global identifiability analysis","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/#Basic-example","page":"Structural Identifiability Analysis","title":"Basic example","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Global identifiability can be assessed using the assess_identifiability function. For each model quantity (parameters and variables), it will assess whether they are:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Globally identifiable.\nLocally identifiable.\nUnidentifiable.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"To it, we provide our ReactionSystem model and a list of quantities that we are able to measure. Here, we consider a Goodwind oscillator (a simple 3-component model, where the three species M, E, and P are produced and degraded, which may exhibit oscillations)[2]. Let us say that we are able to measure the concentration of M, we then designate this using the measured_quantities argument. We can now assess identifiability in the following way:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"using Catalyst, Logging, StructuralIdentifiability\ngoodwind_oscillator = @reaction_network begin\n    (pₘ/(1+P), dₘ), 0 <--> M\n    (pₑ*M,dₑ), 0 <--> E\n    (pₚ*E,dₚ), 0 <--> P\nend\nassess_identifiability(goodwind_oscillator; measured_quantities=[:M], loglevel=Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"From the output, we find that E(t), pₑ, and pₚ (the trajectory of E, and the production rates of E and P, respectively) are non-identifiable. Next, dₑ and dₚ (the degradation rates of E and P, respectively) are locally identifiable. Finally, P(t), M(t), pₘ, and dₘ (the trajectories of P and M, and the production and degradation rate of M, respectively) are all globally identifiable. We note that we also imported the Logging.jl package, and provided the loglevel=Logging.Error input argument. StructuralIdentifiability functions generally provide a large number of output messages. Hence, we will use this argument (which requires the Logging package) throughout this tutorial to decrease the amount of printed text.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Next, we also assess identifiability in the case where we can measure all three species concentrations:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"assess_identifiability(goodwind_oscillator; measured_quantities=[:M, :P, :E], loglevel=Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"in which case all species trajectories and parameters become identifiable.","category":"page"},{"location":"inverse_problems/structural_identifiability/#Indicating-known-parameters","page":"Structural Identifiability Analysis","title":"Indicating known parameters","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"In the previous case we assumed that all parameters are unknown, however, this is not necessarily true. If there are parameters with known values, we can supply these using the known_p argument. Providing this additional information might also make other, previously unidentifiable, parameters identifiable. Let us consider the previous example, where we measure the concentration of M only, but now assume we also know the production rate of E (pₑ):","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"assess_identifiability(gwo; measured_quantities=[:M], known_p=[:pₑ], loglevel=Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Not only does this turn the previously non-identifiable pₑ (globally) identifiable (which is obvious, given that its value is now known), but this additional information improve identifiability for several other network components.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"To, in a similar manner, indicate that certain initial conditions are known is a work in progress. Hopefully this feature should be an available in the near future.","category":"page"},{"location":"inverse_problems/structural_identifiability/#Providing-non-trivial-measured-quantities","page":"Structural Identifiability Analysis","title":"Providing non-trivial measured quantities","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Sometimes, ones may not have measurements of species, but rather some combinations of species (or possibly parameters). To account for this, measured_quantities accepts any algebraic expression (and not just single species). To form such expressions, species and parameters have to first be @unpack'ed from the model. Say that we have a model where an enzyme (E) is converted between an active and inactive form, which in turns activates the production of a product, P:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"using Catalyst, StructuralIdentifiability # hide\nenzyme_activation = @reaction_network begin\n    (kA,kD), Eᵢ <--> Eₐ\n    (Eₐ, d), 0 <-->P\nend","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"If we can measure the total amount of E (=Eᵢ+Eₐ), as well as the amount of P, we can use the following to assess identifiability:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"@unpack Eᵢ, Eₐ = enzyme_activation\nassess_identifiability(enzyme_activation; measured_quantities=[Eᵢ+Eₐ, :P], loglevel=Logging.Error)\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/#Assessing-identifiability-for-specified-quantities-only","page":"Structural Identifiability Analysis","title":"Assessing identifiability for specified quantities only","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"By default, StructuralIdentifiability assesses identifiability for all parameters and variables. It is, however, possible to designate precisely which quantities you want to check using the funcs_to_check option. This both includes selecting a smaller subset of parameters and variables to check, or defining customised expressions. Let us consider the Goodwind from previously, and say that we would like to check whether the production parameters (pₘ, pₑ, and pₚ) and the total amount of the three species (P + M + E) are identifiable quantities. Here, we would first unpack these (allowing us to form algebraic expressions) and then use the following code:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"@unpack pₘ, pₑ, pₚ, M, E, P = goodwind_oscillator\nassess_identifiability(goodwind_oscillator; measured_quantities=[:M], funcs_to_check=[pₘ, pₑ, pₚ, M + E + P], loglevel=Logging.Error)\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/#Probability-of-correctness","page":"Structural Identifiability Analysis","title":"Probability of correctness","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"The identifiability methods used can, in theory, produce erroneous results. However, it is possible to adjust the lower bound for the probability of correctness using the argument prob_threshold (by default set to 0.99, that is, at least a 99 chance of correctness). We can e.g. increase the bound through:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"assess_identifiability(goodwind_oscillator; measured_quantities=[:M], prob_threshold=0.999, loglevel=Logging.Error)\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"giving a minimum bound of 999 chance of correctness. In practise, the bounds used by StructuralIdentifiability are very conservative, which means that while the minimum guaranteed probability of correctness in the default case is 99, in practise it is much higher. While increasing the value of prob_threshold increases the certainty of correctness, it will also increase the time required to assess identifiability.","category":"page"},{"location":"inverse_problems/structural_identifiability/#Local-identifiability-analysis","page":"Structural Identifiability Analysis","title":"Local identifiability analysis","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Local identifiability can be assessed through the assess_local_identifiability function. While this is already determined by assess_identifiability, assessing local identifiability only has the advantage that it is easier to compute. Hence, there might be models where global identifiability analysis fails (or takes a prohibitively long time), where instead assess_local_identifiability can be used. This function takes the same inputs as assess_identifiability and returns, for each quantity, true if it is locally identifiable (or false if it is not). Here, for the Goodwind oscillator, we assesses it for local identifiability only:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"assess_local_identifiability(goodwind_oscillator; measured_quantities=[:M], loglevel=Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"We note that the results are consistent with those produced by assess_identifiability (with globally or locally identifiable quantities here all being assessed as at least locally identifiable).","category":"page"},{"location":"inverse_problems/structural_identifiability/#Finding-identifiable-functions","page":"Structural Identifiability Analysis","title":"Finding identifiable functions","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Finally, StructuralIdentifiability provides the find_identifiable_functions function. Rather than determining the identifiability of each parameter and state of the model, it finds a set of identifiable functions, such as any other identifiable expression of the model can be generated by these. Let us again consider the Goodwind oscillator, using the find_identifiable_functions function we find that identifiability can be reduced to five globally identifiable expressions:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"find_identifiable_functions(goodwind_oscillator; measured_quantities=[:M], loglevel=Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Again, these results are consistent with those produced by assess_identifiability. There, pₑ and pₚ where found to be globally identifiable. Here, they correspond directly to identifiable expressions. The remaining four parameters (pₘ, dₘ, dₑ, and dₚ) occur as part of more complicated composite expressions.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"find_identifiable_functions tries to simplify its output functions to create nice expressions. The degree to which it does this can be adjusted using the simplify keywords. Using the :weak, :standard (default), and :strong arguments, increased simplification can be forced (at the expense of longer runtime).","category":"page"},{"location":"inverse_problems/structural_identifiability/#Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems","page":"Structural Identifiability Analysis","title":"Creating StructuralIdentifiability compatible ODE models from Catalyst ReactionSystems","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"While the functionality described above covers the vast majority of analysis that user might want to perform, the StructuralIdentifiability package supports several additional features. While these does not have inherent Catalyst support, we do provide the make_si_ode function to simplify their use. Similar to the previous functions, it takes a ReactionSystem, lists of measured quantities, and known parameter values. The output is a ODE of the standard form supported by StructuralIdentifiability. It can be created using the following syntax:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"si_ode = make_si_ode(goodwind_oscillator; measured_quantities=[:M])\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"and then used as input to various StructuralIdentifiability functions. In the following example we use StructuralIdentifiability's print_for_DAISY function, printing the model as an expression that can be used by the DAISY software for identifiability analysis[3].","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"print_for_DAISY(si_ode)\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/#Notes-on-systems-with-conservation-laws","page":"Structural Identifiability Analysis","title":"Notes on systems with conservation laws","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Several reaction network models, such as","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"using Catalyst, Logging, StructuralIdentifiability # hide\nrs = @reaction_network begin\n  (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"contain conservation laws (in this case Γ = X1 + X2, where Γ = X1(0) + X2(0) is a constant). Because the presence of such conservation laws makes structural identifiability analysis prohibitively computationally expensive (for all but the simplest of cases), these are automatically eliminated by Catalyst (removing one ODE from the resulting ODE system for each conservation law). For the assess_identifiability and assess_local_identifiability functions, this will be unnoticed by the user. However, for the find_identifiable_functions and make_si_ode functions, this may result in one, or several, parameters of the form Γ[i] (where i is an integer) appearing in the produced expressions. These correspond to the conservation law constants and can be found through","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"conservedequations(rs)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"E.g. if you run:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"find_identifiable_functions(rs; measured_quantities = [:X1, :X2])","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"we see that Γ[1] (= X1(0) + X2(0)) is detected as an identifiable expression. If we want to disable this feature for any function, we can use the remove_conserved = false option:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"find_identifiable_functions(rs; measured_quantities = [:X1, :X2], remove_conserved = false)","category":"page"},{"location":"inverse_problems/structural_identifiability/#Systems-with-exponent-parameters","page":"Structural Identifiability Analysis","title":"Systems with exponent parameters","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Structural identifiability cannot currently be applied to systems with parameters (or species) in exponents. E.g. this","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"rn = @reaction_network begin\n    (hill(X,v,K,n),d), 0 <--> X\nend\nassess_identifiability(rn; measured_quantities=[:X])","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"is currently not possible. Hopefully this will be a supported feature in the future. For now, such expressions will have to be rewritten to not include such exponents. For some cases, e.g. 10^k this is trivial. However, it is also possible generally (but more involved and often includes introducing additional variables). ","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"","category":"page"},{"location":"inverse_problems/structural_identifiability/#structural_identifiability_citation","page":"Structural Identifiability Analysis","title":"Citation","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"If you use this functionality in your research, please cite the following paper to support the authors of the StructuralIdentifiability package:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"@article{structidjl,\n  author  = {Dong, R. and Goodbrake, C. and Harrington, H. and Pogudin G.},\n  title   = {Differential Elimination for Dynamical Models via Projections with Applications to Structural Identifiability},\n  journal = {SIAM Journal on Applied Algebra and Geometry},\n  url     = {https://doi.org/10.1137/22M1469067},\n  year    = {2023}\n  volume  = {7},\n  number  = {1},\n  pages   = {194-235}\n}","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"","category":"page"},{"location":"inverse_problems/structural_identifiability/#References","page":"Structural Identifiability Analysis","title":"References","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"[1]: Guillaume H.A. Joseph et al., Introductory overview of identifiability analysis: A guide to evaluating whether you have the right type of data for your modeling purpose, Environmental Modelling & Software (2019).","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"[2]: Goodwin B.C., Oscillatory Behavior in Enzymatic Control Processes, Advances in Enzyme Regulation (1965).","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"[3]: Bellu G., et al., DAISY: A new software tool to test global identifiability of biological and physiological systems, Computer Methods and Programs in Biomedicine (2007).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameter_fitting","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The PEtab.jl package implements the PEtab format for fitting the parameters of deterministic CRN models to data [1]. PEtab.jl both implements methods for creating cost functions (determining how well parameter sets fit to data), and for minimizing these cost functions. The PEtab approach covers most cases of fitting deterministic (ODE) models to data and is a good default choice when fitting reaction rate equation ODE models. This page describes how to combine PEtab.jl and Catalyst for parameter fitting, with the PEtab.jl package providing a more extensive documentation (this tutorial is partially an adaptation of this documentation).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Introductory-example","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Introductory example","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Let us consider a simple catalysis network, where an enzyme (E) turns a substrate (S) into a product (P):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Catalyst, PEtab\n\nrn = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"From some known initial condition, and a true parameter set (which we later want to recover from the data) we generate synthetic data (on which we will demonstrate the fitting process).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"# Define initial conditions and parameters.\nu0 = [:S => 1.0, :E => 1.0, :SE => 0.0, :P => 0.0]\np_true = [:kB => 1.0, :kD => 0.1, :kP => 0.5]\n\n# Generate synthetic data.\nusing OrdinaryDiffEq\noprob_true = ODEProblem(rn, u0, (0.0, 10.0), p_true)\ntrue_sol = solve(oprob_true, Tsit5())\ndata_sol = solve(oprob_true, Tsit5(); saveat=1.0)\ndata_ts = data_sol.t[2:end]\ndata_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\n# Plots the true solutions and the (synthetic data) measurements.\nusing Plots\ndefault(bottom_margin=4Plots.Measures.mm,left_margin=4Plots.Measures.mm) # hide\nplot(true_sol; idxs=:P, label=\"True solution\", lw=8)\nplot!(data_ts, data_vals; label=\"Measurements\", seriestype=:scatter, ms=6, color=:blue)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Generally, PEtab takes five different inputs to define an optimisation problem (the minimiser of which generates a fitted parameter set):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Model: The model which we want to fit to the data (a ReactionSystem).\nObservables: The possible observables that can be measured (a Dict{String,PEtabObservable}).\nEstimation parameters: The parameters which we want to fit to the data (a Vector{PEtabParameter}). \nExperimental (or simulation) conditions: The simulations (each corresponding to a potential experiment) carried out during each step of the optimisation process (a Dict{String,Dict{Symbol,Float64}}).\nMeasurements: The measurements to which the model is fitted (a DataFrame). ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Observables","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Observables","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The observables define the quantities that we may measure in our experiments. Typically, each corresponds to a single species, however, more complicated observables are possible. For each observable, we also need a noise formula, defining the uncertainty in its measurements. By default, PEtab assumes normally distributed noise, with a mean equal to the true value and a standard deviation which we have to define. It is also possible to use more advanced noise formulas.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our example, we only have a single possible observable, the P species. We will assume that the noise is normally distributed with a standard deviation 0.5 (in our case this is not true, however, typically the noise distribution is unknown and a guess must be made). We combine this information in a PEtabObservable struct (to access the P species we must use @unpack). Finally, we store all our observables in a dictionary, giving each an id tag (which is later used in the measurements input).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@unpack P = rn\nobs_P = PEtabObservable(P, 0.5)\nobservables = Dict(\"obs_P\" => obs_P)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Parameters","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameters","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Each parameter of the system can either be","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Known (described here).\nDepend on experimental/simulation conditions (described here). \nBe an unknown that we wish to fit to data.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our case, we wish to fit all three system parameters (kB, kD, and kP). For each, we create a single PEtabParameter, and then gather these into a single vector.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB)\npar_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\nparams = [par_kB, par_kD, par_kP]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"For each parameter, it is also possible to set a lower and/or upper bound (by default, (00011000) is used), set whether to use logarithmic or linear scale, or add a prior distribution of its value.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Simulation-conditions","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Simulation conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Sometimes, several different experiments are performed on a system (each potentially generating several measurements). An experiment could e.g. be the time development of a system from a specific initial condition. Since each experimental condition (during the optimisation procedure, for a guess of the unknown parameters) generates a distinct simulation, these are also called simulation conditions. In our example, all data comes from a single experiment, and the simulation condition input is not required. How to define and use different experimental conditions is described here.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Measurements","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Measurements","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Finally, we need to define the system measurements to which the parameters will be fitted. Each measurement combines:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The observable which is observed (here we use the id tag defined in the observables dictionary).\nThe time point of the measurement.\nThe measured value.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"For cases where several simulation conditions are given, we also need to provide:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The simulation condition which generates the measurement (here is an example where this is used).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Note also, when pre-equilibration is used to initiate the system in a steady state, a fifth field is also required.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Each individual measurement is provided as a row of a DataFrame. The values are provided in the obs_id, time, measurement, and simulation_id columns. In our case we only need to fill in the first three:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using DataFrames\nmeasurements = DataFrame(obs_id=\"obs_P\", time=data_ts, measurement=data_vals)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Since, in our example, all measurements are of the same observable, we can set obs_id=\"obs_P\". However, it is also possible to include measurements from several different observables.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Creating-a-PEtabModel","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Creating a PEtabModel","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Finally, we combine all inputs in a single PEtabModel. To it, we also pass the initial conditions of our simulations (using the state_map argument). It is also possible to have initial conditions with uncertainty, that vary between different simulations, or that we attempt to fit to the data.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_model = PEtabModel(rn, observables, measurements, params; state_map=u0)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Fitting-parameters","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Fitting parameters","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"We are now able to fit our model to the data. First, we create a PEtabODEProblem. Here, we use petab_model as the only input, but it is also possible to set various numeric solver and automatic differentiation options (such as method or tolerance).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_problem = PEtabODEProblem(petab_model; verbose=false) # hide\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_problem = PEtabODEProblem(petab_model)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Since no additional input is given, default options are selected by PEtab.jl (and generally, its choices are good).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To fit a parameter set we use the calibrate_model function. In addition to our PEtabODEProblem, we must also provide an initial guess (which can be generated with the generate_startguesses function) and an optimisation algorithm (which needs to be imported specifically). PEtab.jl supports various optimisation methods and options. ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Optim\np0 = generate_startguesses(petab_problem, 1)\np0 = [0.0, 0.0, 0.0] # hide\nres = calibrate_model(petab_problem, p0, IPNewton()) # hide\nres = calibrate_model(petab_problem, p0, IPNewton())","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"We can now simulate our model for the fitted parameter set, and compare the result to the measurements and true solution.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"oprob_fitted = remake(oprob_true; p=get_ps(res, petab_problem))\nfitted_sol = solve(oprob_fitted, Tsit5())\nplot!(fitted_sol; idxs=:P, label=\"Fitted solution\", linestyle=:dash, lw=6, color=:lightblue)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here we use the get_ps function to retrieve a full parameter set using the optimal parameters. Alternatively, the ODEProblem or fitted simulation can be retrieved directly using the get_odeproblem or get_odesol functions, respectively (and the initial condition using the get_u0 function). The calibration result can also be found in res.xmin, however, note that PEtab automatically (unless a linear scale is selected) converts parameters to logarithmic scale, so typically 10 .^res.xmin are the values of interest. If you investigate the result from this example you might note, that even if PEtab.jl has found the global optimum (which fits the data well), this does not actually correspond to the true parameter set. This phenomenon is related to the concept of identifiability, which is very important for parameter fitting.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Final-notes","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Final notes","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"PEtab.jl also supports multistart optimisation, automatic pre-equilibration before simulations, and events. Various plot recipes exist for investigating the optimisation process. Please read the PETab.jl documentation for a more complete description of the package's features. Below follows additional details of various options and features (generally, PEtab is able to find good default values for most options that are not specified).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_observables","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Observables","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_observables_observables","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Defining non-trivial observables","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"It is possible for observables to be any algebraic expression of species concentrations and parameters. E.g. in this example the total amount of X in the system is an observable:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Catalyst, PEtab # hide\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\n@unpack X1, X2 = two_state_model\nobs_X = PEtabObservable(X1 + X2, 0.5)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"A common application for this is to define an offset and a scale for each observable.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_observables_noise_formula","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Advanced observables noise formulas","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our basic example we assumed that the normally distributed noise had a standard deviation of 0.5. However, this value may be a parameter (or indeed any algebraic expression). E.g, we could set","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@parameters σ\nobs_P = PEtabObservable(P, σ)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"and then let the parameter σ vary between different simulation conditions. Alternatively we could let the noise scale linearly with the species' concentration:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"obs_P = PEtabObservable(P, 0.05P)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"It would also be possible to make σ a parameter that is fitted as a part of the parameter fitting process.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"PEtab.jl assumes that noise is normally distributed (with a standard deviation equal to the second argument provided to PEtabObservable). The only other (currently implemented) noise distribution is log-normally distributed noise, which is designated through the transformation=:log argument:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"obs_P = PEtabObservable(P, σ; transformation=:log)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Parameters","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters_known","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Known parameters","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our previous example, all parameters were unknowns that we wished to fit to the data. If any parameters have known values, it is possible to provide these to PEtabModel through the parameter_map argument. E.g if we had known that kB = 10, then we would only define kD and kP as parameters we wish to fit:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\nparams = [par_kD, par_kP]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"We then provide parameter_map=[:kB => 1.0] when we assembly our model:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_model_known_param = PEtabModel(rn, observables, measurements, params; state_map=u0, parameter_map=[:kB => 1.0])\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters_bounds","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter bounds","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"By default, when fitted, potential parameter values are assumed to be in the interval (1e-3 1e3). When declaring a PEtabParameter it is possible to change these values through the lb and ub arguments. E.g. we could use","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB; lb=1e-2, ub=1e2)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"to achieve the more conservative bound (1e-2 1e2) for the parameter kB.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters_scales","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter scales","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Internally, parameters that are fitted are converted to a logarithmic scale (generally, this is considered advantageous[2]). To prevent this conversion, the scale=:lin argument can be used. Here we change the scale of kB to linear:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB; scale=:lin)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters_priors","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter priors","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"If we have prior knowledge about the distribution of a parameter, it is possible to incorporate this into the model. The prior can be any continuous, univariate, distribution from the Distributions.jl package. E.g we can use:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Distributions\npar_kB = PEtabParameter(:kB; prior=Normal(1.0,0.2))","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"to set a normally distributed prior (with mean 1.0 and standard deviation 0.2) on the value of kB. By default, the prior is assumed to be on the linear scale of the parameter (before any potential log transform). To specify that the prior is on the logarithmic scale, the prior_on_linear_scale=false argument can be provided:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB; prior=Normal(1.0,0.2), prior_on_linear_scale=false)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In this example, setting prior_on_linear_scale=false makes sense as a (linear) normal distribution is non-zero for negative values (an alternative is to use a log-normal distribution, e.g. prior=LogNormal(3.0, 3.0)).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_conditions","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Simulation conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Sometimes, we have data from several different experimental conditions. Here, when a potential parameter set is evaluated during the fitting process, each experimental condition corresponds to one simulation condition (which produces one simulation). To account for this, PEtab permits the user to define several different simulation conditions, with each condition being defined by specific values for some initial conditions and/or parameters. ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"If, for our previous catalysis example, we had measured the system for two different initial values of S (S(0)=10 and S(0)=tfrac12), these would correspond to two different simulation conditions. For each condition we define a Dict mapping the species to their initial condition (here, S is the only species in each Dict):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"c1 = Dict(:S => 1.0)\nc2 = Dict(:S => 0.5)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Similarly as for observables, we then gather the conditions in another Dict, giving each an id tag:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"simulation_conditions = Dict(\"c1\" => c1, \"c2\" => c2)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Again (like for observables), each measurement in the measurements DataFrame needs to be associated with a simulation condition id tag (describing which condition those measurements were taken from). Parameters, just like initial conditions, may vary between different conditions. If an initial condition (or parameter) occurs in one condition, it must occur in all of them.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here follows a complete version of our basic example, but with measurements both for S(0)=10 and S(0)=tfrac12.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Catalyst, PEtab\n\nrn = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\n\nu0 = [:E => 1.0, :SE => 0.0, :P => 0.0]\np_true = [:kB => 1.0, :kD => 0.1, :kP => 0.5]\n\n# Simulate data.\nusing OrdinaryDiffEq\nt1, d1 = let \n    oprob_true = ODEProblem(rn, [:S=>1.0; u0], (0.0, 10.0), p_true)\n    data_sol = solve(oprob_true, Tsit5(); saveat=1.0)\n    data_sol.t[2:end], (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\nend\nt2, d2 = let \n    oprob_true = ODEProblem(rn, [:S=>0.5; u0], (0.0, 10.0), p_true)\n    data_sol = solve(oprob_true, Tsit5(); saveat=1.0)\n    data_sol.t[2:end], (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\nend\n\n@unpack P = rn\nobs_P = PEtabObservable(P, 0.5)\nobservables = Dict(\"obs_P\" => obs_P)\n\npar_kB = PEtabParameter(:kB)\npar_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\nparams = [par_kB, par_kD, par_kP]\n\nc1 = Dict(:kB => 1.0)\nc2 = Dict(:kB => 0.5)\nsimulation_conditions = Dict(\"c1\" => c1, \"c2\" => c2)\n\nusing DataFrames\nm1 = DataFrame(simulation_id=\"c1\", obs_id=\"obs_P\", time=t1, measurement=d1)\nm2 = DataFrame(simulation_id=\"c2\", obs_id=\"obs_P\", time=t2, measurement=d2)\nmeasurements = vcat(m1,m2)\n\npetab_model = PEtabModel(rn, simulation_conditions, observables, measurements, params; state_map=u0)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Note that the u0 we pass into PEtabModel through the state_map argument no longer contains the value of S (as it is provided by the conditions). ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_measurements","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Measurements","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_measurements_several_observables","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Measurements of several observables","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our previous example, all our measurements were from a single observable, obs_P. If we also had collected measurements of both S and P:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"data_ts = data_sol.t[2:end]\ndata_vals_S = (0.8 .+ 0.4*rand(10)) .* data_sol[:S][2:end]\ndata_vals_P = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"and then corresponding observables:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@unpack S, P = rn\nobs_S = PEtabObservable(S, 0.5)\nobs_P = PEtabObservable(P, 0.5)\nobservables = Dict(\"obs_S\" => obs_P, \"obs_P\" => obs_P)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"we are able to include all these measurements in the same measurements DataFrame:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"m1 = DataFrame(obs_id=\"obs_P\", time=data_ts, measurement=data_vals_S)\nm2 = DataFrame(obs_id=\"obs_S\", time=data_ts, measurement=data_vals_P)\nmeasurements = vcat(m1,m2)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"which then can be used as input to PEtabModel.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Varying-parameters-between-different-simulation-conditions","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Varying parameters between different simulation conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Sometimes, the parameters that are used vary between the different conditions. Consider our catalysis example, if we had performed the experiment twice, using two different enzymes with different catalytic properties, this could have generated such conditions. The two enzymes could e.g. yield different rates (kP_1 and kP_2) for the SE --> P + E reaction, but otherwise be identical. Here, the parameters kP_1 and kP_2 are unique to their respective conditions. PEtab.jl provides support for cases such as this, and its documentation provided instructions of how to handle them.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_initial_conditions","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Initial conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_initial_conditions_fitted","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Fitting initial conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Sometimes, initial conditions are uncertain quantities which we wish to fit to the data. This is possible by defining an initial condition as a parameter: ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Catalyst, PEtab # hide\nrn = @reaction_network begin\n    @parameters E0\n    @species E(t)=E0\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, the initial value of E is equal to the parameter E0. We modify our u0 vector by removing E (which is no longer known):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"u0 = [:S => 1.0, :SE => 0.0, :P => 0.0]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Next, we add E0 to the parameters we wish to fit:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB)\npar_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\npar_E0 = PEtabParameter(:E0)\nparams = [par_kB, par_kD, par_kP, par_E0]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"and we can use our updated rn, u0, and params as input to our PEtabModel.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_initial_conditions_uncertainty","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Uncertain initial conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Often, while an initial condition has been reported for an experiment, its exact value is uncertain. This can be modelled by making the initial condition a parameter that is fitted to the data and attaching a prior to it corresponding to our certainty about its value. ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Let us consider our initial example, but where we want to add uncertainty to the initial conditions of S and E. We will add priors on these, assuming normal distributions with mean 1.0 and standard deviation 0.1. For the synthetic measured data we will use the true values S(0) = E(0) = 10.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"\nusing Catalyst, PEtab\n\nrn = @reaction_network begin\n    @parameters S0 E0\n    @species S(t)=S0 E(t)=E0\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\n\nu0 = [:SE => 0.0, :P => 0.0]\np_true = [:kB => 1.0, :kD => 0.1, :kP => 0.5, :S0=>1.0, :E0 => 1.0]\n\nusing OrdinaryDiffEq\noprob_true = ODEProblem(rn, u0, (0.0, 10.0), p_true)\ntrue_sol = solve(oprob_true, Tsit5())\ndata_sol = solve(oprob_true, Tsit5(); saveat=1.0)\ndata_ts = data_sol.t[2:end]\ndata_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\n@unpack P = rn\nobs_P = PEtabObservable(P, 0.5)\nobservables = Dict(\"obs_P\" => obs_P)\n\npar_kB = PEtabParameter(:kB)\npar_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\npar_S0 = PEtabParameter(:S0)\npar_E0 = PEtabParameter(:E0)\nparams = [par_kB, par_kD, par_kP, par_S0, par_E0]\n\nusing DataFrames\nmeasurements = DataFrame(obs_id=\"obs_P\", time=data_ts, measurement=data_vals)\n\npetab_model = PEtabModel(rn, observables, measurements, params; state_map=u0)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, when we fit our data we will also gain values for S0 and E0, however, unless we are explicitly interested in these, they can be ignored.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_options","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Simulation options","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"While in our basic example, we do not provide any additional information to our PEtabODEProblem, this is an opportunity to specify how the model should be simulated, and what automatic differentiation techniques to use for the optimisation procedure (if none are provided, appropriate defaults are selected). ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here is an example, taken from the more detailed PEtab.jl documentation","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"PEtabODEProblem(petab_model, ode_solver=ODESolver(Rodas5P(), abstol=1e-8, reltol=1e-8), gradient_method=:ForwardDiff, hessian_method=:ForwardDiff, verbose=false); nothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"PEtabODEProblem(petab_model, \n                ode_solver=ODESolver(Rodas5P(), abstol=1e-8, reltol=1e-8), \n                gradient_method=:ForwardDiff, \n                hessian_method=:ForwardDiff)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"where we simulate our ODE model using the Rodas5p method (with absolute and relative tolerance both equal 1e-8) and use forward automatic differentiation for both gradient and hessian computation. More details on available ODE solver options can be found in the PEtab.jl documentation.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_optimisation","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Optimisation","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_optimisation_optimisers","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Optimisation methods and options","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"For our examples, we have used the Optim.IPNewton optimisation method. PEtab.jl supports several additional optimisation methods. Furthermore, calibrate_model's options argument permits the customisation of the options for any used optimiser. E.g. to designate the maximum number of iterations of the Optim.IPNewton method we would use:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res = calibrate_model(petab_problem, p0, IPNewton(); options=Optim.Options(iterations = 10000))\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Please read the PEtab.jl documentation to learn how to customise the various optimisers' properties. ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_optimisation_path_recording","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Optimisation path recording","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To record all the parameter sets evaluated (and their objective values) during the optimisation procedure, provide the save_trace=true argument to calibrate_model (or calibrate_model_multistart):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res = calibrate_model(petab_problem, p0, IPNewton(); save_trace=true)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"This is required for the various optimisation evaluation plots provided by PEtab.jl. If desired, this information can be accessed in the calibration output's .xtrace and .ftrace fields.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Objective-function-extraction","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Objective function extraction","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"While PEtab.jl provides various tools for analysing the objective function generated by PEtabODEProblem, it is also possible to extract this function for customised analysis. Given a PEtabODEProblem","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_problem = PEtabODEProblem(petab_model; verbose=false); nothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_problem = PEtabODEProblem(petab_model)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"We can find the:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Objective function as the petab_problem.compute_cost. It takes a single argument (p) and returns the objective value.\nGradient as the petab_problem.compute_gradient! field. It takes two arguments (g and p) with the updated gradient values being written to g.\nHessian as the petab_problem.compute_hessian field. It takes two arguments (H and p) with the updated hessian values being written to H.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_multistart_optimisation","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Multi-start optimisation","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To avoid the optimisation process returning a local minimum, it is often advised to run it multiple times, using different initial guesses. PEtab.jl supports this through the calibrate_model_multistart function. This is identical to the calibrate_model function, but takes two additional arguments:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"n_multistart: The number of runs to perform.\ndir_save: A location to which the output is automatically saved. If dir_save=nothing, no output is saved.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"And one additional optional argument:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"sampling_method: Selects the sampling method with which to select the initial guesses (QuasiMonteCarlo.LatinHypercubeSample() used by default). ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Because calibrate_model_multistart handles initial guess sampling, unlike for calibrate_model, no initial guess has to be provided. ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, we fit parameters through 10 independent optimisation runs, using QuasiMonteCarlo's SobolSample method, and save the result to the OptimisationRuns folder:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Optim\nusing QuasiMonteCarlo\nmkdir(\"OptimisationRuns\") # hide\nres_ms = calibrate_model_multistart(petab_problem, IPNewton(), 10, \"OptimisationRuns\"; sampling_method=QuasiMonteCarlo.SobolSample())\nres_ms = calibrate_model_multistart(petab_problem, IPNewton(), 10, \"OptimisationRuns\"; sampling_method=QuasiMonteCarlo.SobolSample()) # hide\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The best result across all runs can still be retrieved using get_ps(res_ms, petab_problem), with the results of the individual runs being stored in the res_ms.runs field. ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To load the result in a later session, we can call:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res_ms = PEtabMultistartOptimisationResult(\"OptimisationRuns\")\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"where \"OptimisationRuns\" is the name of the save directory (specified in calibrate_model_multistart). If the OptimisationRuns folder contains the output from several runs, we can designate which to load using the which_run argument. Here we load the second run to be saved in that folder:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res_ms = PEtabMultistartOptimisationResult(\"OptimisationRuns\"; which_run=\"2\")\nrm(\"OptimisationRuns\", recursive=true) # hide\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"By default, which_run loads the first run saved to that directory.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_events","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Events","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"So far, we have assumed that all experiments, after initiation, run without interference. Experiments where conditions change, or where species are added/removed during the time course, can be represented through events (related to callbacks). In PEtab, an event is represented through the PEtabEvent structure. It takes three arguments:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The condition for triggering the event. This can either indicate a point in time, or a boolean condition.\nA rule for updating the event's target\nThe event's target (either a species or parameter).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here we create an event which adds 0.5 units of S to the system at time 5.0:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@unpack S = rn\nevent1 = PEtabEvent(5.0, S + 0.5, S)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, the first argument is evaluated to a scalar value, in which case it is interpreted as a time point at which the event happens. If we instead want the event to happen whenever the concentration of S falls below 0.5 we set the first argument to a boolean condition indicating this:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"event2 = PEtabEvent(S < 0.5, S + 0.5, S)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, the event only triggers whenever the condition changes from false to true, and not while it remains true (or when changing from true to false). E.g. this event only triggers when S concentration passes from more than 50 to less that 50.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Whenever we have several events or not, we bundle them together in a single vector which is later passed to the PEtabODEProblem using the events argument:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"params = [par_kB, par_kD, par_kP] # hide\nevents = [event1, event2]\npetab_model = PEtabModel(rn, observables, measurements, params; state_map=u0, events=events)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"More details on how to use events, including how to create events with multiple targets, can be found in PEtab.jl's documentation.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"note: Note\nPEtab currently ignores events created as a part of a Catalyst ReactionSystem model, and does not support SciML-style events implemented through callbacks to solve. Instead, events have to use the preceding interface.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_plotting","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Plot recipes","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"There exist various types of graphs that can be used to evaluate the parameter fitting process. These can be plotted using the plot command, where the input is either the result of a calibrate_model or a  calibrate_model_multistart run. To be able to use this functionality, you have to ensure that PEtab.jl records the optimisation process by providing the save_trace=true argument to the calibration functions.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To, for a single start calibration run, plot, for each iteration of the optimization process, the best objective value achieved so far, run:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res = calibrate_model(petab_problem, p0, IPNewton(); save_trace=true) # hide\nplot(res)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"For a multi-start calibration run, the default output is instead a so-called waterfall plot:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res_ms = PEtabMultistartOptimisationResult(\"../assets/boehm___for_petab_tutorial\") # hide\nplot(res_ms)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"(for this, and the next plot, we use a multi-start optimisation result from a different model, which yields less trivial optimisation runs than our catalysis one)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In the waterfall plot, each dot shows the final objective value for a single run in the multi-start process. The runs are ordered by their objective values, and colours designate runs in the same local minimum. A common use of waterfall plots is to check whether a sufficient number of runs (typically 5) has converged to the same best local minimum (in which case it is assumed to be the global minimum).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To instead use the best objective value plot for a multi-start run (with one curve for each run), the plot_type argument is used:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"plot(res_ms; plot_type = :best_objective)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"There exist several types of plots for both types of calibration results. More details of the types of available plots, and how to customise them, can be found here.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_citations","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Citations","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"If you use this functionality in your research, in addition to Catalyst, please cite the following papers to support the authors of the PEtab.jl package (currently there is no article associated with this package) and the PEtab standard:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@misc{2023Petabljl,\n  author       = {Ognissanti, Damiano AND Arutjunjan, Rafael AND Persson, Sebastian AND Hasselgren, Viktor},\n  title        = {{2023Petabljl.jl}},\n  howpublished = {\\url{https://github.com/sebapersson/PEtab.jl/}},\n  year         = {2023}\n}","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@article{SchmiesterSch2021,\n  author    = {Schmiester, Leonard AND Schälte, Yannik AND Bergmann, Frank T. AND Camba, Tacio AND Dudkin, Erika AND Egert, Janine AND Fröhlich, Fabian AND Fuhrmann, Lara AND Hauber, Adrian L. AND Kemmer, Svenja AND Lakrisenko, Polina AND Loos, Carolin AND Merkt, Simon AND Müller, Wolfgang AND Pathirana, Dilan AND Raimúndez, Elba AND Refisch, Lukas AND Rosenblatt, Marcus AND Stapor, Paul L. AND Städter, Philipp AND Wang, Dantong AND Wieland, Franz-Georg AND Banga, Julio R. AND Timmer, Jens AND Villaverde, Alejandro F. AND Sahle, Sven AND Kreutz, Clemens AND Hasenauer, Jan AND Weindl, Daniel},\n  journal   = {PLOS Computational Biology},\n  title     = {PEtab—Interoperable specification of parameter estimation problems in systems biology},\n  year      = {2021},\n  month     = {01},\n  number    = {1},\n  pages     = {1-10},\n  volume    = {17},\n  doi       = {10.1371/journal.pcbi.1008646},\n  publisher = {Public Library of Science},\n  url       = {https://doi.org/10.1371/journal.pcbi.1008646},\n}","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#References","page":"Parameter Fitting for ODEs using PEtab.jl","title":"References","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"[1]: Schmiester, L et al. PEtab—Interoperable specification of parameter estimation problems in systems biology, PLOS Computational Biology (2021).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"[2]: Hass, H et al. PBenchmark problems for dynamic modeling of intracellular processes, Bioinformatics (2019).","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/#bifurcation_diagrams","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"","category":"section"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Bifurcation diagrams describe how, for a dynamical system, the quantity and type of its steady states change as a parameter is varied[1]. When using Catalyst-generated models, these can be computed with the BifurcationKit.jl package. Catalyst provides a simple interface for creating BifurcationKit compatible BifurcationProblems from ReactionSystems.","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"This tutorial briefly introduces how to use Catalyst with BifurcationKit through basic examples, with BifurcationKit.jl providing a more extensive documentation. Especially for more complicated systems, where careful tuning of algorithm options might be required, reading the BifurcationKit documentation is recommended. Finally, BifurcationKit provides many additional features not described here, including computation of periodic orbits, tracking of bifurcation points along secondary parameters, and bifurcation computations for PDEs.","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/#Basic-example","page":"Bifurcation Diagrams","title":"Basic example","text":"","category":"section"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"For this example, we will use a modified version of the model from Wilhelm (2009)[2] (which demonstrates a bistable switch as the parameter k1 is varied). We declare the model using Catalyst:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using Catalyst\nwilhelm_2009_model = @reaction_network begin\n    k1, Y --> 2X\n    k2, 2X --> X + Y\n    k3, X + Y --> Y\n    k4, X --> 0\n    k5, 0 --> X\nend","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Next we will create a BifurcationProblem. In addition to the ReactionSystem, we need to provide:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"The bifurcation parameter (the parameter which is varied in the bifurcation diagram).\nA full model parameter set. This includes the values of all non-bifurcation parameters, but also a value for the bifurcation parameter (which corresponds to the point in parameter space from which the computation of the bifurcation diagram starts).\nAn initial guess of the steady state values of the system at the provided parameter set. Using this point as a starting guess for root finding, BifurcationKit calculates an initial steady state from which to compute the bifurcation diagram. Hence, this guess does not need to be very exact (but may be important if the system exhibits multistability for the initial parameter set).\nThe species or statistic we wish to plot on the y-axis of the bifurcation diagram (a custom value can be provided by using the record_from_solution argument).","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"We combine all this information to form a BifurcationProblem:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using BifurcationKit\nbif_par = :k1\nu_guess = [:X => 5.0, :Y => 2.0]\np_start = [:k1 => 4.0, :k2 => 1.0, :k3 => 1.0, :k4 => 1.5, :k5 => 1.25]\nplot_var = :X\nbprob = BifurcationProblem(wilhelm_2009_model, u_guess, p_start, bif_par; plot_var=plot_var)\nnothing # hide","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"BifurcationKit computes bifurcation diagrams using the bifurcationdiagram function. From an initial point in the diagram, it tracks the solution (using a continuation algorithm) until the entire diagram is computed (BifurcationKit's continuation can be used for other purposes, however, this tutorial focuses on bifurcation diagram computation). The continuation settings are provided in a ContinuationPar structure. In this example, we will only specify three settings, p_min and p_max (which sets the minimum and maximum values over which the bifurcation parameter is varied) and max_steps (the maximum number of continuation steps to take as the bifurcation diagram is tracked). We wish to compute a bifurcation diagram over the interval (20200), and will use the following settings:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_span = (2.0, 20.0)\nopts_br = ContinuationPar(p_min = p_span[1], p_max = p_span[2], max_steps=1000)\nnothing # hide","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Finally, we compute our bifurcation diagram using:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"bif_dia = bifurcationdiagram(bprob, PALC(), 2, (args...) -> opts_br; bothside=true)\nnothing # hide","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Where PALC() designates that we wish to use the pseudo arclength continuation method to track our solution. The third argument (2) designates the maximum number of recursions when branches of branches are computed (branches appear as continuation encounters certain bifurcation points). For diagrams with highly branched structures (rare for many common small chemical reaction networks) this input is important. Finally, bothside=true designates that we wish to perform continuation on both sides of the initial point (which is typically the case). ","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"We can plot our bifurcation diagram using the Plots.jl package:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using Plots\nplot(bif_dia; xguide=\"k1\", yguide=\"X\")","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, the steady state concentration of X is shown as a function of k1's value. Stable steady states are shown with thick lines, unstable ones with thin lines. The two fold bifurcation points are marked with \"bp\".","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/#Additional-ContinuationPar-options","page":"Bifurcation Diagrams","title":"Additional ContinuationPar options","text":"","category":"section"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Most of the options required by the bifurcationdiagram function are provided through the ContinuationPar structure. For full details, please read the BifurcationKit documentation. However, a few common options, and how they affect the continuation computation, are described here:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_min and p_max: Set the interval over which the bifurcation diagram is computed (with the continuation stopping if it reaches these bounds).\ndsmin and dsmax: The minimum and maximum length of the continuation steps (in the bifurcation parameter's value).\nmax_steps: The maximum number of continuation steps. If a bifurcation diagram looks incomplete, try increasing this value.\nnewton_options: Options for the Newton's method that BifurcationKit uses to find steady states. This can be created using NewtonPar(tol = 1e-9, max_iterations = 100) which here sets the tolerance (to 1e-9) and the maximum number of newton iterations (to 100).","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"The previous bifurcation diagram can be computed, with these various options specified, in the following way:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_span = (2.0, 20.0)\nopt_newton = NewtonPar(tol = 1e-9, max_iterations = 1000)\nopts_br = ContinuationPar(p_min = p_span[1], p_max = p_span[2], \n                          dsmin = 0.001, dsmax = 0.01, max_steps = 1000,\n                          newton_options = opt_newton)\nbif_dia = bifurcationdiagram(bprob, PALC(), 2, (args...) -> opts_br; bothside=true)\nnothing # hide","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"(however, in this case these additional settings have no significant effect on the result)","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/#Bifurcation-diagrams-with-disjoint-branches","page":"Bifurcation Diagrams","title":"Bifurcation diagrams with disjoint branches","text":"","category":"section"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Let's consider the previous case, but instead compute the bifurcation diagram over the interval (20150):","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_span = (2.0, 15.0)\nopts_br = ContinuationPar(p_min = p_span[1], p_max = p_span[2], max_steps = 1000)\nbif_dia = bifurcationdiagram(bprob, PALC(), 2, (args...) -> opts_br; bothside=true)\nplot(bif_dia; xguide=\"k1\", yguide=\"X\")","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, in the bistable region, we only see a single branch. The reason is that the continuation algorithm starts at our initial guess (here made at k1 = 40 for (XY) = (5020)) and tracks the diagram from there. However, with the upper bound set at k1=150 the bifurcation diagram has a disjoint branch structure, preventing the full diagram from being computed by continuation alone. In this case it could be solved by increasing the bound from k1=150, however, this is not possible in all cases. In these cases, deflation can be used. This is described in the BifurcationKit documentation.","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/#Systems-with-conservation-laws","page":"Bifurcation Diagrams","title":"Systems with conservation laws","text":"","category":"section"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Some systems are under-determined at steady-state, so that for a given parameter set they have an infinite number of possible steady state solutions, preventing bifurcation diagrams from being computed. Similar to when we compute steady states for fixed parameter values, we can utilise Catalyst's ability to detect and eliminate conservation laws to resolve this issue. This requires us to provide information of the species concentrations at which we wish to compute the bifurcation diagram (to determine the values of conserved quantities). These are provided to the BifurcationProblem using the u0 argument.","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"To illustrate this, we will create a simple model of a kinase that is produced and degraded (at rates p and d). The kinase facilitates the phosphorylation of a protein (X), which is dephosphorylated at a constant rate. For this system, we will compute a bifurcation diagram, showing how the concentration of the phosphorylated protein (Xp) depends on the degradation rate of the kinase (d). We will set the total amount of protein (X+Xp) to 10.","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using BifurcationKit, Catalyst, Plots\nkinase_model = @reaction_network begin\n    (p, d), 0 <--> K\n    (K*kP,kD), X <--> Xp\nend\n\nu_guess = [:K => 1.0, :X => 1.0, :Xp => 1.0]\np_start = [:p => 1.0, :d => 0.5, :kP => 2.0, :kD => 5.0]\nu0 = [:X => 1.0, :Xp => 0.0]\nbprob = BifurcationProblem(kinase_model, u_guess, p_start, :d; plot_var=:Xp, u0=u0)\n\np_span = (0.1, 10.0)\nopts_br = ContinuationPar(p_min = p_span[1], p_max = p_span[2], max_steps = 1000)\nbif_dia = bifurcationdiagram(bprob, PALC(), 2, (args...) -> opts_br; bothside=true)\nplot(bif_dia; xguide=\"d\", yguide=\"Xp\")","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"This bifurcation diagram does not contain any interesting features (such as bifurcation points), and only shows how the steady state concentration of Xp is reduced as d increases. ","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Finally, for additional clarity, we reiterate the purpose of the two u arguments used:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"u_guess: A guess of the initial steady states (which BifurcationKit uses to find its starting point). Typically, most trivial guesses work (e.g. setting all species concentrations to 1.0). u_guess does not have to fulfill the conserved concentrations provided in u0.\nu0: Used to compute the concentrations of any conserved quantities (e.g. in our example X + Xp = 10). Technically, values are only required for species that are involved in conservation laws (in our case we do not need to provide a value for K). However, sometimes determining which species are actually involved in conservation laws can be difficult, and it might be easier to simply provide concentrations for all species.","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/#bifurcation_kit_citation","page":"Bifurcation Diagrams","title":"Citation","text":"","category":"section"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"If you use this functionality in your research, please cite the following paper to support the author of the BifurcationKit package:","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"@misc{veltz:hal-02902346,\n  title = {{BifurcationKit.jl}},\n  author = {Veltz, Romain},\n  url = {https://hal.archives-ouvertes.fr/hal-02902346},\n  institution = {{Inria Sophia-Antipolis}},\n  year = {2020},\n  month = Jul,\n  keywords = {pseudo-arclength-continuation ; periodic-orbits ; floquet ; gpu ; bifurcation-diagram ; deflation ; newton-krylov},\n  pdf = {https://hal.archives-ouvertes.fr/hal-02902346/file/354c9fb0d148262405609eed2cb7927818706f1f.tar.gz},\n  hal_id = {hal-02902346},\n  hal_version = {v1},\n}","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/#References","page":"Bifurcation Diagrams","title":"References","text":"","category":"section"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"[1]: Yuri A. Kuznetsov, Elements of Applied Bifurcation Theory, Springer (2023).","category":"page"},{"location":"catalyst_applications/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"[2]: Thomas Wilhelm, The smallest chemical reaction system with bistability, BMC Systems Biology (2009).","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/#simulation_structure_interfacing","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"","category":"section"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"When simulating a model, one begins with creating a problem. Next, a simulation is performed on a problem, during which the state of the simulation is recorded through an integrator. Finally, the simulation output is returned as a solution. This tutorial describes how to access, or modify the state, or parameter, values of problems, integrators, and solutions structures.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Generally, when we have a structure simulation_struct and want to interface with the state (or parameter) G, we use simulation_struct[:G] to access the value, and simulation_struct[:G] = 5.0 to set it to a new value. However, see the following examples for full details.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/#Interfacing-problem-objects","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problem objects","text":"","category":"section"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"We begin by demonstrating how we can interface with problem objects. We will demonstrate using a ODEProblem, however, it works similarly for other problem types.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using Catalyst\nrn = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\n\nu0 = [:X1 => 1.0, :X2 => 5.0]\np = [:k1 => 5.0, :k2 => 2.0]\noprob = ODEProblem(rn, u0, (0.0,10.0), p)\nnothing    # hide","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"We can find the value of a state simply by interfacing with the corresponding symbol:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[:X1]","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"with the notation being identical for parameters:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[:k1]","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"If we want to change a state's initial condition value, we use the following notation","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[:X1] = 10.0","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"with parameters using the same notation.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/#simulation_structure_interfacing_remake","page":"Interfacing problems, integrators, and solutions","title":"Remaking problems using the remake function","text":"","category":"section"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Typically, when modifying problems, it is recommended to use the remake function. Unlike when we do oprob[:X1] = 10.0 (which modifies the problem in question), remake creates a new problem object. The remake function takes a problem as input, and any fields you wish to modify (and their new values) as optional inputs. Thus, we can do:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using DifferentialEquations\n@unpack X1, X2, k1, k2 = rn\noprob1 = ODEProblem(rn, u0, (0.0,10.0), p)\noprob2 = remake(oprob1; u0=[X1 => 10.0, X2 => 50.0], tspan=(0.0,100.0), p=[k1 => 50.0,k2 => 20.0])\nnothing    # hide","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"and we can now check the fields of oprob2","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob2.u0","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob2.tspan","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob2.p","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Please note that, currently, remake does not work while giving Symbols as input (e.g [:X1 => 10.0, :X2 => 50.0]), but we need to unpack the symbolic variables and use them instead (please see the end of this tutorial for more information on using symbolic variables rather than Symbols).","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"When using remake, we only have to provide the fields that we actually wish to change, e.g.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob3 = remake(oprob1; u0=[X1 => 10.0, X2 => 50.0])\nnothing    # hide","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"will only update the initial conditions.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/#Interfacing-integrator-objects","page":"Interfacing problems, integrators, and solutions","title":"Interfacing integrator objects","text":"","category":"section"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"During a simulation, the solution is stored in an integrator object, we will here describe how to interface with these. The primary circumstance under which a user may wish to do so is when using callbacks. We can create an integrator by calling init on our problem (while circumstances where the user might want to use init function exist, since integrators are automatically created during simulations, these are rare):","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator = init(oprob)","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Using a similar syntax to problems, we can get the current values of a state within the integrator:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator[:X1]","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"or a parameter:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator[:k1]","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Similarly, we can update their values using:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator[:X1] = 10.0","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Please read this with regards to updating integrators of JumpProblems.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/#simulation_structure_interfacing_solutions","page":"Interfacing problems, integrators, and solutions","title":"Interfacing solution objects","text":"","category":"section"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Finally, we consider solution objects. First, we simulate our problem:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol = solve(oprob)","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"For solutions, when we access a state, we get its whole simulation vector:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol[:X1]","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"while when we access a parameter we only get a single value:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol[:k1]","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Finally, we note that we cannot change the values of solution states or parameters (i.e. both sol[:X1] = 0.0 and sol[:k1] = 0.0 generate errors).","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/#simulation_structure_interfacing_symbolic_representation","page":"Interfacing problems, integrators, and solutions","title":"Interfacing using symbolic representation","text":"","category":"section"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Catalyst is built on an intermediary representation implemented by (ModelingToolkit.jl)[https://github.com/SciML/ModelingToolkit.jl]. ModelingToolkit is a modelling framework where one first declares a set of symbolic variables and parameters using e.g.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using ModelingToolkit\n@parameters σ ρ β\n@variables t x(t) y(t) z(t)\nnothing # hide","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"and then uses these to build systems of equations. Here, these symbolic variables (x, y, and z) and parameters (σ, ρ, and β) can be used to interface a problem, integrator, and solution object (like we did previously, but using Symbols, e.g. :X). Since Catalyst models are built on ModelingToolkit, these models also contain similar symbolic variables and parameters.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using Catalyst\nrn = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\n\n@unpack k1,k2,X1,X2 = rn","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Here, we first list the parameters and variables (for reaction systems the latter are typically species) we wish to import (in this case we select all, but we could select only a subset), next we denote from which model (here rn) from which we wish to import from. Next, these values can be used directly to interface with e.g. an ODEProblem:","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"u0 = [X1 => 1.0, X2 => 5.0]\np = [:k1 => 5.0, :k2 => 2.0]\noprob = ODEProblem(rn, u0, (0.0,10.0), p)\n\noprob[k1]","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"To interface with integrators and solutions we use a similar syntax.","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Finally, instead of using @unpack to access a symbolic variable or parameter, we can access it directly using rn.X1, and thus access a state of our ODEProblem using","category":"page"},{"location":"catalyst_applications/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[rn.X1]","category":"page"},{"location":"catalyst_functionality/compositional_modeling/#compositional_modeling","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"","category":"section"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst supports the construction of models in a compositional fashion, based on ModelingToolkit's subsystem functionality. In this tutorial we'll see how we can construct the earlier repressilator model by composing together three identically repressed genes, and how to use compositional modeling to create compartments.","category":"page"},{"location":"catalyst_functionality/compositional_modeling/#Compositional-modeling-tooling","page":"Compositional Modeling of Reaction Systems","title":"Compositional modeling tooling","text":"","category":"section"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst supports two ModelingToolkit interfaces for composing multiple ReactionSystems together into a full model. The first mechanism for extending a system is the extend command","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"using Catalyst\nbasern = @reaction_network rn1 begin\n  k, A + B --> C\nend\nnewrn = @reaction_network rn2 begin\n  r, C --> A + B\nend\n@named rn = extend(newrn, basern)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Here we extended basern with newrn giving a system with all the reactions. Note, if a name is not specified via @named or the name keyword then rn will have the same name as newrn.","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"The second main compositional modeling tool is the use of subsystems. Suppose we now add to basern two subsystems, newrn and newestrn, we get a different result:","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"newestrn = @reaction_network rn3 begin\n            v, A + D --> 2D\n           end\n@named rn = compose(basern, [newrn, newestrn])","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Here we have created a new ReactionSystem that adds newrn and newestrn as subsystems of basern. The variables and parameters in the sub-systems are considered distinct from those in other systems, and so are namespaced (i.e. prefaced) by the name of the system they come from.","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"We can see the subsystems of a given system by","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_systems(rn)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"They naturally form a tree-like structure","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"using Plots, GraphRecipes\nplot(TreePlot(rn), method=:tree, fontsize=12, nodeshape=:ellipse)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"(Image: rn network with subsystems)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"We could also have directly constructed rn using the same reaction as in basern as","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"@parameters k\n@variables t\n@species A(t), B(t), C(t)\nrxs = [Reaction(k, [A,B], [C])]\n@named rn = ReactionSystem(rxs, t; systems = [newrn, newestrn])","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst provides several different accessors for getting information from a single system, or all systems in the tree. To get the species, parameters, and reactions only within a given system (i.e. ignoring subsystems), we can use","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst.get_species(rn)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_ps(rn)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst.get_rxs(rn)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"To see all the species, parameters and reactions in the tree we can use","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"species(rn)   # or states(rn)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"parameters(rn)  # or reactionparameters(rn)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"reactions(rn)   # or equations(rn)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"If we want to collapse rn down to a single system with no subsystems we can use","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"flatrn = Catalyst.flatten(rn)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"where","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_systems(flatrn)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"More about ModelingToolkit's interface for compositional modeling can be found in the ModelingToolkit docs.","category":"page"},{"location":"catalyst_functionality/compositional_modeling/#Compositional-model-of-the-repressilator","page":"Compositional Modeling of Reaction Systems","title":"Compositional model of the repressilator","text":"","category":"section"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Let's apply the tooling we've just seen to create the repressilator in a more modular fashion. We start by defining a function that creates a negatively repressed gene, taking the repressor as input","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"function repressed_gene(; R, name)\n  @reaction_network $name begin\n    hillr($R,α,K,n), ∅ --> m\n    (δ,γ), m <--> ∅\n    β, m --> m + P\n    μ, P --> ∅\n  end\nend\nnothing # hide","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Here we assume the user will pass in the repressor species as a ModelingToolkit variable, and specify a name for the network. We use Catalyst's interpolation ability to substitute the value of these variables into the DSL (see Interpolation of Julia Variables). To make the repressilator we now make three genes, and then compose them together","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"@variables t\n@species G3₊P(t)\n@named G1 = repressed_gene(; R=ParentScope(G3₊P))\n@named G2 = repressed_gene(; R=ParentScope(G1.P))\n@named G3 = repressed_gene(; R=ParentScope(G2.P))\n@named repressilator = ReactionSystem(t; systems=[G1,G2,G3])","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Notice, in this system each gene is a child node in the system graph of the repressilator","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"plot(TreePlot(repressilator), method=:tree, fontsize=12, nodeshape=:ellipse)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"(Image: repressilator tree plot)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"In building the repressilator we needed to use two new features. First, we needed to create a symbolic variable that corresponds to the protein produced by the third gene before we created the corresponding system. We did this via @variables t, G3₊P(t). We also needed to set the scope where each repressor lived. Here ParentScope(G3₊P), ParentScope(G1.P), and ParentScope(G2.P) signal Catalyst that these variables will come from parallel systems in the tree that have the same parent as the system being constructed (in this case the top-level repressilator system).","category":"page"},{"location":"catalyst_functionality/compositional_modeling/#Compartment-based-models","page":"Compositional Modeling of Reaction Systems","title":"Compartment-based models","text":"","category":"section"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Finally, let's see how we can make a compartment-based model. Let's create a simple eukaryotic gene expression model with negative feedback by protein dimers. Transcription and gene inhibition by the protein dimer occurs in the nucleus, translation and dimerization occur in the cytosol, and nuclear import and export reactions couple the two compartments. We'll include volume parameters for the nucleus and cytosol, and assume we are working with species having units of number of molecules. Rate constants will have their common concentration units, i.e. if V denotes the volume of a compartment then","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Reaction Type Example Rate Constant Units Effective rate constant (units of per time)\nZero order varnothing oversetalphato A concentration / time alpha V\nFirst order A oversetbetato B (time)⁻¹ beta\nSecond order A + B oversetgammato C (concentration × time)⁻¹ gammaV","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"In our model we'll therefore add the conversions of the last column to properly account for compartment volumes:","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"# transcription and regulation\nnuc = @reaction_network nuc begin\n  α, G --> G + M\n  (κ₊/V,κ₋), D + G <--> DG\nend\n\n# translation and dimerization\ncyto = @reaction_network cyto begin\n  β, M --> M + P\n  (k₊/V,k₋), 2P <--> D\n  σ, P --> 0\n  μ, M --> 0\nend\n\n# export reactions,\n# γ,δ=probability per time to be exported/imported\nmodel = @reaction_network model begin\n  γ, $(nuc.M) --> $(cyto.M)\n  δ, $(cyto.D) --> $(nuc.D)\nend\n@named model = compose(model, [nuc, cyto])","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"A graph of the resulting network is","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Graph(model)","category":"page"},{"location":"catalyst_functionality/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"(Image: graph of gene regulation model)","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/#parametric_stoichiometry","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"","category":"section"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Catalyst supports stoichiometric coefficients that involve parameters, species, or even general expressions. In this tutorial we show several examples of how to use symbolic stoichiometries, and discuss several caveats to be aware of.","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/#Using-symbolic-stoichiometry","page":"Symbolic Stochiometries","title":"Using symbolic stoichiometry","text":"","category":"section"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Let's first consider a simple reversible reaction where the number of reactants is a parameter, and the number of products is the product of two parameters.","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"using Catalyst, Latexify, DifferentialEquations, ModelingToolkit, Plots\nrevsys = @reaction_network revsys begin\n    k₊, m*A --> (m*n)*B\n    k₋, B --> A\nend\nreactions(revsys)","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Note, as always the @reaction_network macro defaults to setting all symbols neither used as a reaction substrate nor a product to be parameters. Hence, in this example we have two species (A and B) and four parameters (k₊, k₋, m, and n). In addition, the stoichiometry is applied to the rightmost symbol in a given term, i.e. in the first equation the substrate A has stoichiometry m and the product B has stoichiometry m*n. For example, in","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"rn = @reaction_network begin\n    k, A*C --> 2B\n    end\nreactions(rn)","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"we see two species, (B,C), with A treated as a parameter representing the stoichiometric coefficient of C, i.e.","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"rx = reactions(rn)[1]\nrx.substrates[1],rx.substoich[1]","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"We could have equivalently specified our systems directly via the Catalyst API. For example, for revsys we would could use","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"@parameters k₊, k₋, m, n\n@variables t\n@species A(t), B(t)\nrxs = [Reaction(k₊, [A], [B], [m], [m*n]),\n       Reaction(k₋, [B], [A])]\nrevsys2 = ReactionSystem(rxs,t; name=:revsys)\nrevsys2 == revsys","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"which can be simplified using the @reaction macro to","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"rxs2 = [(@reaction k₊, m*A --> (m*n)*B),\n        (@reaction k₋, B --> A)]\nrevsys3 = ReactionSystem(rxs2,t; name=:revsys)\nrevsys3 == revsys","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Note, the @reaction macro again assumes all symbols are parameters except the substrates or reactants (i.e. A and B). For example, in @reaction k, F*A + 2(H*G+B) --> D, the substrates are (A,G,B) with stoichiometries (F,2*H,2).","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Let's now convert revsys to ODEs and look at the resulting equations:","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"osys = convert(ODESystem, revsys)\nequations(osys)\nshow(stdout, MIME\"text/plain\"(), equations(osys)) # hide","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Notice, as described in the Reaction rate laws used in simulations section, the default rate laws involve factorials in the stoichiometric coefficients. For this reason we must specify m and n as integers, and hence use a tuple for the parameter mapping","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"p  = (k₊ => 1.0, k₋ => 1.0, m => 2, n => 2)\nu₀ = [A => 1.0, B => 1.0]\noprob = ODEProblem(osys, u₀, (0.0, 1.0), p)\nnothing # hide","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"We can now solve and plot the system","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"sol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"If we had used a vector to store parameters, m and n would be converted to floating point giving an error when solving the system. Note, currently a bug in ModelingToolkit has broken this example by converting to floating point when using tuple parameters, see the alternative approach below for a workaround.","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"An alternative approach to avoid the issues of using mixed floating point and integer variables is to disable the rescaling of rate laws as described in Reaction rate laws used in simulations section. This requires passing the combinatoric_ratelaws=false keyword to convert or to ODEProblem (if directly building the problem from a ReactionSystem instead of first converting to an ODESystem). For the previous example this gives the following (different) system of ODEs","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"osys = convert(ODESystem, revsys; combinatoric_ratelaws = false)\nequations(osys)\nshow(stdout, MIME\"text/plain\"(), equations(osys)) # hide","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Since we no longer have factorial functions appearing, our example will now run even with floating point values for m and n:","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"p  = (k₊ => 1.0, k₋ => 1.0, m => 2.0, n => 2.0)\noprob = ODEProblem(osys, u₀, (0.0, 1.0), p)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/#Gene-expression-with-randomly-produced-amounts-of-protein","page":"Symbolic Stochiometries","title":"Gene expression with randomly produced amounts of protein","text":"","category":"section"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"As a second example, let's build the negative feedback model from MomentClosure.jl that involves a bursty reaction that produces a random amount of protein.","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"In our model G₋ will denote the repressed state, and G₊ the active state where the gene can transcribe. P will denote the protein product of the gene. We will assume that proteins are produced in bursts that produce m proteins, where m is a (shifted) geometric random variable with mean b. To define m we must register the Distributions.Geometric distribution from Distributions.jl with Symbolics.jl, after which we can use it in symbolic expressions:","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"using Distributions: Geometric\n@register_symbolic Geometric(b)\n@parameters b\nm = rand(Geometric(1/b)) + 1\nnothing # hide","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Note, as we require the shifted geometric distribution, we add one to Distributions.jl's Geometric random variable (which includes zero).","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"We can now define our model","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"burstyrn = @reaction_network burstyrn begin\n    k₊, G₋ --> G₊\n    k₋*P^2, G₊ --> G₋\n    kₚ, G₊ --> G₊ + $m*P\n    γₚ, P --> ∅\nend\nreactions(burstyrn)\nshow(stdout, MIME\"text/plain\"(), reactions(burstyrn)) # hide","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"The parameter b does not need to be explicitly declared in the @reaction_network macro as it is detected when the expression rand(Geometric(1/b)) + 1 is substituted for m.","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"We next convert our network to a jump process representation","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"jsys = convert(JumpSystem, burstyrn; combinatoric_ratelaws = false)\nequations(jsys)\nshow(stdout, MIME\"text/plain\"(), equations(jsys)) # hide","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Notice, the equations of jsys have three MassActionJumps for the first three reactions, and one ConstantRateJump for the last reaction. If we examine the ConstantRateJump more closely we can see the generated rate and affect! functions for the bursty reaction that makes protein","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"equations(jsys)[4].rate\nshow(stdout, MIME\"text/plain\"(), equations(jsys)[4].rate) # hide","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"equations(jsys)[4].affect!\nshow(stdout, MIME\"text/plain\"(), equations(jsys)[4].affect!) # hide","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Finally, we can now simulate our jumpsystem","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"pmean = 200\nbval = 70\nγₚval = 1\nk₋val = 0.001\nk₊val = 0.05\nkₚval = pmean * γₚval * (k₋val * pmean^2 + k₊val) / (k₊val * bval)\np = symmap_to_varmap(jsys, (:k₊ => k₊val, :k₋ => k₋val, :kₚ => kₚval,\n                            :γₚ => γₚval, :b => bval))\nu₀ = symmap_to_varmap(jsys, [:G₊ => 1, :G₋ => 0, :P => 1])\ntspan = (0., 6.0)   # time interval to solve over\ndprob = DiscreteProblem(jsys, u₀, tspan, p)\njprob = JumpProblem(jsys, dprob, Direct())\nsol = solve(jprob, SSAStepper())\nplot(sol.t, sol[jsys.P], legend = false, xlabel = \"time\", ylabel = \"P(t)\")","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"To double check our results are consistent with MomentClosure.jl, let's calculate and plot the average amount of protein (which is also plotted in the MomentClosure.jl tutorial).","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"function getmean(jprob, Nsims, tv)\n    Pmean = zeros(length(tv))\n    @variables t, P(t)\n    for n in 1:Nsims\n        sol = solve(jprob, SSAStepper())\n        Pmean .+= sol(tv, idxs=P)\n    end\n    Pmean ./= Nsims\nend\ntv = range(tspan[1],tspan[2],step=.1)\npsim_mean = getmean(jprob, 20000, tv)\nplot(tv, psim_mean; ylabel = \"average of P(t)\", xlabel = \"time\",\n                    xlim = (0.0,6.0), legend = false)","category":"page"},{"location":"catalyst_functionality/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Comparing, we see similar averages for P(t).","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"In this tutorial we provide an introduction to using Catalyst to specify chemical reaction networks, and then to solve ODE, jump, and SDE models generated from them. At the end we show what mathematical rate laws and transition rate functions (i.e. intensities or propensities) are generated by Catalyst for ODE, SDE and jump process models.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Let's start by using the Catalyst @reaction_network macro to specify a simple chemical reaction network: the well-known repressilator.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We first import the basic packages we'll need:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"# If not already installed, first hit \"]\" within a Julia REPL. Then type:\n# add Catalyst DifferentialEquations Plots Latexify\n\nusing Catalyst, DifferentialEquations, Plots, Latexify","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We now construct the reaction network. The basic types of arrows and predefined rate laws one can use are discussed in detail within the tutorial, The Reaction DSL. Here, we use a mix of first order, zero order, and repressive Hill function rate laws. Note, varnothing corresponds to the empty state, and is used for zeroth order production and first order degradation reactions:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"repressilator = @reaction_network Repressilator begin\n    hillr(P₃,α,K,n), ∅ --> m₁\n    hillr(P₁,α,K,n), ∅ --> m₂\n    hillr(P₂,α,K,n), ∅ --> m₃\n    (δ,γ), m₁ <--> ∅\n    (δ,γ), m₂ <--> ∅\n    (δ,γ), m₃ <--> ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    β, m₃ --> m₃ + P₃\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\n    μ, P₃ --> ∅\nend\nshow(stdout, MIME\"text/plain\"(), repressilator) # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"showing that we've created a new network model named Repressilator with the listed chemical species and states. @reaction_network returns a ReactionSystem, which we saved in the repressilator variable. It can be converted to a variety of other mathematical models represented as ModelingToolkit.AbstractSystems, or analyzed in various ways using the Catalyst.jl API. For example, to see the chemical species, parameters, and reactions we can use","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"species(repressilator)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"parameters(repressilator)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"and","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"reactions(repressilator)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We can also use Latexify to see the corresponding reactions in Latex, which shows what the hillr terms mathematically correspond to","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"latexify(repressilator)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"repressilator #hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Assuming Graphviz is installed and command line accessible, within a Jupyter notebook we can also graph the reaction network by","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"g = Graph(repressilator)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"giving","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"(Image: Repressilator solution)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"The network graph shows a variety of information, representing each species as a blue node, and each reaction as an orange dot. Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry. Similarly, black arrows from reactions to species indicate products, and are labelled with their output stoichiometry. In contrast, red arrows from a species to reactions indicate the species is used within the reactions' rate expressions. For the repressilator, the reactions","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"hillr(P₃,α,K,n), ∅ --> m₁\nhillr(P₁,α,K,n), ∅ --> m₂\nhillr(P₂,α,K,n), ∅ --> m₃","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"have rates that depend on the proteins, and hence lead to red arrows from each Pᵢ.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Note, from the REPL or scripts one can always use savegraph to save the graph (assuming Graphviz is installed).","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Mass-action-ODE-models","page":"Introduction to Catalyst","title":"Mass action ODE models","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Let's now use our ReactionSystem to generate and solve a corresponding mass action ODE model. We first convert the system to a ModelingToolkit.ODESystem by","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"odesys = convert(ODESystem, repressilator)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"(Here Latexify is used automatically to display odesys in Latex within Markdown documents or notebook environments like Pluto.jl.)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Before we can solve the ODEs, we need to specify the values of the parameters in the model, the initial condition, and the time interval to solve the model on. To do this we need to build mappings from the symbolic parameters and the species to the corresponding numerical values for parameters and initial conditions. We can build such mappings in several ways. One is to use Julia Symbols to specify the values like","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"pmap  = (:α => .5, :K => 40, :n => 2, :δ => log(2)/120,\n         :γ => 5e-3, :β => log(2)/6, :μ => log(2)/60)\nu₀map = [:m₁ => 0., :m₂ => 0., :m₃ => 0., :P₁ => 20., :P₂ => 0., :P₃ => 0.]\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Alternatively, we can use ModelingToolkit-based symbolic species variables to specify these mappings like","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"@parameters  α K n δ γ β μ\n@variables t\n@species m₁(t) m₂(t) m₃(t) P₁(t) P₂(t) P₃(t)\npsymmap  = (α => .5, K => 40, n => 2, δ => log(2)/120,\n         γ => 5e-3, β => 20*log(2)/120, μ => log(2)/60)\nu₀symmap = [m₁ => 0., m₂ => 0., m₃ => 0., P₁ => 20., P₂ => 0., P₃ => 0.]\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Knowing these mappings we can set up the ODEProblem we want to solve:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"# time interval to solve on\ntspan = (0., 10000.)\n\n# create the ODEProblem we want to solve\noprob = ODEProblem(repressilator, u₀map, tspan, pmap)\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"By passing repressilator directly to the ODEProblem, Catalyst has to (internally) call convert(ODESystem, repressilator) again to generate the symbolic ODEs. We could instead pass odesys directly like","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"oprob2 = ODEProblem(odesys, u₀symmap, tspan, psymmap)\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"oprob and oprob2 are functionally equivalent, each representing the same underlying problem.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"note: Note\nWhen passing odesys to ODEProblem we needed to use the symbolic variable-based parameter mappings, u₀symmap and psymmap, while when directly passing repressilator we could use either those or the Symbol-based mappings, u₀map and pmap. Symbol-based mappings can always be converted to symbolic mappings using symmap_to_varmap, see the Basic Syntax section for more details.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"At this point we are all set to solve the ODEs. We can now use any ODE solver from within the DifferentialEquations.jl package. We'll use the recommended default explicit solver, Tsit5(), and then plot the solutions:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"sol = solve(oprob, Tsit5(), saveat=10.)\nplot(sol)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We see the well-known oscillatory behavior of the repressilator! For more on the choices of ODE solvers, see the DifferentialEquations.jl documentation.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Stochastic-simulation-algorithms-(SSAs)-for-stochastic-chemical-kinetics","page":"Introduction to Catalyst","title":"Stochastic simulation algorithms (SSAs) for stochastic chemical kinetics","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Let's now look at a stochastic chemical kinetics model of the repressilator, modeling it with jump processes. Here, we will construct a JumpProcesses JumpProblem that uses Gillespie's Direct method, and then solve it to generate one realization of the jump process:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"# redefine the initial condition to be integer valued\nu₀map = [:m₁ => 0, :m₂ => 0, :m₃ => 0, :P₁ => 20, :P₂ => 0, :P₃ => 0]\n\n# next we create a discrete problem to encode that our species are integer-valued:\ndprob = DiscreteProblem(repressilator, u₀map, tspan, pmap)\n\n# now, we create a JumpProblem, and specify Gillespie's Direct Method as the solver:\njprob = JumpProblem(repressilator, dprob, Direct(), save_positions=(false,false))\n\n# now, let's solve and plot the jump process:\nsol = solve(jprob, SSAStepper(), saveat=10.)\nplot(sol)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We see that oscillations remain, but become much noisier. Note, in constructing the JumpProblem we could have used any of the SSAs that are part of JumpProcesses instead of the Direct method, see the list of SSAs (i.e., constant rate jump aggregators) in the documentation.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Common questions that arise in using the JumpProcesses SSAs (i.e. Gillespie methods) are collated in the JumpProcesses FAQ.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Chemical-Langevin-equation-(CLE)-stochastic-differential-equation-(SDE)-models","page":"Introduction to Catalyst","title":"Chemical Langevin equation (CLE) stochastic differential equation (SDE) models","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"At an intermediate physical scale between macroscopic ODE models and microscopic stochastic chemical kinetics models lies the CLE, given by a system of SDEs that add to each ODE above a noise term. As the repressilator has species that get very close to zero in size, it is not a good candidate to model with the CLE (where solutions can then go negative and become unphysical). Let's create a simpler reaction network for a birth-death process that will stay non-negative:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"bdp = @reaction_network begin\n  c₁, X --> 2X\n  c₂, X --> 0\n  c₃, 0 --> X\nend\np = (:c₁ => 1.0, :c₂ => 2.0, :c₃ => 50.)\nu₀ = [:X => 5.]\ntspan = (0.,4.)\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"The corresponding Chemical Langevin Equation SDE is then","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"dX(t) = left( c_1 Xleft( t right) - c_2 Xleft( t right) + c_3 right) dt + sqrtc_1 X(t) dW_1(t) - sqrtc_2 X(t) dW_2(t) + sqrtc_3 dW_3(t)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"where each W_i(t) denotes an independent Brownian Motion. We can solve the CLE model by creating an SDEProblem and solving it similarly to what we did for ODEs above:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"# SDEProblem for CLE\nsprob = SDEProblem(bdp, u₀, tspan, p)\n\n# solve and plot, tstops is used to specify enough points\n# that the plot looks well-resolved\nsol = solve(sprob, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))\nplot(sol)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We again have complete freedom to select any of the StochasticDiffEq.jl SDE solvers, see the documentation.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Specifying-a-complete-model-via-the-DSL","page":"Introduction to Catalyst","title":"Specifying a complete model via the DSL","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"In the previous examples we specified initial conditions and parameter values via mappings that were constructed after building our ReactionSystem. Catalyst also supports specifying default values for these during ReactionSystem construction. For example, for the last SDE example we could have also built and simulated the complete model using the DSL like","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"bdp2 = @reaction_network begin\n    @parameters c₁ = 1.0 c₂ = 2.0 c₃ = 50.0\n    @species X(t) = 5.0\n    c₁, X --> 2X\n    c₂, X --> 0\n    c₃, 0 --> X\nend\ntspan = (0., 4.)\nsprob2 = SDEProblem(bdp2, [], tspan)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Let's now simulate both models, starting from the same random number generator seed, and check we get the same solutions","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"using Random\nRandom.seed!(1)\nsol = solve(sprob, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))\np1 = plot(sol)\nRandom.seed!(1)\nsol2 = solve(sprob2, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))\np2 = plot(sol2)\nplot(p1, p2, layout = (2,1))","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"For details on what information can be specified via the DSL see the The Reaction DSL tutorial.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Reaction-rate-laws-used-in-simulations","page":"Introduction to Catalyst","title":"Reaction rate laws used in simulations","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"In generating mathematical models from a ReactionSystem, reaction rates are treated as microscopic rates. That is, for a general mass action reaction of the form n_1 S_1 + n_2 S_2 + dots n_M S_M to dots with stoichiometric substrate coefficients n_i_i=1^M and rate constant k, the corresponding ODE and SDE rate laws are taken to be","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"k prod_i=1^M frac(S_i)^n_in_i","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"while the jump process transition rate (i.e., the propensity or intensity function) is","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"k prod_i=1^M fracS_i (S_i-1) dots (S_i-n_i+1)n_i","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"For example, the rate law of the reaction 2X + 3Y to Z with rate constant k would be","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"k fracX^22 fracY^33 ","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"giving the ODE model","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"beginalign*\nfracdXdt =  -2 k fracX^22 fracY^33 \nfracdYdt =  -3 k fracX^22 fracY^33 \nfracdZdt = k fracX^22 fracY^33\nendalign*","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"This implicit rescaling of rate constants can be disabled through explicit conversion of a ReactionSystem to another system via Base.convert using the combinatoric_ratelaws=false keyword argument, i.e.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"rn = @reaction_network ...\nconvert(ODESystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"For the previous example using this keyword argument would give the rate law","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"k X^2 Y^3","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"and the ODE model","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"beginalign*\nfracdXdt =  -2 k X^2 Y^3 \nfracdYdt =  -3 k X^2 Y^3 \nfracdZdt = k X^2 Y^3\nendalign*","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Notes","page":"Introduction to Catalyst","title":"Notes","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"For each of the preceding models we converted the ReactionSystem to, i.e., ODEs, jumps, or SDEs, we had two paths for conversion:\na. Convert to the corresponding ModelingToolkit system and then use it in     creating the corresponding problem.\nb. Directly create the desired problem type from the ReactionSystem.\nThe latter is more convenient, however, the former will be more efficient if one needs to repeatedly create the associated Problem.\nModelingToolkit offers many options for optimizing the generated ODEs and SDEs, including options to build functions for evaluating Jacobians and/or multithreaded versions of derivative evaluation functions. See the options for ODEProblems and SDEProblems.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#References","page":"Introduction to Catalyst","title":"References","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"[1]: Torkel E. Loman, Yingbo Ma, Vasily Ilin, Shashi Gowda, Niklas Korsbo, Nikhil Yewale, Chris Rackauckas, Samuel A. Isaacson, Catalyst: Fast and flexible modeling of reaction networks, PLOS Computational Biology (2023).","category":"page"},{"location":"catalyst_functionality/network_analysis/#network_analysis","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In this tutorial we introduce several of the Catalyst API functions for network analysis. A complete summary of the exported functions is given in the API section Network-Analysis-and-Representations.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).","category":"page"},{"location":"catalyst_functionality/network_analysis/#Network-representation-of-the-Repressilator-ReactionSystem","page":"Network Analysis in Catalyst","title":"Network representation of the Repressilator ReactionSystem","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We first load Catalyst and construct our model of the repressilator","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"using Catalyst\nrepressilator = @reaction_network Repressilator begin\n       hillr(P₃,α,K,n), ∅ --> m₁\n       hillr(P₁,α,K,n), ∅ --> m₂\n       hillr(P₂,α,K,n), ∅ --> m₃\n       (δ,γ), m₁ <--> ∅\n       (δ,γ), m₂ <--> ∅\n       (δ,γ), m₃ <--> ∅\n       β, m₁ --> m₁ + P₁\n       β, m₂ --> m₂ + P₂\n       β, m₃ --> m₃ + P₃\n       μ, P₁ --> ∅\n       μ, P₂ --> ∅\n       μ, P₃ --> ∅\nend","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In the Introduction to Catalyst tutorial we showed how the above network could be visualized as a species-reaction graph. There, species are represented by the nodes of the graph and edges show the reactions in which a given species is a substrate or product.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"g = Graph(repressilator)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: Repressilator solution)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We also showed in the Introduction to Catalyst tutorial that the reaction rate equation ODE model for the repressilator is","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"beginaligned\nfracdm_1(t)dt = fracalpha K^nK^n + left( P_3left( t right) right)^n - delta m_1left( t right) + gamma \nfracdm_2(t)dt = fracalpha K^nK^n + left( P_1left( t right) right)^n - delta m_2left( t right) + gamma \nfracdm_3(t)dt = fracalpha K^nK^n + left( P_2left( t right) right)^n - delta m_3left( t right) + gamma \nfracdP_1(t)dt = beta m_1left( t right) - mu P_1left( t right) \nfracdP_2(t)dt = beta m_2left( t right) - mu P_2left( t right) \nfracdP_3(t)dt = beta m_3left( t right) - mu P_3left( t right)\nendaligned","category":"page"},{"location":"catalyst_functionality/network_analysis/#Matrix-vector-reaction-rate-equation-representation","page":"Network Analysis in Catalyst","title":"Matrix-vector reaction rate equation representation","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In general, reaction rate equation (RRE) ODE models for chemical reaction networks can be represented as a first-order system of ODEs in a compact matrix-vector notation. Suppose we have a reaction network with K reactions and M species, labelled by the state vector","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"mathbfx(t) = beginpmatrix x_1(t)  vdots  x_M(t)) endpmatrix","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"For the repressilator, mathbfx(t) is just","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"x = species(repressilator)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The RRE ODEs satisfied by mathbfx(t) are then","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"fracdmathbfxdt = N mathbfv(mathbfx(t)t)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"where N is a constant M by K matrix with N_m k the net stoichiometric coefficient of species m in reaction k. mathbfv(mathbfx(t)t) is the rate law vector, with v_k(mathbfx(t)t) the rate law for the kth reaction. For example, for the first reaction of the repressilator above, the rate law is","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"v_1(mathbfx(t)t) = fracalpha K^nK^n + left( P_3(t) right)^n","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can calculate each of these in Catalyst via","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"N = netstoichmat(repressilator)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"and by using the oderatelaw function","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rxs = reactions(repressilator)\nν = oderatelaw.(rxs)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Note, as oderatelaw takes just one reaction as input we use broadcasting to apply it to each element of rxs.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Let's check that this really gives the same ODEs as Catalyst. Here is what Catalyst generates by converting to an ODESystem","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"osys = convert(ODESystem, repressilator)\n\n# for display purposes we just pull out the right side of the equations\nodes = [eq.rhs for eq in equations(osys)]","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"whereas our matrix-vector representation gives","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"odes2 = N * ν","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Let's check these are equal symbolically","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"isequal(odes, odes2)","category":"page"},{"location":"catalyst_functionality/network_analysis/#Reaction-complex-representation","page":"Network Analysis in Catalyst","title":"Reaction complex representation","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We now introduce a further decomposition of the RRE ODEs, which has been used to facilitate analysis of a variety of reaction network properties. Consider a simple reaction system like","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n k*A, 2*A + 3*B --> A + 2*C + D\n b, C + D --> 2*A + 3*B\nend","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can think of the first reaction as converting the reaction complex, 2A+3B to the complex A+2C+D with rate kA. Suppose we order our species the same way as Catalyst does, i.e.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"beginpmatrix\nx_1(t)\nx_2(t)\nx_3(t)\nx_4(t)\nendpmatrix =\nbeginpmatrix\nA(t)\nB(t)\nC(t)\nD(t)\nendpmatrix","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"which should be the same as","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"species(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can describe a given reaction complex by the stoichiometric coefficients of each species within the complex. For the reactions in rn these vectors would be","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"beginalign*\n2A+3B = beginpmatrix\n2\n3\n0\n0\nendpmatrix \nA+2C+D = beginpmatrix\n1\n0\n2\n1\nendpmatrix\n \nC+D = beginpmatrix\n0\n0\n1\n1\nendpmatrix\nendalign*","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Catalyst can calculate these representations as the columns of the complex stoichiometry matrix,","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Z = complexstoichmat(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"If we have C complexes, Z is a M by C matrix with Z_m c giving the stoichiometric coefficient of species m within complex c.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can use this representation to provide another representation of the RRE ODEs. The net stoichiometry matrix can be factored as N = Z B, where B is called the incidence matrix of the reaction network,","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"B = incidencemat(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Here B is a C by K matrix with B_c k = 1 if complex c appears as a product of reaction k, and B_c k = -1 if complex c is a substrate of reaction k.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Using our decomposition of N, the RRE ODEs become","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"fracdxdt = Z B mathbfv(mathbfx(t)t)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Let's verify that N = Z B,","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"N = netstoichmat(rn)\nN == Z*B","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Reaction complexes give an alternative way to visualize a reaction network graph. Catalyst's complexgraph command will calculate the complexes of a network and then show how they are related. For example,","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"gives","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: Simple example complex graph)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"while for the repressilator we find","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(repressilator)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: Repressilator complex)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Here ∅ represents the empty complex, black arrows show reactions converting substrate complexes into product complexes where the rate is just a number or parameter, and red arrows indicate the conversion of substrate complexes into product complexes where the rate is an expression involving chemical species.","category":"page"},{"location":"catalyst_functionality/network_analysis/#Aspects-of-reaction-network-structure","page":"Network Analysis in Catalyst","title":"Aspects of reaction network structure","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The reaction complex representation can be exploited via Chemical Reaction Network Theory to provide insight into possible steady state and time-dependent properties of RRE ODE models and stochastic chemical kinetics models. We'll now illustrate some of the types of network properties that Catalyst can determine, using the reaction complex representation in these calculations.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Consider the following reaction network.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n    (k1,k2), A + B <--> C\n    k3, C --> D+E\n    (k4,k5), D+E <--> F\n    (k6,k7), 2A <--> B+G\n    k8, B+G --> H\n    k9, H --> 2A\nend","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"with graph","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: network_1)","category":"page"},{"location":"catalyst_functionality/network_analysis/#Linkage-classes-and-sub-networks-of-the-reaction-network","page":"Network Analysis in Catalyst","title":"Linkage classes and sub-networks of the reaction network","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The preceding reaction complex graph shows that rn is composed of two disconnected sub-graphs, one containing the complexes A+B, C, D+E, and F, the other containing the complexes 2A, B + G, and H. These sets, A+B C D+E F and 2A B + GH are called the \"linkage classes\" of the reaction network. The function linkageclasses will calculate these for a given network, returning a vector of the integer indices of reaction complexes participating in each set of linkage-classes. Note, indices of reaction complexes can be determined from the ordering returned by reactioncomplexes.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# we must first calculate the reaction complexes -- they are cached in rn\nreactioncomplexes(rn)\n\n# now we can calculate the linkage classes\nlcs = linkageclasses(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"It can often be convenient to obtain the disconnected sub-networks as distinct ReactionSystems, which are returned by the subnetworks function:","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"subnets = subnetworks(rn)\n\n# check the reactions in each subnetwork\nreactions.(subnets)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The graphs of the reaction complexes in the two sub-networks are then","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"  complexgraph(subnets[1])","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: subnetwork_1)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"and,","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":" complexgraph(subnets[2])","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: subnetwork_2)","category":"page"},{"location":"catalyst_functionality/network_analysis/#network_analysis_deficiency","page":"Network Analysis in Catalyst","title":"Deficiency of the network","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"A famous theorem in Chemical Reaction Network Theory, the Deficiency Zero Theorem [1], allows us to use knowledge of the net stoichiometry matrix and the linkage classes of a mass action RRE ODE system to draw conclusions about the system's possible steady states. In this section we'll see how Catalyst can calculate a network's deficiency.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The rank, r, of a reaction network is defined as the dimension of the subspace spanned by the net stoichiometry vectors of the reaction-network [1], i.e. the span of the columns of the net stoichiometry matrix N. It corresponds to the number of independent species in a chemical reaction network. That is, if we calculate the linear conservation laws of a network, and use them to eliminate the dependent species of the network, we will have r independent species remaining. For our current example the conservation laws are given by","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# first we calculate the conservation laws -- they are cached in rn\nconservationlaws(rn)\n\n# then we display them as equations for the dependent variables\nconservedequations(rn)\nshow(stdout, MIME\"text/plain\"(), ans) # hide","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Here the parameters Γ[i] represent the constants of the three conservation laws, and we see that there are three dependent species that could be eliminated. As","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"numspecies(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"we find that there are five independent species. Let's check this is correct:","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"using LinearAlgebra\nrank(netstoichmat(rn)) == 5","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"So we know that the rank of our reaction network is five.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The deficiency, delta, of a reaction network is defined as","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"delta = textrm(number of complexes) - textrm(number of linkage classes) - textrm(rank)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"For our network this is 7 - 2 - 5 = 0, which we can calculate in Catalyst as","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# first we calculate the reaction complexes of rn and cache them in rn\nreactioncomplexes(rn)\n\n# then we can calculate the deficiency\nδ = deficiency(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Quoting Feinberg [1]","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Deficiency zero networks are ones for which the reaction vectors [i.e. net stoichiometry vectors] are as independent as the partition of complexes into linkage classes will allow.","category":"page"},{"location":"catalyst_functionality/network_analysis/#Reversibility-of-the-network","page":"Network Analysis in Catalyst","title":"Reversibility of the network","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"A reaction network is reversible if the \"arrows\" of the reactions are symmetric so that every reaction is accompanied by its reverse reaction. Catalyst's API provides the isreversible function to determine whether a reaction network is reversible. As an example, consider","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n  (k1,k2),A <--> B\n  (k3,k4),A + C <--> D\n  (k5,k6),D <--> B+E\n  (k7,k8),B+E <--> A+C\nend\n\n# calculate the set of reaction complexes\nreactioncomplexes(rn)\n\n# test if the system is reversible\nisreversible(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Consider another example,","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n  (k1,k2),A <--> B\n  k3, A + C --> D\n  k4, D --> B+E\n  k5, B+E --> A+C\nend\nreactioncomplexes(rn)\nisreversible(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: reversibility)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"It is evident from the preceding graph that the network is not reversible. However, it satisfies a weaker property in that there is a path from each reaction complex back to itself within its associated subgraph. This is known as weak reversiblity. One can test a network for weak reversibility by using the isweaklyreversible function:","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# need subnetworks from the reaction network first\nsubnets = subnetworks(rn)\nisweaklyreversible(rn, subnets)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Every reversible network is also weakly reversible, but not every weakly reversible network is reversible.","category":"page"},{"location":"catalyst_functionality/network_analysis/#Deficiency-Zero-Theorem","page":"Network Analysis in Catalyst","title":"Deficiency Zero Theorem","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Knowing the deficiency and weak reversibility of a mass action chemical reaction network ODE model allows us to make inferences about the corresponding steady state behavior. Before illustrating how this works for one example, we need one last definition.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Recall that in the matrix-vector representation for the RRE ODEs, the entries, N_m k, of the stoichiometry matrix, N, give the net change in species m due to reaction k. If we let mathbfN_k denote the kth column of this matrix, this vector corresponds to the change in the species state vector, mathbfx(t), due to reaction k, i.e. when reaction k occurs mathbfx(t) to mathbfx(t) + mathbfN_k. Moreover, by integrating the ODE","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"fracdmathbfxdt = N mathbfv(mathbfx(t)) = sum_k=1^K v_k(mathbfx(t))  mathbfN_k","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"we find","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"mathbfx(t) = mathbfx(0) + sum_k=1^K left(int_0^t v_k(mathbfx)(s)  dsright) mathbfN_k","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"which demonstrates that mathbfx(t) - mathbfx(0) is always given by a linear combination of the stoichiometry vectors, i.e.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"mathbfx(t) - mathbfx(0) in operatornamespanmathbfN_k ","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In particular, this says that mathbfx(t) lives in the translation of the operatornamespanmathbfN_k  by mathbfx(0) which we write as (mathbfx(0) + operatornamespanmathbfN_k). In fact, since the solution should stay non-negative, if we let barmathbbR_+^M denote the subset of vectors in mathbbR^M with non-negative components, the possible physical values for the solution, mathbfx(t), must be in the set","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(mathbfx(0) + operatornamespanmathbfN_k) cap barmathbbR_+^M","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"This set is called the stoichiometric compatibility class of mathbfx(t). The key property of stoichiometric compatibility classes is that they are invariant under the RRE ODE's dynamics, i.e. a solution will always remain within the subspace given by the stoichiometric compatibility class. Finally, we note that the positive stoichiometric compatibility class generated by mathbfx(0) is just (mathbfx(0) + operatornamespanmathbfN_k) cap mathbbR_+^M, where mathbbR_+^M denotes the vectors in mathbbR^M with strictly positive components.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"With these definitions we can now see how knowing the deficiency and weak reversibility of the network can tell us about its steady state behavior. Consider the previous example, which we know is weakly reversible. Its deficiency is","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"deficiency(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We also verify that the system is purely mass action (though it is apparent from the network's definition):","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"all(rx -> ismassaction(rx, rn), reactions(rn))","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can therefore apply the Deficiency Zero Theorem to draw conclusions about the system's steady state behavior. The Deficiency Zero Theorem (roughly) says that a mass action network with deficiency zero satisfies","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"If the network is weakly reversible, then independent of the reaction rate constants the RRE ODEs have exactly one equilibrium solution within each positive stoichiometric compatibility class. That equilibrium is locally asymptotically stable.\nIf the network is not weakly reversible, then the RRE ODEs cannot admit a positive equilibrium solution.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"See [1] for a more precise statement, proof, and additional examples.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can therefore conclude that for any initial condition that is positive, and hence in some positive stoichiometric compatibility class, rn will have exactly one equilibrium solution which will be positive and locally asymptotically stable.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"As a final example, consider the following network from [1]","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n  (k1,k2),A <--> 2B\n  (k3,k4), A + C <--> D\n  k5, B+E --> C + D\nend\nreactioncomplexes(rn)\nsubnets = subnetworks(rn)\nisma = all(rx -> ismassaction(rx,rn), reactions(rn))\ndef = deficiency(rn)\niswr = isweaklyreversible(rn, subnets)\nisma,def,iswr","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"which we see is mass action and has deficiency zero, but is not weakly reversible. As such, we can conclude that for any choice of rate constants the RRE ODEs cannot have a positive equilibrium solution.","category":"page"},{"location":"catalyst_functionality/network_analysis/#Caching-of-Network-Properties-in-ReactionSystems","page":"Network Analysis in Catalyst","title":"Caching of Network Properties in ReactionSystems","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"When calling many of the network API functions, Catalyst calculates and caches in rn a variety of information. For example the first call to","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rcs,B = reactioncomplexes(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"calculates, caches, and returns the reaction complexes, rcs, and the incidence matrix, B, of rn. Subsequent calls simply return rcs and B from the cache.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Similarly, the first call to","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"N = netstoichmat(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"calculates, caches and returns the net stoichiometry matrix. Subsequent calls then simply return the cached value of N. Caching such information means users do not need to manually know which subsets of network properties are needed for a given calculation (like the deficiency). Generally only","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rcs,B = reactioncomplexes(rn)    # must be called once to cache rcs and B\nany_other_network_property(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"should work to calculate a desired network property, with the API doc strings indicating when reactioncomplexes(rn) must be called at least once before a given function is used.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Because of the caching of network properties, subsequent calls to most API functions will be fast, simply returning the previously calculated and cached values. In some cases it may be desirable to reset the cache and recalculate these properties, for example after modifying a network (see addspecies!, addparam!, or addreaction!). This can be done by calling","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Catalyst.reset_networkproperties!(rn)","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Network property functions will then recalculate their associated properties and cache the new values the next time they are called.","category":"page"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"","category":"page"},{"location":"catalyst_functionality/network_analysis/#References","page":"Network Analysis in Catalyst","title":"References","text":"","category":"section"},{"location":"catalyst_functionality/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"[1]: Feinberg, M. Foundations of Chemical Reaction Network Theory, Applied Mathematical Sciences 202, Springer (2019).","category":"page"},{"location":"faqs/#FAQs","page":"FAQs","title":"FAQs","text":"","category":"section"},{"location":"faqs/#How-to-index-solution-objects-using-symbolic-variables-and-observables?","page":"FAQs","title":"How to index solution objects using symbolic variables and observables?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"One can directly use symbolic variables to index into SciML solution objects. Moreover, observables can also be evaluated in this way. For example, consider the system","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst, DifferentialEquations, Plots\nrn = @reaction_network ABtoC begin\n  (k₊,k₋), A + B <--> C\nend\n\n# initial condition and parameter values\nsetdefaults!(rn, [:A => 1.0, :B => 2.0, :C => 0.0, :k₊ => 1.0, :k₋ => 1.0])\nnothing    # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Let's convert it to a system of ODEs, using the conservation laws of the system to eliminate two of the species:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn; remove_conserved = true)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Notice the resulting ODE system has just one ODE, while algebraic observables have been added for the two removed species (in terms of the conservation law constants, Γ[1] and Γ[2])","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"observed(osys)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Let's solve the system and see how to index the solution using our symbolic variables","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"oprob = ODEProblem(osys, [], (0.0, 10.0), [])\nsol = solve(oprob, Tsit5())","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Suppose we want to plot just species C, without having to know its integer index in the state vector. We can do this using the symbolic variable C, which we can get at in several ways","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"sol[osys.C]","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"or","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@unpack C = osys\nsol[C]","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"To evaluate C at specific times and plot it we can just do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"t = range(0.0, 10.0, length=101)\nplot(t, sol(t, idxs = C), label = \"C(t)\", xlabel = \"t\")","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"If we want to get multiple variables we can just do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@unpack A, B = osys\nsol(t, idxs = [A, B])","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Plotting multiple variables using the SciML plot recipe can be achieved like","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"plot(sol; idxs = [A, B])","category":"page"},{"location":"faqs/#How-to-disable-rescaling-of-reaction-rates-in-rate-laws?","page":"FAQs","title":"How to disable rescaling of reaction rates in rate laws?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"As explained in the Reaction rate laws used in simulations section, for a reaction such as k, 2X --> 0, the generated rate law will rescale the rate constant, giving k*X^2/2 instead of k*X^2 for ODEs and k*X*(X-1)/2 instead of k*X*(X-1) for jumps. This can be disabled when directly converting a ReactionSystem. If rn is a generated ReactionSystem, we can do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Disabling these rescalings should work for all conversions of ReactionSystems to other ModelingToolkit.AbstractSystems.","category":"page"},{"location":"faqs/#How-to-use-non-integer-stoichiometric-coefficients?","page":"FAQs","title":"How to use non-integer stoichiometric coefficients?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nrn = @reaction_network begin\n  k, 2.5*A --> 3*B\nend","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"or directly via","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@parameters k b\n@variables t\n@species A(t) B(t) C(t) D(t)\nrx1 = Reaction(k,[B,C],[B,D], [2.5,1],[3.5, 2.5])\nrx2 = Reaction(2*k, [B], [D], [1], [2.5])\nrx3 = Reaction(2*k, [B], [D], [2.5], [2])\n@named mixedsys = ReactionSystem([rx1, rx2, rx3], t, [A, B, C, D], [k, b])\nosys = convert(ODESystem, mixedsys; combinatoric_ratelaws = false)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Note, when using convert(ODESystem, mixedsys; combinatoric_ratelaws=false) the combinatoric_ratelaws=false parameter must be passed. This is also true when calling ODEProblem(mixedsys,...; combinatoric_ratelaws=false). As described above, this disables Catalyst's standard rescaling of reaction rates when generating reaction rate laws, see also the Reaction rate laws used in simulations section. Leaving this keyword out for systems with floating point stoichiometry will give an error message.","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"For a more extensive documentation of using non-integer stoichiometric coefficients, please see the Symbolic Stochiometries section.","category":"page"},{"location":"faqs/#How-to-set-default-values-for-initial-conditions-and-parameters?","page":"FAQs","title":"How to set default values for initial conditions and parameters?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"How to set defaults when using the @reaction_network macro is described in more detail here. There are several ways to do this. Using the DSL, one can use the @species and @parameters options:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nsir = @reaction_network sir begin\n    @species S(t)=999.0 I(t)=1.0 R(t)=0.0\n    @parameters β=1e-4 ν=0.01\n    β, S + I --> 2I\n    ν, I --> R\nend\nshow(stdout, MIME\"text/plain\"(), sir) # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"When directly constructing a ReactionSystem, we can set the symbolic values to have the desired default values, and this will automatically be propagated through to the equation solvers:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst, Plots, OrdinaryDiffEq\n@parameters β=1e-4 ν=.01\n@variables t\n@species S(t)=999.0 I(t)=1.0 R(t)=0.0\nrx1 = Reaction(β, [S, I], [I], [1,1], [2])\nrx2 = Reaction(ν, [I], [R])\n@named sir = ReactionSystem([rx1, rx2], t)\noprob = ODEProblem(sir, [], (0.0, 250.0))\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"One can also build a mapping from symbolic parameter/species to value/initial condition and pass these to the ReactionSystem via the defaults keyword argument:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@parameters β ν\n@variables t\n@species S(t) I(t) R(t)\nrx1 = Reaction(β, [S,I], [I], [1,1], [2])\nrx2 = Reaction(ν, [I], [R])\ndefs = [β => 1e-4, ν => .01, S => 999.0, I => 1.0, R => 0.0]\n@named sir = ReactionSystem([rx1, rx2], t; defaults = defs)\nnothing # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Finally, default values can also be added after creating the system via the setdefaults! command and passing a Symbol based mapping, like","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"sir = @reaction_network sir begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsetdefaults!(sir, [:β => 1e-4, :ν => .01, :S => 999.0, :I => 1.0, :R => 0.0])\nnothing # hide","category":"page"},{"location":"faqs/#How-to-specify-initial-conditions-and-parameters-values-for-ODEProblem-and-other-problem-types?","page":"FAQs","title":"How to specify initial conditions and parameters values for ODEProblem and other problem types?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"To explicitly pass initial conditions and parameters we can use mappings from Julia Symbols corresponding to each variable/parameter to their values, or from ModelingToolkit symbolic variables/parameters to their values. Using Symbols we have","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst, DifferentialEquations\nrn = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend\nu0 = [:S => 999.0, :I => 1.0, :R => 0.0]\np  = (:α => 1e-4, :β => .01)\nop1  = ODEProblem(rn, u0, (0.0, 250.0), p)\nnothing  # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"while using ModelingToolkit symbolic variables we have","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@parameters α β\n@variables t\n@species S(t) I(t) R(t)\nu0 = [S => 999.0, I => 1.0, R => 0.0]\np  = (α => 1e-4, β => .01)\nop2  = ODEProblem(rn, u0, (0.0, 250.0), p)\nnothing  # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Note, while symbolic mappings as in the last example will work with any ModelingToolkit.AbstractSystem, for example if one converts rn to an ODESystem, Symbol-based mappings only work when passing a ReactionSystem directly into a problem type. That is, the following does not work","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn)\n\n# this fails\nu0 = [:S => 999.0, :I => 1.0, :R => 0.0]\np  = (:α => 1e-4, :β => .01)\nop  = ODEProblem(osys, u0, (0.0, 250.0), p)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"In this case one must either use a symbolic mapping as was used to make op2 in the second example, or one can use the symmap_to_varmap function to convert the Symbol mapping to a symbolic mapping. I.e. this works","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn)\n\n# this works\nu0 = symmap_to_varmap(rn, [:S => 999.0, :I => 1.0, :R => 0.0])\np  = symmap_to_varmap(rn, (:α => 1e-4, :β => .01))\nop  = ODEProblem(osys, u0, (0.0, 250.0), p)\nnothing # hide","category":"page"},{"location":"faqs/#How-to-include-non-reaction-terms-in-equations-for-a-chemical-species?","page":"FAQs","title":"How to include non-reaction terms in equations for a chemical species?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"One method to add non-reaction terms into an ODE or algebraic equation for a chemical species is to add a new (non-species) state variable that represents those terms, let it be the rate of zero order reaction, and add a constraint equation. I.e., to add a force of (1 + sin(t)) to dAdt in a system with the reaction k, A --> 0, we can do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\n@variables t f(t)\nrx1 = @reaction k, A --> 0\nrx2 = @reaction $f, 0 --> A\neq = f ~ (1 + sin(t))\n@named rs = ReactionSystem([rx1, rx2, eq], t)\nosys = convert(ODESystem, rs)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"In the final ODE model, f can be eliminated by using ModelingToolkit.structural_simplify","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osyss = structural_simplify(osys)\nfull_equations(osyss)","category":"page"},{"location":"faqs/#How-to-modify-generated-ODEs?","page":"FAQs","title":"How to modify generated ODEs?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Conversion to other ModelingToolkit.AbstractSystems allows the possibility to modify the system with further terms that are difficult to encode as a chemical reaction or a constraint equation. For example, an alternative method to the previous question for adding a forcing function, 1 + sin(t), to the ODE for dA/dt is","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nrn = @reaction_network begin\n    k, A --> 0\nend\nosys = convert(ODESystem, rn)\ndAdteq = equations(osys)[1]\nt      = ModelingToolkit.get_iv(osys)\ndAdteq = Equation(dAdteq.lhs, dAdteq.rhs + 1 + sin(t))\n\n# create a new ODESystem with the modified equation\n@named osys2  = ODESystem([dAdteq], t)","category":"page"},{"location":"faqs/#How-to-override-mass-action-kinetics-rate-laws?","page":"FAQs","title":"How to override mass action kinetics rate laws?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"While generally one wants the reaction rate law to use the law of mass action, so the reaction","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nrn = @reaction_network begin\n  k, X --> ∅\nend\nconvert(ODESystem, rn)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"occurs at the (ODE) rate dXdt = -kX, it is possible to override this by using any of the following non-filled arrows when declaring the reaction: <=, ⇐, ⟽, =>, ⇒, ⟾, ⇔, ⟺. This means that the reaction","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n  k, X => ∅\nend\nconvert(ODESystem, rn)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"will occur at rate dXdt = -k (which might become a problem since X will be degraded at a constant rate even when very small or equal to 0).","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Note, stoichiometric coefficients are still included, i.e. the reaction","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n  k, 2*X ⇒ ∅\nend\nconvert(ODESystem, rn)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"has rate dXdt = -2 k.","category":"page"},{"location":"faqs/#user_functions","page":"FAQs","title":"How to specify user-defined functions as reaction rates?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"The reaction network DSL can \"see\" user-defined functions that work with ModelingToolkit. e.g., this is should work","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nmyHill(x) = 2*x^3/(x^3+1.5^3)\nrn = @reaction_network begin\n  myHill(X), ∅ --> X\nend","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"In some cases, it may be necessary or desirable to register functions with Symbolics.jl before their use in Catalyst, see the discussion here.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/#nonlinear_solve","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"","category":"section"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"We have previously described how ReactionSystem steady states can be found through homotopy continuation. Catalyst also supports the creation of NonlinearProblems corresponding to ODEProblems with all left-hand side derivatives set to 0. These can be solved using the variety of nonlinear equation-solving algorithms implemented by NonlinearSolve.jl, with the solutions corresponding to system steady states. Generally, using this approach is advantageous when:","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"Only a single steady state solution is sought.\nThe nonlinear system produced by the model does not correspond to a multivariate, rational, polynomial (homotopy continuation cannot be applied to these systems). Examples include models with non-integer hill coefficients or stoichiometric constants.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"However, if all (or multiple) steady states are sought, using homotopy continuation is better.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"This tutorial describes how to create NonlinearProblems from Catalyst's ReactionSystemns, and how to solve them using NonlinearSolve. More extensive descriptions of available solvers and options can be found in NonlinearSolve's documentation.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/#Basic-example","page":"Finding Steady States using NonlinearSolve.jl","title":"Basic example","text":"","category":"section"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"Let us consider a simple dimerisation network, where a protein (P) can exist in a monomer and a dimer form. The protein is produced at a constant rate from its mRNA, which is also produced at a constant rate.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"using Catalyst\ndimer_production = @reaction_network begin\n    pₘ, 0 --> mRNA\n    pₚ, mRNA --> mRNA + P\n    (k₁, k₂), 2P <--> P₂\n    d, (mRNA, P, P₂) --> 0\nend","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"This system corresponds to the following ODE:","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"beginaligned\nfracdmRNAdt = pₘ - d cdot mRNA \nfracdPdt = pₚ cdot mRNA - k₁ cdot P + 2k₂ cdot P₂ - d cdot P \nfracdP₂dt = k₁ cdot P + 2k₂ cdot P₂ \nendaligned","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"To find its steady states we need to solve:","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"beginaligned\n0 = pₘ - d cdot mRNA \n0 = pₚ cdot mRNA - k₁ cdot P + 2k₂ cdot P₂ - d cdot P \n0 = k₁ cdot P + 2k₂ cdot P₂ \nendaligned","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"To solve this problem, we must first designate our parameter values, and also make an initial guess of the solution. Generally, for problems with a single solution (like this one), most arbitrary guesses will work fine (the exception typically being systems with conservation laws). Using these, we can create the NonlinearProblem that we wish to solve.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"p = [:pₘ => 0.5, :pₚ => 2.0, :k₁ => 5.0, :k₂ => 1.0, :d => 1.0]\nu_guess = [:mRNA => 1.0, :P => 1.0, :P₂ => 1.0]\nnl_prob = NonlinearProblem(dimer_production, u_guess, p)","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"Finally, we can solve it using the solve command, returning the steady state solution:","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"using NonlinearSolve\nsol = solve(nl_prob)","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"NonlinearSolve provides a wide range of potential solvers. If we wish to designate one, it can be supplied as a second argument to solve. Here, we use the Newton Trust Region method, and then check that the solution is equal to the previous one.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"sol_ntr = solve(nl_prob, TrustRegion())\nsol ≈ sol_ntr","category":"page"},{"location":"catalyst_applications/nonlinear_solve/#nonlinear_solve_ode_simulation_based","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding steady states through ODE simulations","text":"","category":"section"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"The NonlinearProblems generated by Catalyst corresponds to ODEs. A common method of solving these is to simulate the ODE from an initial condition until a steady state is reached. NonlinearSolve supports this through the DynamicSS method. To use it, an appropriate ODE solver (and any options you wish it to use) must also be supplied (with a large number being available). Here, we will use the Tsit5 ODE solver to find the steady states of our dimerisation system.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"using OrdinaryDiffEq, SteadyStateDiffEq\nsolve(nl_prob, DynamicSS(Tsit5()))","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"Here, we had to import OrdinaryDiffEq.jl (to use Tsit5) and SteadyStateDiffEq.jl (to use DynamicSS).","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"Like previously, the found steady state is unaffected by the initial u guess. However, when finding the steady states of systems with conservation laws it is important to select a u guess that corresponds to the initial condition for the ODE model for which a steady state is sought.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/#nonlinear_solve_conservation_laws","page":"Finding Steady States using NonlinearSolve.jl","title":"Systems with conservation laws","text":"","category":"section"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"As described in the section on homotopy continuation, when finding the steady states of systems with conservation laws, additional considerations have to be taken. E.g. consider the following two-state system:","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"using Catalyst, NonlinearSolve # hide\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"It has an infinite number of steady states. To make steady state finding possible, information of the system's conserved quantities (here C=X1+X2) must be provided. Since these can be computed from system initial conditions (u0, i.e. those provided when performing ODE simulations), designating an u0 is often the best way. There are two ways to do this. First, one can perform ODE simulation-based steady state finding, using the initial condition as the initial u guess. Alternatively, any conserved quantities can be eliminated when the NonlinearProblem is created. This feature is supported by Catalyst's conservation law finding and elimination feature.","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"To eliminate conservation laws we simply provide the remove_conserved = true argument to NonlinearProblem:","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"p = [:k1 => 2.0, :k2 => 3.0]\nu_guess = [:X1 => 3.0, :X2 => 1.0]\nnl_prob = NonlinearProblem(two_state_model, u_guess, p; remove_conserved = true)\nnothing # hide","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"here it is important that the quantities used in u_guess correspond to the conserved quantities we wish to use. E.g. here the conserved quantity X1 + X2= 30 + 10 = 4 holds for the initial condition, and will hence also hold in the calculated steady-state as well. We can now find the steady states using solve like before:","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"sol = solve(nl_prob)","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"We note that the output only provides a single value. The reason is that the actual system solved only contains a single equation (the other being eliminated with the conserved quantity). To find the values of X1 and X2 we can directly query the solution object for these species' values, using the species themselves as inputs:","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"@unpack X1, X2 = two_state_model\nsol[X1]","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"sol[X2]","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"","category":"page"},{"location":"catalyst_applications/nonlinear_solve/#nonlinear_solve_citation","page":"Finding Steady States using NonlinearSolve.jl","title":"Citations","text":"","category":"section"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"If you use this functionality in your research, in addition to Catalyst, please cite the following papers to support the authors of the NonlinearSolve.jl package:","category":"page"},{"location":"catalyst_applications/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl","title":"Finding Steady States using NonlinearSolve.jl","text":"A NonlinearSolve. jl-related publication is in preparation, once it is available, its details will be added here.","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/#chemistry_functionality","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"","category":"section"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"While Catalyst has primarily been designed around the modelling of biological systems, reaction network models are also common across chemistry. This section describes two types of functionality, that while of general interest, should be especially useful in the modelling of chemical systems.","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"The @compound option, which enables the user to designate that a specific species is composed of certain subspecies.\nThe balance_reaction function, which enables the user to balance a reaction so the same number of components occur on both sides.","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/#Modelling-with-compound-species","page":"Chemistry-related functionality","title":"Modelling with compound species","text":"","category":"section"},{"location":"catalyst_functionality/chemistry_related_functionality/#Creating-compound-species-programmatically","page":"Chemistry-related functionality","title":"Creating compound species programmatically","text":"","category":"section"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"We will first show how to create compound species through programmatic model construction, and then demonstrate using the DSL. To create a compound species, use the @compound macro, first designating the compound, followed by its components (and their stoichiometries). In this example, we will create a CO₂ molecule, consisting of one C atom and two O atoms. First, we create species corresponding to the components:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"using Catalyst\n@variables t\n@species C(t) O(t) ","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Next, we create the CO2 compound species:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound CO2 ~ C + 2O","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Here, the compound is the first argument to the macro, followed by its component (with the left-hand and right-hand sides separated by a ~ sign). While non-compound species (such as C and O) have their independent variable (in this case t) designated, independent variables are generally not designated for compounds (these are instead directly inferred from their components). Components with non-unit stoichiometries have this value written before the component (generally, the rules for designating the components of a compound are identical to those of designating the substrates or products of a reaction). The created compound, CO2, is also a species, and can be used wherever e.g. C can be used:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"isspecies(CO2)","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"In its metadata, however, is stored information of its components, which can be retrieved using the components (returning a vector of its component species) and coefficients (returning a vector with each component's stoichiometry) functions:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"components(CO2)","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"coefficients(CO2)","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Alternatively, we can retrieve the components and their stoichiometric coefficients as a single vector using the component_coefficients function:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"component_coefficients(CO2)","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Finally, it is possible to check whether a species is a compound or not using the iscompound function:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"iscompound(CO2)","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Compound components that are also compounds are allowed, e.g. we can create a carbonic acid compound (H₂CO₃) that consists of CO₂ and H₂O:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@species H(t)\n@compound H2O ~ 2H + O\n@compound H2CO3 ~ CO2 + H2O","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"When multiple compounds are created, they can be created simultaneously using the @compounds macro, e.g. the previous code-block can be re-written as:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@species H(t)\n@compounds begin\n    H2O ~ 2H + O\n    H2CO3 ~ CO2 + H2O\nend","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/#Creating-compound-species-within-the-DSL","page":"Chemistry-related functionality","title":"Creating compound species within the DSL","text":"","category":"section"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"It is also possible to declare species as compound species within the @reaction_network DSL, using the @compounds options:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rn = @reaction_network begin\n    @species C(t) H(t) O(t)\n    @compounds begin\n        C2O ~ C + 2O\n        H2O ~ 2H + O\n        H2CO3 ~ CO2 + H2O\n    end\n    (k1,k2), H2O + CO2 <--> H2CO3\nend","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"When creating compound species using the DSL, it is important to note that every component must be known to the system as a species, either by being declared using the @species or @compound options, or by appearing in a reaction. E.g. the following is not valid","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rn = @reaction_network begin``\n    @compounds begin\n        C2O ~ C + 2O\n        H2O ~ 2H + O\n        H2CO3 ~ CO2 + H2O\n    end\n    (k1,k2), H2O+ CO2 <--> H2CO3\nend","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"as the components C, H, and O are not declared as a species anywhere. Please also note that only @compounds can be used as an option in the DSL, not @compound.","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/#Designating-metadata-and-default-values-for-compounds","page":"Chemistry-related functionality","title":"Designating metadata and default values for compounds","text":"","category":"section"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Just like for normal species, it is possible to designate metadata and default values for compounds. Metadata is provided after the compound name, but separated from it by a ,:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound (CO2, [unit=\"mol\"]) ~ C + 2O","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Default values are designated using =, and provided directly after the compound name.:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound (CO2 = 2.0) ~ C + 2O","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"If both default values and meta data are provided, the metadata is provided after the default value:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound (CO2 = 2.0, [unit=\"mol\"]) ~ C + 2O","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"In all of these cases, the side to the left of the ~ must be enclosed within ().","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/#Compounds-with-multiple-independent-variables","page":"Chemistry-related functionality","title":"Compounds with multiple independent variables","text":"","category":"section"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"While we generally do not need to specify independent variables for compound, if the components (together) have more than one independent variable, this have to be done:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@variables t s\n@species N(s) O(t) \n@compound NO2(t,s) ~ N + 2O","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Here, NO2 depend both on a spatial independent variable (s) and a time one (t). This is required since, while multiple independent variables can be inferred, their internal order cannot (and must hence be provided by the user).","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/#Balancing-chemical-reactions","page":"Chemistry-related functionality","title":"Balancing chemical reactions","text":"","category":"section"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"One use of defining a species as a compound is that they can be used to balance reactions so that the number of components are the same on both sides. Catalyst provides the balance_reaction function, which takes a reaction, and returns a balanced version. E.g. let us consider a reaction when carbon dioxide is formed from carbon and oxide C + O --> CO2. Here, balance_reaction enables us to find coefficients creating a balanced reaction (in this case, where the number of carbon and oxygen atoms are the same on both sides). To demonstrate, we first created the unbalanced reactions:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rx = @reaction k, C + O --> $CO2","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Here, the reaction rate (k) is not involved in the reaction balancing. We use interpolation for CO2, ensuring that the CO2 used in the reaction is the same one we previously defined as a compound of C and O. Next, we call the balance_reaction function","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"balance_reaction(rx)","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"which correctly finds the (rather trivial) solution C + 2O --> CO2. Here we note that balance_reaction actually returns a vector. The reason is that the reaction balancing problem may have several solutions. Typically, there is only a single solution (in which case this is the vector's only element). No, or an infinite number of, solutions is also possible depending on the given reaction.","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Let us consider a more elaborate example, the reaction between ammonia (NH₃) and oxygen (O₂) to form nitrogen monoxide (NO) and water (H₂O). Let us first create the components and the unbalanced reaction:","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"using Catalyst # hide\n@variables t\n@species N(t) H(t) O(t) \n@compounds begin\n    NH3 ~ N + 3H\n    O2 ~ 2O\n    NO ~ N + O\n    H2O ~ 2H + O\nend\nunbalanced_reaction = @reaction k, $NH3 + $O2 --> $NO + $H2O","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"We can now create a balanced version (where the amount of H, N, and O is the same on both sides):","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"balanced_reaction = balance_reaction(unbalanced_reaction)[1]","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Reactions declared as a part of a ReactionSystem (e.g. using the DSL) can be retrieved for balancing using the reactions function. Please note that balancing these will not mutate the ReactionSystem, but a new reaction system will need to be created using the balanced reactions.","category":"page"},{"location":"catalyst_functionality/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"note: Note\nReaction balancing is currently not supported for reactions involving compounds of compounds.","category":"page"},{"location":"catalyst_applications/advanced_simulations/#advanced_simulations","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"","category":"section"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Throughout the preceding tutorials, we have shown the basics of how to solve ODE, SDE, and jump process models generated from Catalyst ReactionSystems. In this tutorial we'll illustrate some more advanced functionality that can be useful in many modeling contexts, and that provide conveniences for common workflows. For a comprehensive overview of solver properties, parameters, and manipulating solution objects, please read the documentation of the DifferentialEquations package, which Catalyst uses for all simulations.","category":"page"},{"location":"catalyst_applications/advanced_simulations/#advanced_simulations_ensemble_problems","page":"Advanced Simulation Options","title":"Monte Carlo simulations using EnsembleProblems","text":"","category":"section"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"In many contexts one needs to run multiple simulations of a model, for example to collect statistics of SDE or jump process solutions, or to systematically vary parameter values within a model. While it is always possible to manually run such ensembles of simulations via a for loop, DifferentialEquations.jl provides the EnsembleProblem as a convenience to manage structured collections of simulations. EnsembleProblems provide a simple interface for modifying a problem between individual simulations, and offers several options for batching and/or parallelizing simulation runs. For a more thorough description, please read the Parallel Ensemble Simulations section of the DifferentialEquations documentation. Here, we will give a brief introduction to the use of EnsembleProblems from Catalyst-generated models.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Let's look at a single-component bistable self-activation model:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"using Catalyst, DifferentialEquations, Plots\n\nrn = @reaction_network begin\n    v0 + hill(X,v,K,n), ∅ --> X\n    deg, X --> ∅\nend\nu0 = [:X => 0.0]\ntspan = (0.0,1000.0)\np = [:v0 => 0.1, :v => 2.5, :K => 75.0, :n => 2.0, :deg => 0.01];\nsprob = SDEProblem(rn, u0, tspan, p)\nnothing # hide","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"we can then use our SDEProblem as input to an EnsembleProblem:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"eprob = EnsembleProblem(sprob)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"The EnsembleProblem can now be used as input to the solve command. It has the same options as when simulating the SDEProblem directly, however, it has an additional argument trajectories to determine how many simulations should be performed.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"esol = solve(eprob; trajectories=5)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"This simulation is automatically multithreaded over all available threads. Please read this documentation for more information on parallelisation alternatives. The ensemble simulations can be plotted using the plot function, which by default displays all trajectories:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"plot(esol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Sometimes when performing a large number of ensemble simulations, the plots get very dense. In these cases, the plot argument linealpha (which sets trajectory transparency) may be useful:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"esol = solve(eprob; trajectories = 100)\nplot(esol; linealpha = 0.5)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Sometimes, one wishes to perform the same simulation a large number of times, while making minor modifications to the problem each time. This can be done by giving a problem function, prob_func, argument to the EnsembleProblem. Let us consider ODE simulations of a simple birth/death process:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"rn = @reaction_network begin\n    (b,1.0), ∅ <--> X\nend\nu0 = [:X => 1.0]\ntspan = (0.0, 1.0)\np = [:b => 1.];\noprob = ODEProblem(rn, u0, tspan, p)\nnothing # hide","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"We wish to simulate this model for a large number of values of b. We do this by creating a prob_func that will make a modification to the problem at the start of each Monte Carlo simulation:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"b_values = 1.0:0.1:2.0\nfunction prob_func(prob, i, repeat)\n    @unpack b = prob.f.sys    # Fetches the b parameter to be used in the local scope.\n    remake(prob; p = [b => b_values[i]])\nend\nnothing # hide","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Here, prob_func takes three arguments:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"prob: The problem given to our EnsembleProblem, this is the problem that prob_func modifies in each iteration.\ni: The number of this specific Monte Carlo iteration in the interval 1:trajectories.\nrepeat: The repeat of this specific Monte Carlo simulation (We will ignore","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"this argument in this brief overview). In our case, for each Monte Carlo simulation, our prob_func takes our original ODEProblem and uses the remake function to change the parameter vector. Here, for the ith Monte Carlo simulation, the value of b is also the ith value of our b_values vector. Finally, we can simulate and plot our problem:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"eprob = EnsembleProblem(oprob; prob_func = prob_func)\nesol = solve(eprob; trajectories = length(b_values))\nplot(esol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Note that plot legends are disabled when plotting ensemble solutions. These can be re-enabled using the legend plotting keyword. However, when plotting a large number of trajectories, each will generate a label. Sometimes the best approach is to remove these and add a label manually:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"p = plot(esol; label = nothing)\nplot!(p, Float64[], Float64[]; label = \"X\", legend = :topleft)","category":"page"},{"location":"catalyst_applications/advanced_simulations/#advanced_simulations_callbacks","page":"Advanced Simulation Options","title":"Event handling using callbacks","text":"","category":"section"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Sometimes one wishes to add discrete events during simulations. Examples could include:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"A chemical system where an amount of some species is added at a time point after the simulation's initiation.\nA simulation of a circadian rhythm, where light is turned on/off every 12 hours.\nA cell divides when some size variable reaches a certain threshold, randomly allocating all species to two daughter cells.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"In simple cases events such as these can be modelled symbolically, as described in the Constraint Equations and Events tutorial. A more flexible, but low-level, interface is also available via the callback functionality of DifferentialEquations.jl. A callback is a function that is passed to the solve() command, combing an affect! function (defining how the callback changes the system) with a condition function (a condition for triggering a callback). For a thorough introduction, please read the section about callbacks in the DifferentialEquations.jl documentation.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"There exist three types of callbacks, PresetTimeCallbacks DiscreteCallbacks, and ContinuousCallbacks. Here, we will limit ourselves to introducing the PresetTimeCallback. For our example, we are going to use a simple network where a single component, X, degrades linearly.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"using Catalyst\ndegradation_model = @reaction_network begin\n    d, X --> 0\nend\nnothing # hide","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"we can simulate the model without using a callback:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"using DifferentialEquations, Plots\nu0 = [:X => 10.0]\ntspan = (0.0, 10.0)\np = [:d => 1.0]\n\noprob = ODEProblem(degradation_model, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"We now wish to modify our simulation so that at the times t = 3.0 and t = 7.0 we add 5 units of X to the system. For this we create a PresetTimeCallback:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"condition = [3.0, 7.0]\nfunction affect!(integrator)\n    integrator[:X] += 5.0\nend\nps_cb = PresetTimeCallback(condition, affect!)\nnothing # hide","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Here, condition is simply a vector with all the time points during which we want the callback to trigger. The affect! function determines what happens to the simulation when the callback is triggered. It takes a single object, an integrator and makes some modification to it (please read more about integrators here). Here, we access the system's state X through the integrator, and add 5.0 to its amount. We can now simulate our system using the callback:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"sol = solve(oprob; callback = ps_cb)\nplot(sol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Next, we can also use a callback to change the parameters of a system. The following code plots the concentration of a two-state system, as we change the equilibrium constant between the two states:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"rn = @reaction_network begin\n    (k,1), X1 <--> X2\nend\nu0 = [:X1 => 10.0, :X2 => 0.0]\ntspan = (0.0, 20.0)\np = [:k => 1.0]\noprob = ODEProblem(rn, u0, tspan, p)\n\ncondition = [5.0]\naffect!(integrator) = integrator[:k] = 5.0\nps_cb = PresetTimeCallback(condition, affect!)\n\nsol = solve(oprob; callback = ps_cb)\nplot(sol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"The result looks as expected. However, what happens if we attempt to run the simulation again?","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"sol = solve(oprob; callback = ps_cb)\nplot(sol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"The plot looks different, even though we simulate the same problem. Furthermore, the callback does not seem to have any effect on the system. If we check our ODEProblem","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"oprob.p","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"we note that k = 5.0, rather than k = 1.0 as we initially specified. This is because the callback modifies our ODEProblem during the simulation, and this modification remains during the second simulation. An improved workflow to avoid this issue is:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"rn = @reaction_network begin\n    (k,1), X1 <--> X2\nend\nu0 = [:X1 => 10.0,:X2 => 0.0]\ntspan = (0.0, 20.0)\np = [:k => 1.0]\noprob = ODEProblem(rn, u0, tspan, p)\n\ncondition = [5.0]\naffect!(integrator) = integrator[:k] = 5.0\nps_cb = PresetTimeCallback(condition, affect!)\n\nsol = solve(deepcopy(oprob); callback = ps_cb)\nplot(sol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"where we parse a copy of our ODEProblem to the solver (using deepcopy). We can now run","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"sol = solve(deepcopy(oprob); callback = ps_cb)\nplot(sol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"and get the expected result.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"It is possible to give several callbacks to the solve() command. To do so, one has to bundle them together in a CallbackSet, here follows one example:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"rn = @reaction_network begin\n    (k,1), X1 <--> X2\nend\nu0 = [:X1 => 10.0,:X2 => 0.0]\ntspan = (0.0, 20.0)\np = [:k => 1.0]\noprob = ODEProblem(rn, u0, tspan, p)\n\nps_cb_1 = PresetTimeCallback([3.0, 7.0], integ -> integ[:X1] += 5.0)\nps_cb_2 = PresetTimeCallback([5.0], integ -> integ[:k] = 5.0)\n\nsol = solve(deepcopy(oprob); callback=CallbackSet(ps_cb_1, ps_cb_2))\nplot(sol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"The difference between the PresetTimeCallbacks and the DiscreteCallbacks and ContiniousCallbacks is that the latter two allow the condition to be a function, permitting the user to give more general conditions for the callback to be triggered. An example could be a callback that triggers whenever a species surpasses some threshold value.","category":"page"},{"location":"catalyst_applications/advanced_simulations/#advanced_simulations_ssa_callbacks","page":"Advanced Simulation Options","title":"Callbacks during SSA simulations","text":"","category":"section"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"An assumption of (most) SSA simulations is that the state of the system is unchanged between reaction events. However, callbacks that affect the system's state can violate this assumption. To prevent erroneous simulations, users must inform a SSA solver when the state has been updated in a callback. This allows the solver to reinitialize any internal state information that may have changed. This can be done through the reset_aggregated_jumps! function, see the following example:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"rn = @reaction_network begin\n    (k,1), X1 <--> X2\nend\nu0 = [:X1 => 10.0,:X2 => 0.0]\ntspan = (0.0, 20.0)\np = [:k => 1.0]\ndprob = DiscreteProblem(rn, u0, tspan, p)\njprob = JumpProblem(rn, dprob, Direct())\n\ncondition = [5.0]\nfunction affect!(integrator)\n    integrator[:X1] += 5.0\n    integrator[:k] += 2.0\n    reset_aggregated_jumps!(integrator)\n    nothing\nend\ncb = PresetTimeCallback(condition, affect!)\n\nsol = solve(deepcopy(jprob), SSAStepper(); callback=cb)\nplot(sol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/#Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations","page":"Advanced Simulation Options","title":"Scaling the noise magnitude in the chemical Langevin equations","text":"","category":"section"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"When using the CLE to generate SDEs from a CRN, it can sometimes be desirable to scale the magnitude of the noise terms. Here, each reaction of the system generates a separate noise term in the CLE. If you require identical scaling for all reaction, the @default_noise_scaling option can be used. Else, you can supply a noise_scaling metadata for each individual reaction, describing how to scale the noise for that reaction.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"We begin with considering the first approach. First, we simulate a simple two-state CRN model using the CLE:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"using Catalyst, StochasticDiffEq, Plots\n\nrn_1 = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\nu0 = [:X1 => 10.0, :X2 => 10.0]\ntspan = (0.0, 10.0)\np_1 = [:k1 => 1.0, :k2 => 1.0]\n\nsprob_1 = SDEProblem(rn_1, u0, tspan, p_1)\nsol_1 = solve(sprob_1, ImplicitEM())\nplot(sol_1; idxs = :X1, ylimit = (0.0, 20.0))","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Here we can see that the X concentration fluctuates around a steady state of X100.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Next, we wish increase the amount of noise with by a factor 2. To do so, we use the @default_noise_scaling option, to which we provide the desired scaling ","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"rn_2 = @reaction_network begin\n    @default_noise_scaling 2\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"If we re-simualte the system we see that the amount of noise have increased:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"sprob_1 = SDEProblem(rn_2, u0, tspan, p_1)\nsol_1 = solve(sprob_1, ImplicitEM())\nplot(sol_1; idxs = :X1, ylimit = (0.0, 20.0))","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"It is possible to scale the amount of noise using any expression. A common use of this is to set a parameter which determines the amount of noise. Here we create a parameter η, and uses its value to scale the noise.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"using Catalyst, StochasticDiffEq, Plots\n\nrn_3 = @reaction_network begin\n    @parameters η\n    @default_noise_scaling η\n    (k1,k2), X1 <--> X2\nend\nu0 = [:X1 => 10.0, :X2 => 10.0]\ntspan = (0.0, 10.0)\np_3 = [:k1 => 1.0, :k2 => 1.0, :η => 0.2]\n\nsprob_3 = SDEProblem(rn_3, u0, tspan, p_3)\nsol_3 = solve(sprob_3, ImplicitEM())\nplot(sol_3; idxs = :X1, ylimit = (0.0, 20.0))","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Here we saw how, by setting a small η value, the amount of noise was reduced.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"It is possible to use a different noise scaling expression for each reaction. Here, each reaction's noise scaling expression is provided using the noise_scaling metadata. In the following example, we use this to turn the noise of for both reactions involving the species Y.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"rn_4 = @reaction_network begin\n    (p, d), 0 <--> X\n    (p, d), 0 <--> Y, ([noise_scaling=0.0, noise_scaling=0.0])\nend\n\nu0_4 = [:X => 10.0, :Y => 10.0]\ntspan = (0.0, 10.0)\np_4 = [p => 10.0, d => 1.]\n\nsprob_4 = SDEProblem(rn_4, u0_4, tspan, p_4)\nsol_4 = solve(sprob_4, ImplicitEM())\nplot(sol_4; ylimit = (0.0, 20.0))","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Here, we not that there is n fluctuation in the value of Y. If the @default_noise_scaling option is used, its value is used for all reactions for which the noise_scaling metadata is unused. If @default_noise_scaling is not used, teh default noise scaling value is 1.0.","category":"page"},{"location":"catalyst_applications/advanced_simulations/#Useful-plotting-options","page":"Advanced Simulation Options","title":"Useful plotting options","text":"","category":"section"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Catalyst, just like DifferentialEquations, uses the Plots package for all plotting. For a detailed description of differential equation plotting, see DifferentialEquations documentation on the subject. Furthermore, the Plots package documentation contains additional information and describes a large number of plotting options. Here follows a very short tutorial with a few useful options.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Let us consider the Brusselator model:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"using Catalyst, DifferentialEquations, Plots\n\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\nu0 = [:X => 1.0, :Y => 0.0]\ntspan = (0.0, 50.0)\np = [:A => 1.0, :B => 4.0]\n\noprob = ODEProblem(brusselator, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"If we want to plot only the X species, we can use the idxs command:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"plot(sol; idxs = [:X])","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"If we wish to plot a single species (such as we do in this case), vector notation is not required and we could simply write plot(sol; idxs=:X).","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"Next, if we wish to plot a solution in phase space (instead of across time) we again use the idxs notation, but use () instead of [] when designating the species we wish to plot. Here, we plot the solution in (X,Y) space:","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"plot(sol; idxs=(:X, :Y))","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"","category":"page"},{"location":"catalyst_applications/advanced_simulations/#References","page":"Advanced Simulation Options","title":"References","text":"","category":"section"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"[1]: DifferentialEquations.jl online documentation.","category":"page"},{"location":"catalyst_applications/advanced_simulations/","page":"Advanced Simulation Options","title":"Advanced Simulation Options","text":"[2]: Chris Rackauckas, Qing Nie, DifferentialEquations.jl – A Performant and Feature-Rich Ecosystem for Solving Differential Equations in Julia, Journal of Open Resource Software (2017).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Fitting parameters to data involves solving an optimisation problem (that is, finding the parameter set that optimally fits your model to your data, typically by minimising a cost function). The SciML ecosystem's primary package for solving optimisation problems is Optimization.jl. It provides access to a variety of solvers via a single common interface by wrapping a large number of optimisation libraries that have been implemented in Julia.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"This tutorial demonstrates both how to create parameter fitting cost functions using the DiffEqParamEstim.jl package, and how to use Optimization.jl to minimise these. Optimization.jl can also be used in other contexts, such as finding parameter sets that maximise the magnitude of some system behaviour. More details on how to use these packages can be found in their respective documentations.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#Basic-example","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Basic example","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Let us consider a simple catalysis network, where an enzyme (E) turns a substrate (S) into a product (P):","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"using Catalyst\nrn = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"From some known initial condition, and a true parameter set (which we later want to recover from the data) we generate synthetic data (on which we will demonstrate the fitting process).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"# Define initial conditions and parameters.\nu0 = [:S => 1.0, :E => 1.0, :SE => 0.0, :P => 0.0]\np_true = [:kB => 1.0, :kD => 0.1, :kP => 0.5]\n\n# Generate synthetic data.\nusing OrdinaryDiffEq\noprob_true = ODEProblem(rn, u0, (0.0, 10.0), p_true)\ntrue_sol = solve(oprob_true, Tsit5())\ndata_sol = solve(oprob_true, Tsit5(); saveat=1.0)\ndata_ts = data_sol.t[2:end]\ndata_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\n# Plots the true solutions and the (synthetic data) measurements.\nusing Plots\nplot(true_sol; idxs=:P, label=\"True solution\", lw=8)\nplot!(data_ts, data_vals; label=\"Measurements\", seriestype=:scatter, ms=6, color=:blue)","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Next, we will use DiffEqParamEstim to build a loss function to measure how well our model's solutions fit the data.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"using DiffEqParamEstim, Optimization\np_dummy = [:kB => 0.0, :kD => 0.0, :kP => 0.0]\noprob = ODEProblem(rn, u0, (0.0, 10.0), p_dummy)\nloss_function = build_loss_objective(oprob, Tsit5(), L2Loss(data_ts, data_vals), Optimization.AutoForwardDiff(); \n    maxiters=10000, verbose=false, save_idxs=4)\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"To build_loss_objective we provide the following arguments:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"oprob: The ODEProblem with which we simulate our model (using some dummy parameter values, since we do not know these).\nTsit5(): The numeric integrator we wish to simulate our model with.\nL2Loss(data_ts, data_vals): Defines the loss function. While other alternatives are available, L2Loss is the simplest one (measuring the sum of squared distances between model simulations and data measurements). Its first argument is the time points at which the data is collected, and the second is the data's values.\nOptimization.AutoForwardDiff(): Our choice of automatic differentiation framework.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Furthermore, we can pass any number of additional optional arguments, these are then passed to the internal solve() function (which is used to solve our ODE). Here we provide the following additional arguments:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"maxiters=10000: If the ODE integrator takes a very large number of steps, that can be a sign of a very poor fit (or stiffness in the ODEs, but that is not a concern for our current example). Reducing the maxiters threshold reduces the time we waste on evaluating such models. \nverbose=false: The simulation of models with highly unsuitable parameter sets typically generate various warnings (such as premature simulation termination due to reaching maxiters timesteps). To avoid an overflow of such (here unnecessary) warnings, as we evaluate a large number of parameter sets, we turn warnings off.\nsave_idxs=4: The measured species (P) is the 4th species in our species vector (species(rn)). Since we only assume data is available for P(t) there is no reason to save any other species.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Now we can create an OptimizationProblem using our loss_function and some initial guess of parameter values from which the optimiser will start:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"optprob = OptimizationProblem(loss_function, [1.0, 1.0, 1.0])\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"note: Note\nOptimizationProblem cannot currently accept parameter values in the form of a map (e.g. [:kB => 1.0, :kD => 1.0, :kP => 1.0]). These must be provided as individual values (using the same order as the parameters occur in in the parameters(rs) vector). Similarly, build_loss_objective's save_idxs uses the species' indexes, rather than the species directly. These inconsistencies should be remedied in future DiffEqParamEstim releases.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Finally, we can optimise optprob to find the parameter set that best fits our data. Optimization.jl only provides a few optimisation methods natively. However, for each supported optimisation package, it provides a corresponding wrapper-package to import that optimisation package for use with Optimization.jl. E.g., if we wish to use Optim.jl's Nelder-Mead method, we must install and import the OptimizationOptimJL package. A summary of all, by Optimization.jl, supported optimisation packages can be found here. Here, we import the Optim.jl package and uses it to minimise our cost function (thus finding a parameter set that fits the data):","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"using OptimizationOptimJL\noptsol = solve(optprob, Optim.NelderMead())\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"We can now simulate our model for the corresponding parameter set, checking that it fits our data.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"oprob_fitted = remake(oprob; p=optsol.u)\nfitted_sol = solve(oprob_fitted, Tsit5())\nplot!(fitted_sol; idxs=:P, label=\"Fitted solution\", linestyle=:dash, lw=6, color=:lightblue)","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"note: Note\nHere, a good exercise is to check the resulting parameter set and note that, while it creates a good fit to the data, it does not actually correspond to the original parameter set. Identifiability is a concept that studies how to deal with this problem.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Say that we instead would like to use the Broyden–Fletcher–Goldfarb–Shannon algorithm, as implemented by the NLopt.jl package. In this case we would run:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"using OptimizationNLopt\nsol = solve(optprob, NLopt.LD_LBFGS())\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#Optimisation-problems-with-data-for-multiple-species","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Optimisation problems with data for multiple species","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Imagine that, in our previous example, we had measurements of the concentration of both S and P:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"data_vals_S = (0.8 .+ 0.4*rand(10)) .* data_sol[:S][2:end]\ndata_vals_P = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\nplot(true_sol; idxs=[:S, :P], label=[\"True S\" \"True P\"], lw=8)\nplot!(data_ts, data_vals_S; label=\"Measured S\", seriestype=:scatter, ms=6, color=:blue)\nplot!(data_ts, data_vals_P; label=\"Measured P\", seriestype=:scatter, ms=6, color=:red)","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"In this case we would have to use the L2Loss(data_ts, hcat(data_vals_S, data_vals_P)) and save_idxs=[1,4] arguments in loss_function:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"loss_function_S_P = build_loss_objective(oprob, Tsit5(), L2Loss(data_ts, Array(hcat(data_vals_S, data_vals_P)')), Optimization.AutoForwardDiff(); maxiters=10000, verbose=false, save_idxs=[1,4])\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Here, Array(hcat(data_vals_S, data_vals_P)') is required to put the data in the right form (in this case, a 2x10 matrix).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"We can now fit our model to data and plot the results:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"optprob_S_P = OptimizationProblem(loss_function_S_P, [1.0,1.0, 1.0])\noptsol_S_P = solve(optprob_S_P, Optim.NelderMead())\noprob_fitted_S_P = remake(oprob; p=optsol_S_P.u)\nfitted_sol_S_P = solve(oprob_fitted_S_P, Tsit5())\nplot!(fitted_sol_S_P; idxs=[:S, :P], label=\"Fitted solution\", linestyle=:dash, lw=6, color=[:lightblue :pink])","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#Setting-parameter-constraints-and-boundaries","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Setting parameter constraints and boundaries","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Sometimes, it is desired to set boundaries on parameter values. Indeed, this can speed up the optimisation process (by preventing searching through unfeasible parts of parameter space), and can also be a requirement for some optimisation methods. This can be done by passing the lb (lower bounds) and up (upper bounds) arguments to OptimizationProblem. These are vectors (of the same length as the number of parameters), with each argument corresponding to the boundary value of the parameter with the same index (as used in the parameters(rn) vector). If we wish to constrain each parameter to the interval (01 100) this can be done through:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"optprob = OptimizationProblem(loss_function, [1.0, 1.0, 1.0]; lb = [0.1, 0.1, 0.1], ub = [10.0, 10.0, 10.0])\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"In addition to boundaries, Optimization.jl also supports setting linear and non-linear constraints on its output solution for some optimizers.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#Parameter-fitting-with-known-parameters","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter fitting with known parameters","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"If we from previous knowledge know that kD = 01, and only want to fit the values of kB and kP, this can be achieved through build_loss_objective's prob_generator argument. First, we create a function (fixed_p_prob_generator) that modifies our ODEProblem to incorporate this knowledge:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"fixed_p_prob_generator(prob, p) = remake(prob; p = vcat(p[1], 0.1, p[2]))\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Here, it takes the ODEProblem (prob) we simulate, and the parameter set used, during the optimisation process (p), and creates a modified ODEProblem (by setting a customised parameter vector using remake). Now we create our modified loss function:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"loss_function_fixed_kD = build_loss_objective(oprob, Tsit5(), L2Loss(data_ts, data_vals), Optimization.AutoForwardDiff(); prob_generator = fixed_p_prob_generator, maxiters=10000, verbose=false, save_idxs=4)\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"We can create an OptimizationProblem from this one like previously, but keep in mind that it (and its output results) only contains two parameter values (k* and kP):","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"optprob_fixed_kD = OptimizationProblem(loss_function_fixed_kD, [1.0, 1.0])\noptsol_fixed_kD = solve(optprob_fixed_kD, Optim.NelderMead())\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#Fitting-parameters-on-the-logarithmic-scale","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Fitting parameters on the logarithmic scale","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Often it can be advantageous to fit parameters on a logarithmic, rather than linear, scale. The best way to proceed is to simply replace each parameter in the model definition by its logarithmic version:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"using Catalyst\nrn = @reaction_network begin\n    10^kB, S + E --> SE\n    10^kD, SE --> S + E\n    10^kP, SE --> P + E\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"And then proceeding, by keeping in mind that parameter values are logarithmic. Here, setting","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"p_true = [:kB => 0.0, :kD => -1.0, :kP => 10^(0.5)]\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"corresponds to the same true parameter values as used previously ([:kB => 1.0, :kD => 0.1, :kP => 0.5]).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#Parameter-fitting-to-multiple-experiments","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter fitting to multiple experiments","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Say that we had measured our model for several different initial conditions, and would like to fit our model to all these measurements simultaneously. This can be done by first creating a corresponding EnsembleProblem. How to then create loss functions for these are described in more detail here.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#Optimisation-solver-options","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Optimisation solver options","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"Optimization.jl supports various optimisation solver options that can be supplied to the solve command. For example, to set a maximum number of seconds (after which the optimisation process is terminated), you can use the maxtime argument:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"optsol_fixed_kD = solve(optprob, Optim.NelderMead(); maxtime=100)\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#References","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"References","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl","text":"[1]: Alejandro F. Villaverde, Dilan Pathirana, Fabian Fröhlich, Jan Hasenauer, Julio R. Banga, A protocol for dynamic model calibration, Briefings in Bioinformatics (2023).","category":"page"},{"location":"catalyst_applications/homotopy_continuation/#homotopy_continuation","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"","category":"section"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"The steady states of a dynamical system dx over dt = f(x) can be found by solving 0 = f(x). This is typically a hard problem, and generally, there is no method guaranteed to find all steady states for a system that has multiple ones. However, many chemical reaction networks generate polynomial systems (for example those which are purely mass action or have only have Hill functions with integer Hill exponents). The roots of these can reliably be found through a homotopy continuation algorithm. This is implemented in Julia through the HomotopyContinuation.jl package.","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Catalyst contains a special homotopy continuation extension that is loaded whenever HomotopyContinuation.jl is. This exports a single function, hc_steady_states, that can be used to find the steady states of any ReactionSystem structure.","category":"page"},{"location":"catalyst_applications/homotopy_continuation/#Basic-example","page":"Finding Steady States through Homotopy Continuation","title":"Basic example","text":"","category":"section"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"For this tutorial, we will use a model from Wilhelm (2009)[1] (which demonstrates bistability in a small chemical reaction network). We declare the model and the parameter set for which we want to find the steady states:","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"using Catalyst\r\nimport HomotopyContinuation\r\n\r\nwilhelm_2009_model = @reaction_network begin\r\n    k1, Y --> 2X\r\n    k2, 2X --> X + Y\r\n    k3, X + Y --> Y\r\n    k4, X --> 0\r\nend\r\nps = [:k1 => 8.0, :k2 => 2.0, :k3 => 1.0, :k4 => 1.5]\r\nnothing   # hide","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Here, we only run import HomotopyContinuation as we do not require any of its functions, and just need it to be present in the current scope for the extension to be activated.","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Now we can find the steady states using:","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"hc_steady_states(wilhelm_2009_model, ps)","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"The order of the species in the output vectors are the same as in species(wilhelm_2009_model).","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"It should be noted that the steady state multivariate polynomials produced by reaction systems may have both imaginary and negative roots, which are filtered away by hc_steady_states. If you want the negative roots, you can use the hc_steady_states(wilhelm_2009_model, ps; filter_negative=false) argument.","category":"page"},{"location":"catalyst_applications/homotopy_continuation/#homotopy_continuation_conservation_laws","page":"Finding Steady States through Homotopy Continuation","title":"Systems with conservation laws","text":"","category":"section"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Some systems are under-determined, and have an infinite number of possible steady states. These are typically systems containing a conservation law, e.g.","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"using Catalyst\r\nimport HomotopyContinuation\r\n\r\ntwo_state_model = @reaction_network begin\r\n    (k1,k2), X1 <--> X2\r\nend","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Catalyst allows the conservation laws of such systems to be computed using the conservationlaws function. By using these to reduce the dimensionality of the system, as well specifying the initial amount of each species, HomotopyContinuation can again be used to find steady states. To find the steady states using the Catalyst interface to HomotopyContinuation, an initial condition must be provided (which is used to compute the system's conserved quantities, in this case X1+X2):","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"ps = [:k1 => 2.0, :k2 => 1.0]\r\nu0 = [:X1 => 1.0, :X2 => 1.0]\r\nhc_steady_states(two_state_model, ps; u0)","category":"page"},{"location":"catalyst_applications/homotopy_continuation/#Final-notes","page":"Finding Steady States through Homotopy Continuation","title":"Final notes","text":"","category":"section"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"hc_steady_states supports any systems where all rates are systems of rational polynomials (such as Hill functions with integer Hill coefficients).\nWhen providing initial conditions to compute conservation laws, values are only required for those species that are part of conserved quantities. If this set of species is unknown, it is recommended to provide initial conditions for all species. \nAdditional arguments provided to hc_steady_states are automatically passed to HomotopyContinuation's solve command. Use e.g. show_progress=false to disable the progress bar.","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"","category":"page"},{"location":"catalyst_applications/homotopy_continuation/#homotopy_continuation_citation","page":"Finding Steady States through Homotopy Continuation","title":"Citation","text":"","category":"section"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"If you use this functionality in your research, please cite the following paper to support the authors of the HomotopyContinuation package:","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"@inproceedings{HomotopyContinuation.jl,\r\n  title={{H}omotopy{C}ontinuation.jl: {A} {P}ackage for {H}omotopy {C}ontinuation in {J}ulia},\r\n  author={Breiding, Paul and Timme, Sascha},\r\n  booktitle={International Congress on Mathematical Software},\r\n  pages={458--465},\r\n  year={2018},\r\n  organization={Springer}\r\n}","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"","category":"page"},{"location":"catalyst_applications/homotopy_continuation/#References","page":"Finding Steady States through Homotopy Continuation","title":"References","text":"","category":"section"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"[1]: Thomas Wilhelm, The smallest chemical reaction system with bistability, BMC Systems Biology (2009).","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"[2]: Paul Breiding, Sascha Timme, HomotopyContinuation.jl: A Package for Homotopy Continuation in Julia, International Congress on Mathematical Software (2018).","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"[3]: Andrew J Sommese, Charles W Wampler The Numerical Solution of Systems of Polynomials Arising in Engineering and Science, World Scientific (2005).","category":"page"},{"location":"catalyst_applications/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"[4]: Daniel J. Bates, Paul Breiding, Tianran Chen, Jonathan D. Hauenstein, Anton Leykin, Frank Sottile, Numerical Nonlinear Algebra, arXiv (2023).","category":"page"},{"location":"catalyst_functionality/example_networks/basic_CRN_examples/#basic_CRN_examples","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"","category":"section"},{"location":"catalyst_functionality/example_networks/basic_CRN_examples/#Example:-Birth-death-process","page":"Basic Chemical Reaction Network Examples","title":"Example: Birth-death process","text":"","category":"section"},{"location":"catalyst_functionality/example_networks/basic_CRN_examples/","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"using Catalyst, DifferentialEquations, Plots\n\nrs = @reaction_network begin\n  c1, X --> 2X\n  c2, X --> 0\n  c3, 0 --> X\nend\np = (:c1 => 1.0, :c2 => 2.0, :c3 => 50.)\ntspan = (0.,4.)\nu0 = [:X => 5.]\n\n# solve ODEs\noprob = ODEProblem(rs, u0, tspan, p)\nosol  = solve(oprob, Tsit5())\n\n# solve for Steady states\nssprob = SteadyStateProblem(rs, u0, p)\nsssol  = solve(ssprob, SSRootfind())\n\n# solve SDEs\nsprob = SDEProblem(rs, u0, tspan, p)\nssol  = solve(sprob, EM(), dt=.01)\n\n# solve JumpProblem\nu0 = [:X => 5]\ndprob = DiscreteProblem(rs, u0, tspan, p)\njprob = JumpProblem(rs, dprob, Direct())\njsol = solve(jprob, SSAStepper())\n\nplot(plot(osol; title = \"Reaction Rate Equation ODEs\"),\n     plot(ssol; title = \"Chemical Langevin SDEs\"),\n     plot(jsol; title = \"Stochastic Chemical Kinetics Jump Processes\");\n     layout = (3, 1))","category":"page"},{"location":"catalyst_functionality/example_networks/basic_CRN_examples/#Example:-Michaelis-Menten-enzyme-kinetics","page":"Basic Chemical Reaction Network Examples","title":"Example: Michaelis-Menten enzyme kinetics","text":"","category":"section"},{"location":"catalyst_functionality/example_networks/basic_CRN_examples/","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"using Catalyst, DifferentialEquations, Plots\n\nrs = @reaction_network begin\n  c1, S + E --> SE\n  c2, SE --> S + E\n  c3, SE --> P + E\nend\np = (:c1 => 0.00166, :c2 => 0.0001, :c3 => 0.1)\ntspan = (0., 100.)\nu0 = [:S => 301., :E => 100., :SE => 0., :P => 0.]\n\n# solve ODEs\noprob = ODEProblem(rs, u0, tspan, p)\nosol  = solve(oprob, Tsit5())\n\n# solve JumpProblem\nu0 = [:S => 301, :E => 100, :SE => 0, :P => 0]\ndprob = DiscreteProblem(rs, u0, tspan, p)\njprob = JumpProblem(rs, dprob, Direct())\njsol = solve(jprob, SSAStepper())\n\nplot(plot(osol; title = \"Reaction Rate Equation ODEs\"),\n     plot(jsol; title = \"Stochastic Chemical Kinetics Jump Processes\");\n     layout = (2, 1))","category":"page"},{"location":"catalyst_functionality/example_networks/basic_CRN_examples/#Example:-SIR-infection-model","page":"Basic Chemical Reaction Network Examples","title":"Example: SIR infection model","text":"","category":"section"},{"location":"catalyst_functionality/example_networks/basic_CRN_examples/","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"using Catalyst, DifferentialEquations, Plots\n\nrs = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend\np = [:α => .1/100, :β => .01]\ntspan = (0.0,500.0)\nu0 = [:S => 99.0, :I => 1.0, :R => 0.0]\n\n# Solve ODEs.\noprob = ODEProblem(rs, u0, tspan, p)\nosol = solve(oprob)\n\n# Solve Jumps.\ndprob = DiscreteProblem(rs, u0, tspan, p)\njprob = JumpProblem(rs, dprob, Direct())\njsol = solve(jprob, SSAStepper())\n\nplot(plot(osol; title = \"Reaction Rate Equation ODEs\"),\n     plot(jsol; title = \"Stochastic Chemical Kinetics Jump Processes\");\n     layout = (2, 1))","category":"page"},{"location":"catalyst_functionality/example_networks/basic_CRN_examples/#Example:-Brusselator-chemical-reaction-network","page":"Basic Chemical Reaction Network Examples","title":"Example: Brusselator chemical reaction network","text":"","category":"section"},{"location":"catalyst_functionality/example_networks/basic_CRN_examples/","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"using Catalyst, DifferentialEquations, Plots\n\nrs = @reaction_network begin\n    @parameters A B\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\ntspan = (0.0,50.0)\nu0 = [:X => 1.0, :Y => 1.0]\n\n# Non-oscillation parameter set\noprob1 = ODEProblem(rs, u0, tspan, [:A => 1.0, :B => 1.0])\nosol1 = solve(oprob1)\n\n# Oscillation parameter set\noprob2 = ODEProblem(rs, u0, tspan, [:A => 1.0, :B => 3.0])\nosol2 = solve(oprob2)\n\nplot(plot(osol1; title = \"No oscillation (B < 1 + A^2)\"),\n     plot(osol2; title = \"Oscillation (B > 1 + A^2)\");\n     layout = (2, 1))","category":"page"},{"location":"catalyst_functionality/constraint_equations/#constraint_equations","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"","category":"section"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"In many applications one has additional algebraic or differential equations for non-chemical species that can be coupled to a chemical reaction network model. Catalyst supports coupled differential and algebraic equations, and currently allows conversion of such coupled systems to ModelingToolkit ODESystems and NonlinearSystems. Likewise, one often needs events that can occur when a set condition is reached, such as providing a drug treatment at a specified time, or turning off production of cells once the population reaches a given level. Catalyst supports the event representation provided by ModelingToolkit, see here, allowing for both continuous and discrete events (though only the latter are supported when converting to JumpSystems currently).","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"In this tutorial we'll illustrate how to make use of constraint equations and events. Let's consider a model of a cell with volume V(t) that grows at a rate lambda. For now we'll assume the cell can grow indefinitely. We'll also keep track of one protein P(t), which is produced at a rate proportional V and can be degraded.","category":"page"},{"location":"catalyst_functionality/constraint_equations/#constraint_equations_coupling_constratins","page":"Constraint Equations and Events","title":"Coupling ODE constraints via extending a system","text":"","category":"section"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"There are several ways we can create our Catalyst model with the two reactions and ODE for V(t). One approach is to use compositional modeling, create separate ReactionSystems and ODESystems with their respective components, and then extend the ReactionSystem with the ODESystem. Let's begin by creating these two systems:","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"using Catalyst, DifferentialEquations, Plots\n\n# set the growth rate to 1.0\n@parameters λ = 1.0\n\n# set the initial volume to 1.0\n@variables t V(t) = 1.0\n\n# build the ODESystem for dV/dt\nD = Differential(t)\neq = [D(V) ~ λ * V]\n@named osys = ODESystem(eq, t)\n\n# build the ReactionSystem with no protein initially\nrn = @reaction_network begin\n    @species P(t) = 0.0\n    $V,   0 --> P\n    1.0, P --> 0\nend","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Notice, here we interpolated the variable V with $V to ensure we use the same symbolic state variable in the rn as we used in building osys. See the doc section on interpolation of variables for more information.","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"We can now merge the two systems into one complete ReactionSystem model using ModelingToolkit.extend:","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"@named growing_cell = extend(osys, rn)","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"We see that the combined model now has both the reactions and ODEs as its equations. To solve and plot the model we proceed like normal","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"oprob = ODEProblem(growing_cell, [], (0.0, 1.0))\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"catalyst_functionality/constraint_equations/#Coupling-ODE-constraints-via-directly-building-a-ReactionSystem","page":"Constraint Equations and Events","title":"Coupling ODE constraints via directly building a ReactionSystem","text":"","category":"section"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"As an alternative to the previous approach, we could have constructed our ReactionSystem all at once by directly using the symbolic interface:","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"using Catalyst, DifferentialEquations, Plots\n\n@parameters λ = 1.0\n@variables t V(t) = 1.0\nD = Differential(t)\neq = D(V) ~ λ * V\nrx1 = @reaction $V, 0 --> P\nrx2 = @reaction 1.0, P --> 0\n@named growing_cell = ReactionSystem([rx1, rx2, eq], t)\nsetdefaults!(growing_cell, [:P => 0.0])\n\noprob = ODEProblem(growing_cell, [], (0.0, 1.0))\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"catalyst_functionality/constraint_equations/#constraint_equations_events","page":"Constraint Equations and Events","title":"Adding events","text":"","category":"section"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Our current model is unrealistic in assuming the cell will grow exponentially forever. Let's modify it such that the cell divides in half every time its volume reaches a size of 2. We also assume we lose half of the protein upon division. Note, we will only keep track of one cell, and hence follow a specific  lineage of the system. To do this we can create a continuous event using the ModelingToolkit symbolic event interface and attach it to our system. Please see the associated ModelingToolkit tutorial for more details on the types of events that can be represented symbolically. A lower-level approach for creating events via the DifferentialEquations.jl callback interface is illustrated in the Advanced Simulation Options tutorial.","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Let's first create our equations and states/species again","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"using Catalyst, DifferentialEquations, Plots\n\n@parameters λ = 1.0\n@variables t V(t) = 1.0\n@species P(t) = 0.0\nD = Differential(t)\neq = D(V) ~ λ * V\nrx1 = @reaction $V, 0 --> $P\nrx2 = @reaction 1.0, $P --> 0","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Before creating our ReactionSystem we make the event.","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"# every 1.0 time unit we half the volume of the cell and the number of proteins\ncontinuous_events = [V ~ 2.0] => [V ~ V/2, P ~ P/2]","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"We can now create and simulate our model","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"@named rs = ReactionSystem([rx1, rx2, eq], t; continuous_events)\n\noprob = ODEProblem(rs, [], (0.0, 10.0))\nsol = solve(oprob, Tsit5())\nplot(sol; plotdensity = 1000)","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"We can also model discrete events. Similar to our example with continuous events, we start by creating reaction equations, parameters, variables, and states. ","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"@parameters k_on switch_time k_off\n@variables t\n@species A(t) B(t)\n\nrxs = [(@reaction k_on, A --> B), (@reaction k_off, B --> A)]","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Now we add an event such that at time t (switch_time), k_on is set to zero. ","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"discrete_events = (t == switch_time) => [k_on ~ 0.0]\n\nu0 = [:A => 10.0, :B => 0.0]\ntspan = (0.0, 4.0)\np = [k_on => 100.0, switch_time => 2.0, k_off => 10.0]","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Simulating our model, ","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"@named osys = ReactionSystem(rxs, t, [A, B], [k_on, k_off, switch_time]; discrete_events)\n\noprob = ODEProblem(osys, u0, tspan, p)\nsol = solve(oprob, Tsit5(); tstops = 2.0)\nplot(sol)","category":"page"},{"location":"catalyst_functionality/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Note that for discrete events we need to set a stop time, tstops, so that the ODE solver can step exactly to the specific time of our event. For a detailed discussion on how to directly use the lower-level but more flexible DifferentialEquations.jl event/callback interface, see the tutorial on event handling using callbacks. ","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/#programmatic_CRN_construction","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"","category":"section"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"While the DSL provides a simple interface for creating ReactionSystems, it can often be convenient to build or augment a ReactionSystem programmatically. In this tutorial we show how to build the repressilator model of the Introduction to Catalyst tutorial directly using symbolic variables, and then summarize the basic API functionality for accessing information stored within ReactionSystems.","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/#Directly-building-the-repressilator-with-ReactionSystems","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Directly building the repressilator with ReactionSystems","text":"","category":"section"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"We first load Catalyst","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"using Catalyst","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"and then define symbolic variables for each parameter and species in the system (the latter corresponding to a variable or state in ModelingToolkit terminology)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@parameters α K n δ γ β μ\n@variables t\n@species m₁(t) m₂(t) m₃(t) P₁(t) P₂(t) P₃(t)\nnothing    # hide","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Note, each species is declared as a function of time!","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"note: Note\nFor users familiar with ModelingToolkit, chemical species must be declared    via the @species macro, and not the ModelingToolkit.@variables macro.    @species wraps @variables, adding additional metadata to the symbolic    variables that represent species which is used internally in Catalyst.","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Next, we specify the chemical reactions that comprise the system using Catalyst Reactions","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rxs = [Reaction(hillr(P₃,α,K,n), nothing, [m₁]),\n       Reaction(hillr(P₁,α,K,n), nothing, [m₂]),\n       Reaction(hillr(P₂,α,K,n), nothing, [m₃]),\n       Reaction(δ, [m₁], nothing),\n       Reaction(γ, nothing, [m₁]),\n       Reaction(δ, [m₂], nothing),\n       Reaction(γ, nothing, [m₂]),\n       Reaction(δ, [m₃], nothing),\n       Reaction(γ, nothing, [m₃]),\n       Reaction(β, [m₁], [m₁,P₁]),\n       Reaction(β, [m₂], [m₂,P₂]),\n       Reaction(β, [m₃], [m₃,P₃]),\n       Reaction(μ, [P₁], nothing),\n       Reaction(μ, [P₂], nothing),\n       Reaction(μ, [P₃], nothing)]\nnothing    # hide","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Here we use nothing where the DSL used varnothing. Finally, we are ready to construct our ReactionSystem as","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@named repressilator = ReactionSystem(rxs, t)\nnothing     # hide","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Notice, the model is named repressilator. A name must always be specified when directly constructing a ReactionSystem (the DSL will auto-generate one if left out). Using @named when constructing a ReactionSystem causes the name of the system to be the same as the name of the variable storing the system. Alternatively, one can use the name = :repressilator keyword argument to the ReactionSystem constructor.","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"We can check that this is the same model as the one we defined via the DSL as follows (this requires that we use the same names for rates, species and the system)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"repressilator2 = @reaction_network repressilator begin\n    hillr(P₃,α,K,n), ∅ --> m₁\n    hillr(P₁,α,K,n), ∅ --> m₂\n    hillr(P₂,α,K,n), ∅ --> m₃\n    (δ,γ), m₁ <--> ∅\n    (δ,γ), m₂ <--> ∅\n    (δ,γ), m₃ <--> ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    β, m₃ --> m₃ + P₃\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\n    μ, P₃ --> ∅\nend\nrepressilator == repressilator2","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"For more options in building ReactionSystems, see the ReactionSystem API docs. For a more extensive example of how to programmatically create a ReactionSystem, see the Smoluchowski Coagulation Equation example.","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/#More-general-Reactions","page":"Programmatic Construction of Symbolic Reaction Systems","title":"More general Reactions","text":"","category":"section"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"In the example above all the specified Reactions were first or zero order. The three-argument form of Reaction implicitly assumes all species have a stoichiometric coefficient of one, i.e. for substrates [S₁,...,Sₘ] and products [P₁,...,Pₙ] it has the possible forms","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# rate, S₁ + ... + Sₘ --> P₁ + ... + Pₙ\nReaction(rate, [S₁,...,Sₘ], [P₁,...,Pₙ])\n\n# rate, S₁ + ... + Sₘ --> ∅\nReaction(rate, [S₁,...,Sₘ], nothing)\n\n# rate, ∅ --> P₁ + ... + Pₙ\nReaction(rate, nothing, [P₁,...,Pₙ])","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"To allow for other stoichiometric coefficients we also provide a five argument form","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# rate, α₁*S₁ + ... + αₘ*Sₘ --> β₁*P₁ + ... + βₙ*Pₙ\nReaction(rate, [S₁,...,Sₘ], [P₁,...,Pₙ], [α₁,...,αₘ], [β₁,...,βₙ])\n\n# rate, α₁*S₁ + ... + αₘ*Sₘ --> ∅\nReaction(rate, [S₁,...,Sₘ], nothing, [α₁,...,αₘ], nothing)\n\n# rate, ∅ --> β₁*P₁ + ... + βₙ*Pₙ\nReaction(rate, nothing, [P₁,...,Pₙ], nothing, [β₁,...,βₙ])","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Finally, we note that the rate constant, rate above, does not need to be a constant or fixed function, but can be a general symbolic expression:","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@parameters α, β\n@variables t\n@species A(t), B(t)\nrx = Reaction(α + β*t*A, [A], [B])","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"See the FAQs for info on using general user-specified functions for the rate constant.","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/#The-@reaction-macro-for-constructing-Reactions","page":"Programmatic Construction of Symbolic Reaction Systems","title":"The @reaction macro for constructing Reactions","text":"","category":"section"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"In some cases one wants to build reactions incrementally, as in the repressilator example, but it would be nice to still have a short hand as in the @reaction_network DSL. In this case one can construct individual reactions using the @reaction macro.","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"For example, the repressilator reactions could also have been constructed like","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@variables t\n@species P₁(t) P₂(t) P₃(t)\nrxs = [(@reaction hillr($P₃,α,K,n), ∅ --> m₁),\n       (@reaction hillr($P₁,α,K,n), ∅ --> m₂),\n       (@reaction hillr($P₂,α,K,n), ∅ --> m₃),\n       (@reaction δ, m₁ --> ∅),\n       (@reaction γ, ∅ --> m₁),\n       (@reaction δ, m₂ --> ∅),\n       (@reaction γ, ∅ --> m₂),\n       (@reaction δ, m₃ --> ∅),\n       (@reaction γ, ∅ --> m₃),\n       (@reaction β, m₁ --> m₁ + P₁),\n       (@reaction β, m₂ --> m₂ + P₂),\n       (@reaction β, m₃ --> m₃ + P₃),\n       (@reaction μ, P₁ --> ∅),\n       (@reaction μ, P₂ --> ∅),\n       (@reaction μ, P₃ --> ∅)]\n@named repressilator = ReactionSystem(rxs, t)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Note, there are a few differences when using the @reaction macro to specify one reaction versus using the full @reaction_network macro to create a ReactionSystem. First, only one reaction (i.e. a single forward arrow type) can be used, i.e. reversible arrows like <--> will not work (since they define more than one reaction). Second, the @reaction macro does not have an option for designating what should be considered a species or parameter, and instead assumes that any symbol that appears as either a substrate or a product is a species, and everything else (including stoichiometric coefficients) are parameters. As such, the following are equivalent","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx = @reaction hillr(P,α,K,n), A --> B","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"is equivalent to","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@parameters P α K n\n@variables t A(t) B(t)\nrx = Reaction(hillr(P,α,K,n), [A], [B])","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Here (P,α,K,n) are parameters and (A,B) are species.","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"This behavior is the reason that in the repressilator example above we pre-declared (P₁(t),P₂(t),P₃(t)) as variables, and then used them via interpolating their values into the rate law expressions using $ in the macro. This ensured they were properly treated as species and not parameters. See the @reaction macro docstring for more information.","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/#Basic-querying-of-ReactionSystems","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Basic querying of ReactionSystems","text":"","category":"section"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"The Catalyst.jl API provides a large variety of functionality for querying properties of a reaction network. Here we go over a few of the most useful basic functions. Given the repressillator defined above we have that","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"species(repressilator)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"parameters(repressilator)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"reactions(repressilator)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"We can test if a Reaction is mass action, i.e. the rate does not depend on t or other species, as","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# Catalyst.hillr(P₃(t), α, K, n), ∅ --> m₁\nrx1 = reactions(repressilator)[1]\nismassaction(rx1,repressilator)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"while","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# δ, m₁ --> ∅\nrx2 = reactions(repressilator)[4]\nismassaction(rx2,repressilator)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Similarly, we can determine which species a reaction's rate law will depend on like","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rn = @reaction_network begin\n       k*W, 2X + 3Y --> 5Z + W\n     end\ndependents(reactions(rn)[1], rn)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Basic stoichiometry matrices can be obtained from a ReactionSystem as","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"substoichmat(repressilator)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"prodstoichmat(repressilator)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"netstoichmat(repressilator)","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Here the (ij) entry gives the corresponding stoichiometric coefficient of species i for reaction j.","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Finally, we can directly access fields of individual reactions like","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.rate","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.substrates","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.products","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.substoich","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.prodstoich","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.netstoich","category":"page"},{"location":"catalyst_functionality/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"See the Catalyst.jl API for much more detail on the various querying and analysis functions provided by Catalyst.","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/#smoluchowski_coagulation_equation","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"","category":"section"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"This tutorial shows how to programmatically construct a ReactionSystem corresponding to the chemistry underlying the Smoluchowski coagulation model using ModelingToolkit/Catalyst. A jump process version of the model is then constructed from the ReactionSystem, and compared to the model's analytical solution obtained by the method of Scott (see also 3).","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"The Smoluchowski coagulation equation describes a system of reactions in which monomers may collide to form dimers, monomers and dimers may collide to form trimers, and so on. This models a variety of chemical/physical processes, including polymerization and flocculation.","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We begin by importing some necessary packages.","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"using ModelingToolkit, Catalyst, LinearAlgebra\nusing DiffEqBase, JumpProcesses\nusing Plots, SpecialFunctions","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"Suppose the maximum cluster size is N. We assume an initial concentration of monomers, Nₒ, and let uₒ denote the initial number of monomers in the system. We have nr total reactions, and label by V the bulk volume of the system (which plays an important role in the calculation of rate laws since we have bimolecular reactions). Our basic parameters are then","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"## Parameter\nN = 10                       # maximum cluster size\nVₒ = (4π/3)*(10e-06*100)^3   # volume of a monomers in cm³\nNₒ = 1e-06/Vₒ                # initial conc. = (No. of init. monomers) / bulk volume\nuₒ = 10000                   # No. of monomers initially\nV = uₒ/Nₒ                    # Bulk volume of system in cm³\n\ninteg(x) = Int(floor(x))\nn        = integ(N/2)\nnr       = N%2 == 0 ? (n*(n + 1) - n) : (n*(n + 1)) # No. of forward reactions","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"The Smoluchowski coagulation equation Wikipedia page illustrates the set of possible reactions that can occur. We can easily enumerate the pairs of multimer reactants that can combine when allowing a maximal cluster size of N monomers. We initialize the volumes of the reactant multimers as volᵢ and volⱼ","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# possible pairs of reactant multimers\npair = []\nfor i = 2:N\n    push!(pair, [1:integ(i/2)  i .- (1:integ(i/2))])\nend\npair = vcat(pair...)\nvᵢ = @view pair[:,1]   # Reactant 1 indices\nvⱼ = @view pair[:,2]   # Reactant 2 indices\nvolᵢ = Vₒ*vᵢ           # cm⁻³\nvolⱼ = Vₒ*vⱼ           # cm⁻³\nsum_vᵢvⱼ = @. vᵢ + vⱼ  # Product index","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We next specify the rates (i.e. kernel) at which reactants collide to form products. For simplicity, we allow a user-selected additive kernel or constant kernel. The constants(B and C) are adopted from Scott's paper 2","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# set i to  1 for additive kernel, 2  for constant\ni = 1\nif i==1\n    B = 1.53e03                # s⁻¹\n    kv = @. B*(volᵢ + volⱼ)/V  # dividing by volume as its a bi-molecular reaction chain\nelseif i==2\n    C = 1.84e-04               # cm³ s⁻¹\n    kv = fill(C/V, nr)\nend","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We'll store the reaction rates in pars as Pairs, and set the initial condition that only monomers are present at t=0 in u₀map.","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# state variables are X, pars stores rate parameters for each rx\n@variables t\n@species k[1:nr] (X(t))[1:N]\npars = Pair.(collect(k), kv)\n\n# time-span\nif i == 1\n    tspan = (0. ,2000.)\nelseif i == 2\n    tspan = (0. ,350.)\nend\n\n # initial condition of monomers\nu₀    = zeros(Int64, N)\nu₀[1] = uₒ\nu₀map = Pair.(collect(X), u₀)   # map variable to its initial value","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"Here we generate the reactions programmatically. We systematically create Catalyst Reactions for each possible reaction shown in the figure on Wikipedia. When vᵢ[n] == vⱼ[n], we set the stoichiometric coefficient of the reactant multimer to two.","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# vector to store the Reactions in\nrx = []\nfor n = 1:nr\n    # for clusters of the same size, double the rate\n    if (vᵢ[n] == vⱼ[n])\n        push!(rx, Reaction(k[n], [X[vᵢ[n]]], [X[sum_vᵢvⱼ[n]]], [2], [1]))\n    else\n        push!(rx, Reaction(k[n], [X[vᵢ[n]], X[vⱼ[n]]], [X[sum_vᵢvⱼ[n]]],\n                           [1, 1], [1]))\n    end\nend\n@named rs = ReactionSystem(rx, t, collect(X), collect(k))","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We now convert the ReactionSystem into a ModelingToolkit.JumpSystem, and solve it using Gillespie's direct method. For details on other possible solvers (SSAs), see the DifferentialEquations.jl documentation","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# solving the system\njumpsys = convert(JumpSystem, rs)\ndprob   = DiscreteProblem(jumpsys, u₀map, tspan, pars)\njprob   = JumpProblem(jumpsys, dprob, Direct(), save_positions=(false,false))\njsol    = solve(jprob, SSAStepper(), saveat = tspan[2]/30)","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"Lets check the results for the first three polymers/cluster sizes. We compare to the analytical solution for this system:","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# Results for first three polymers...i.e. monomers, dimers and trimers\nv_res = [1;2;3]\n\n# comparison with analytical solution\n# we only plot the stochastic solution at a small number of points\n# to ease distinguishing it from the exact solution\nt   = jsol.t\nsol = zeros(length(v_res), length(t))\nif i == 1\n    ϕ = @. 1 - exp(-B*Nₒ*Vₒ*t)\n    for j in v_res\n        sol[j,:] = @. Nₒ*(1 - ϕ)*(((j*ϕ)^(j-1))/gamma(j+1))*exp(-j*ϕ)\n    end\nelseif i == 2\n    ϕ = @. (C*Nₒ*t)\n    for j in v_res\n        sol[j,:] = @. 4Nₒ*((ϕ^(j-1))/((ϕ + 2)^(j+1)))\n    end\nend\n\n# plotting normalised concentration vs analytical solution\ndefault(lw=2, xlabel=\"Time (sec)\")\nscatter(ϕ, jsol(t)[1,:]/uₒ, label=\"X1 (monomers)\", markercolor=:blue)\nplot!(ϕ, sol[1,:]/Nₒ, line = (:dot,4,:blue), label=\"Analytical sol--X1\")\n\nscatter!(ϕ, jsol(t)[2,:]/uₒ, label=\"X2 (dimers)\", markercolor=:orange)\nplot!(ϕ, sol[2,:]/Nₒ, line = (:dot,4,:orange), label=\"Analytical sol--X2\")\n\nscatter!(ϕ, jsol(t)[3,:]/uₒ, label=\"X3 (trimers)\", markercolor=:purple)\nplot!(ϕ, sol[3,:]/Nₒ, line = (:dot,4,:purple), label=\"Analytical sol--X3\",\n      ylabel = \"Normalized Concentration\")","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"For the additive kernel we find","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"(Image: additive_kernel)","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/#References","page":"Smoluchowski Coagulation Equation","title":"References","text":"","category":"section"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"[1]: https://en.wikipedia.org/wiki/Smoluchowski_coagulation_equation","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"[2]: Scott, W. T. (1968). Analytic Studies of Cloud Droplet Coalescence I, Journal of Atmospheric Sciences, 25(1), 54-65. Retrieved Feb 18, 2021, from https://journals.ametsoc.org/view/journals/atsc/25/1/1520-0469_1968_025_0054_asocdc_2_0_co_2.xml","category":"page"},{"location":"catalyst_functionality/example_networks/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"[3]: Ian J. Laurenzi, John D. Bartels, Scott L. Diamond, A General Algorithm for Exact Simulation of Multicomponent Aggregation Processes, Journal of Computational Physics, Volume 177, Issue 2, 2002, Pages 418-449, ISSN 0021-9991, https://doi.org/10.1006/jcph.2002.7017.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The Catalyst tool for the modelling of chemical reaction networks is based in the Julia programming language. While experience in Julia programming is advantageous for using Catalyst, it is not necessary for accessing some of its basic features. This tutorial serves as an introduction to Catalyst for those unfamiliar with Julia, also introducing some basic Julia concepts. Anyone who plans on using Catalyst extensively is recommended to familiarise oneself more thoroughly with the Julia programming language. A collection of resources for learning Julia can be found here, and a full documentation is available here.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Julia can be downloaded here. Generally, it is recommended to use the juliaup tool to install and update Julia. Furthermore, Visual Studio Code is a good IDE with extensive Julia support, and a good default choice.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Users who are already familiar with Julia can skip to the Introduction to Catalyst tutorial.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Basic-Julia-usage","page":"Introduction to Catalyst and Julia for New Julia users","title":"Basic Julia usage","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"On the surface, Julia has many similarities to languages like MATLAB, Python, and R.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Values can be assigned to variables through = sign. Values (possibly stored in variables) can be used for most basic computations.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"length = 2.0\nwidth = 4.0\narea = length * width","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Functions take one or more inputs (enclosed by ()) and return some output. E.g. the min function returns the minimum of two values.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"min(1.0, 3.0)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Each Julia variable has a specific type, designating what type of value it is. While not directly required to use Catalyst, this is useful to be aware of. To learn the type of a specific variable, use the typeof function. More information about types can be found here.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"typeof(1.0)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, Float64 denotes decimal-valued numbers. Integer-valued numbers instead are of the Int64 type.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"typeof(1)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"There exists a large number of Julia types (with even more being defined by various packages). Additional examples include Strings (defined by enclosing text within \" \"):","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"\"Hello world!\"","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"and Symbols (defined by pre-appending an expression with :):","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":":Julia","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, we note that the first time some code is run in Julia, it has to be compiled. However, this is only required once per Julia session. Hence, the second time the same code is run, it runs much faster. E.g. try running this line of code first one time, and then one additional time. You will note that the second run is much faster.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"rand(100, 100)^3.5\nnothing # hide","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"(This code creates a random 100x100 matrix, and takes it to the power of 3.5)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"This is useful to know when you e.g. declare, simulate, or plot, a Catalyst model. The first time you run a command there might be a slight delay. However, subsequent runs will be much quicker. This holds even if you make minor adjustments before the second run (such as changing simulation initial conditions).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_intro","page":"Introduction to Catalyst and Julia for New Julia users","title":"Installing and activating packages","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Due to its native package manager (Pkg), and a registry of almost all packages of relevancy, package management in Julia is unusually easy. Here, we will briefly describe how to install and activate Catalyst (and two additional packages relevant to this tutorial).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"To import a Julia package into a session, you can use the using PackageName command (where PackageName is the name of the package you wish to import). However, before you can do so, it must first be installed on your computer. This is done through the Pkg.add(\"PackageName\") command:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg\nPkg.add(\"Catalyst\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, the Julia package manager package (Pkg) is by default installed on your computer when Julia is installed, and can be activated directly. Next, we also wish to install the DifferentialEquations and Plots packages (for numeric simulation of models, and plotting, respectively).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.add(\"DifferentialEquations\")\nPkg.add(\"Plots\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Once a package has been installed through the Pkg.add command, this command does not have to be repeated if we restart our Julia session. We can now import all three packages into our current session with:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Catalyst\nusing DifferentialEquations\nusing Plots","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, if we restart Julia, these commands *do need to be rerun.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"A more comprehensive (but still short) introduction to package management in Julia is provided at the end of this documentation page. It contains some useful information and is hence highly recommended reading. For a more detailed introduction to Julia package management, please read the Pkg documentation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Simulating-a-basic-Catalyst-model","page":"Introduction to Catalyst and Julia for New Julia users","title":"Simulating a basic Catalyst model","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Now that we have some basic familiarity with Julia, and have installed and imported the required packages, we will create and simulate a basic chemical reaction network model using Catalyst.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Catalyst models are created through the @reaction_network macro. For more information on macros, please read the Julia documentation on macros. This documentation is, however, rather advanced (and not required to use Catalyst). We instead recommend that you simply familiarise yourself with the Catalyst syntax, without studying in detail how macros work and what they are.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The @reaction_network command is followed by the begin keyword, which is followed by one line for each reaction of the model. Each reaction consists of a reaction rate, followed by the reaction itself. The reaction contains a set of substrates and a set of products (what is consumed and produced by the reaction, respectively). These are separated by a --> arrow. Finally, the model ends with the end keyword.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, we create a simple birth-death model, where a single species (X) is created at rate b, and degraded at rate d. The model is stored in the variable rn.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"rn = @reaction_network begin\n    b, 0 --> X\n    d, X --> 0\nend","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"For more information on how to use the Catalyst model creator (also known as the Catalyst DSL), please read the corresponding documentation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Next, we wish to simulate our model. To do this, we need to provide some additional information to the simulator. This is","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The initial condition. That is, the concentration (or copy numbers) of each species at the start of the simulation.\nThe timespan. That is, the timeframe over which we wish to run the simulation.\nThe parameter values. That is, the values of the model's parameters for this simulation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The initial condition is given as a Vector. This is a type which collects several different values. To declare a vector, the values are specific within brackets, [], and separated by ,. Since we only have one species, the vector holds a single element. In this element, we set the value of X using the :X => 1.0 syntax. Here, we first denote the name of the species (with a : pre-appended, i.e. creating a Symbol), next follows a => and then the value of X. Since we wish to simulate the concentration of X over time, we will let the initial condition be decimal valued.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"u0 = [:X => 1.0]","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The timespan sets the time point at which we start the simulation (typically 0.0 is used) and the final time point of the simulation. These are combined into a two-valued tuple. Tuples are similar to vectors, but are enclosed by () and not []. Again, we will let both time points be decimal valued.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"tspan = (0.0, 10.0)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, the parameter values are, like the initial conditions, given in a vector. Since we have two parameters (b and d), the parameter vector has two values. We use a similar notation for setting the parameter values as the initial condition (first the parameter, then an arrow, then the value).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"params = [:b => 1.0, :d => 0.2]","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Please read here for more information on vectors and tuples.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Next, before we can simulate our model, we bundle all the required information together in a so-called ODEProblem. Note that the order in which the input (the model, the initial condition, the timespan, and the parameter values) is provided to the ODEProblem matters. E.g. the parameter values cannot be provided as the first argument, but have to be the fourth argument. Here, we save our ODEProblem in the oprob variable.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"oprob = ODEProblem(rn, u0, tspan, params)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We can now simulate our model. We do this by providing the ODEProblem to the solve function. We save the output to the sol variable.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"sol = solve(oprob)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, we can plot the solution through the plot function.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"plot(sol)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, the plot shows the time evolution of the concentration of the species X from its initial condition.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"For more information about the numerical simulation package, please see the DifferentialEquations documentation. For more information about the plotting package, please see the Plots documentation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Additional-modelling-example","page":"Introduction to Catalyst and Julia for New Julia users","title":"Additional modelling example","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"To make this introduction more comprehensive, we here provide another example, using a more complicated model. Instead of simulating our model as concentrations evolve over time, we will now simulate the individual reaction events through the Gillespie algorithm (a common approach for adding noise to models).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Remember, unless we have restarted Julia, we do not need to activate our packages (through the using command) again.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"This time, we will declare a so-called SIR model for an infectious disease. Note that even if this model does not describe a set of chemical reactions, it can be modelled using the same framework. The model consists of 3 species:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"S\n, the amount of susceptible individuals.\nI\n, the amount of infected individuals.\nR\n, the amount of recovered (or removed) individuals.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"It also has 2 reaction events:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Infection, where a susceptible individual meets an infected individual and also becomes infected.\nRecovery, where an infected individual recovers from the infection.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Each reaction is also associated with a specific rate (corresponding to a parameter).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"b, the infection rate.\nk, the recovery rate.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We declare the model using the @reaction_network macro, and store it in the sir_model variable.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"sir_model = @reaction_network begin\n    b, S + I --> 2I\n    k, I --> R\nend","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Note that the first reaction contains two different substrates (separated by a + sign). While there is only a single product (I), two copies of I are produced. The 2 in front of the product I denotes this.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Next, we declare our initial condition, time span, and parameter values. Since we want to simulate the individual reaction events that discretely change the state of our model, we want our initial conditions to be integer-valued. We will start with a mostly susceptible population, but where a single individual has been infected through some means.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"u0 = [:S => 50, :I => 1, :R => 0]\ntspan = (0.0, 10.0)\nparams = [:b => 0.2, :k => 1.0]\nnothing # hide","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Previously we have bundled this information into an ODEProblem (denoting a deterministic ordinary differential equation). Now we wish to simulate our model as a jump process (where each reaction event corresponds to a single jump in the state of the system). We do this by first creating a DiscreteProblem, and then using this as an input to a JumpProblem.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"dprob = DiscreteProblem(sir_model, u0, tspan, params)\njprob = JumpProblem(sir_model, dprob, Direct())","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Again, the order with which the inputs are given to the DiscreteProblem and the JumpProblem is important. The last argument to the JumpProblem (Direct()) denotes which simulation method we wish to use. For now, we recommend that users simply use the Direct() option, and then consider alternative ones (see the JumpProcesses.jl docs) when they are more familiar with modelling in Catalyst and Julia.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, we can simulate our model using the solve function, and plot the solution using the plot function. Here, the solve function also has a second argument (SSAStepper()). This is a time stepping algorithm that calls the Direct solver to advance a simulation. Again, we recommend at this stage you simply use this option, and then explore exactly what this means at a later stage.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"sol = solve(jprob, SSAStepper())\nsol = solve(jprob, SSAStepper(); seed=1234) # hide\nplot(sol)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Exercise: Try simulating the model several times. Note that the epidemic doesn't always take off, but sometimes dies out without spreading through the population. Try changing the infection rate (b), determining how this value affects the probability that the epidemic goes through the population.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages","page":"Introduction to Catalyst and Julia for New Julia users","title":"Package management in Julia","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We have previously introduced how to install and activate Julia packages. While this is enough to get started with Catalyst, for long-term users, there are some additional considerations for a smooth experience. These are described here.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_environments","page":"Introduction to Catalyst and Julia for New Julia users","title":"Setting up a new Julia environment","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Whenever you run Julia, it will run in a specific environment. You can specify any folder on your computer as a Julia environment. Some modes of running Julia will automatically use the environment corresponding to the folder you start Julia in. Others (or if you start Julia in a folder without an environment), will use your default environment. In these cases you can, during your session, switch to another environment. While it is possible to not worry about environments (and always use the default one), this can lead to long-term problems as more packages are installed.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"To activate your current folder as an environment, run the following commands:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"This will:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If your current folder (which can be displayed using the pwd() command) is not designated as a possible Julia environment, designate it as such.\nSwitch your current Julia session to use the current folder's environment.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"note: Note\nIf you check any folder which has been designated as a Julia environment, it contains a Project.toml and a Manifest.toml file. These store all information regarding the corresponding environment. For non-advanced users, it is recommended to never touch these files directly (and instead do so using various functions from the Pkg package, the important ones which are described in the next two subsections).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_installing","page":"Introduction to Catalyst and Julia for New Julia users","title":"Installing and importing packages in Julia","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Package installation and import have been described previously. However, for the sake of this extended tutorial, let us repeat the description by demonstrating how to install the Latexify.jl package (which enables e.g. displaying Catalyst models in Latex format). First, we import the Julia Package manager (Pkg) (which is required to install Julia packages):","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Latexify is a registered package, so it can be installed directly using:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.add(\"Latexify\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, to import Latexify into our current Julia session we use:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Latexify","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, using Latexify must be rerun whenever you restart a Julia session. However, you only need to run Pkg.add(\"Latexify\") once to install it on your computer (but possibly additional times to add it to new environments, see the next section).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_environment_importance","page":"Introduction to Catalyst and Julia for New Julia users","title":"Why environments are important","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We have previously described how to set up new Julia environments, how to install Julia packages, and how to import them into a current session. Let us say that you were to restart Julia in a new folder and activate this as a separate environment. If you then try to import Latexify through using Latexify you will receive an error claiming that Latexify was not found. The reason is that the Pkg.add(\"Latexify\") command actually carries out two separate tasks:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If Latexify is not already installed on your computer, install it.\nAdd Latexify as an available package to your current environment.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, while Catalyst has previously been installed on your computer, it has not been added to the new environment you created. To do so, simply run ","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg\nPkg.add(\"Latexify\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"after which Catalyst can be imported through using Latexify. You can get a list of all packages available in your current environment using:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.status()","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"So, why is this required, and why cannot we simply import any package installed on our computer? The reason is that most packages depend on other packages, and these dependencies may be restricted to only specific versions of these packages. This creates complicated dependency graphs that restrict what versions of what packages are compatible with each other. When you use Pkg.add(\"PackageName\"), only a specific version of that package is actually added (the latest possible version as permitted by the dependency graph). Here, Julia environments both define what packages are available and their respective versions (these versions are also displayed by the Pkg.status() command). By doing this, Julia can guarantee that the packages (and their versions) specified in an environment are compatible with each other.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The reason why all this is important is that it is highly recommended to, for each project, define a separate environment. To these, only add the required packages. General-purpose environments with a large number of packages often produce package-incompatibility issues. While these might not prevent you from installing all desired package, they often mean that you are unable to use the latest version of some packages.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"note: Note\nA not-infrequent cause for reported errors with Catalyst (typically the inability to replicate code in tutorials) is package incompatibilities in large environments preventing the latest version of Catalyst from being installed. Hence, whenever an issue is encountered, it is useful to run Pkg.status() to check whenever the latest version of Catalyst is being used.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Some additional useful Pkg commands are:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pk.rm(\"PackageName\") removes a package from the current environment.\nPkg.update(PackageName\"): updates the designated package.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"note: Note\nA useful feature of Julia's environment system is that enables the exact definition of what packages and versions were used to execute a script. This supports e.g. reproducibility in academic research. Here, by providing the corresponding Project.toml and Manifest.toml files, you can enable someone to reproduce the exact program just to perform some set of analyses.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Feedback","page":"Introduction to Catalyst and Julia for New Julia users","title":"Feedback","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If you are a new Julia user who has used this tutorial, and there was something you struggled with or would have liked to have explained better, please raise an issue. That way, we can continue improving this tutorial.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#References","page":"Introduction to Catalyst and Julia for New Julia users","title":"References","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"[1]: Jeff Bezanson, Alan Edelman, Stefan Karpinski, Viral B. Shah, Julia: A Fresh Approach to Numerical Computing, SIAM Review (2017).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"[2]: Torkel E. Loman, Yingbo Ma, Vasily Ilin, Shashi Gowda, Niklas Korsbo, Nikhil Yewale, Chris Rackauckas, Samuel A. Isaacson, Catalyst: Fast and flexible modeling of reaction networks, PLOS Computational Biology (2023).","category":"page"},{"location":"#Catalyst.jl-for-Reaction-Network-Modeling","page":"Home","title":"Catalyst.jl for Reaction Network Modeling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst.jl is a symbolic modeling package for analysis and high performance simulation of chemical reaction networks. Catalyst defines symbolic ReactionSystems, which can be created programmatically or easily specified using Catalyst's domain specific language (DSL). Leveraging ModelingToolkit.jl and Symbolics.jl, Catalyst enables large-scale simulations through auto-vectorization and parallelism. Symbolic ReactionSystems can be used to generate ModelingToolkit-based models, allowing the easy simulation and parameter estimation of mass action ODE models, Chemical Langevin SDE models, stochastic chemical kinetics jump process models, and more. Generated models can be used with solvers throughout the broader SciML ecosystem, including higher level SciML packages (e.g. for sensitivity analysis, parameter estimation, machine learning applications, etc).","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A DSL provides a simple and readable format for manually specifying chemical reactions.\nCatalyst ReactionSystems provide a symbolic representation of reaction networks, built on ModelingToolkit.jl and Symbolics.jl.\nNon-integer (e.g. Float64) stoichiometric coefficients are supported for generating ODE models, and symbolic expressions for stoichiometric coefficients are supported for all system types.\nThe Catalyst.jl API provides functionality for extending networks, building networks programmatically, network analysis, and for composing multiple networks together.\nReactionSystems generated by the DSL can be converted to a variety of ModelingToolkit.AbstractSystems, including symbolic ODE, SDE and jump process representations.\nCoupled differential and algebraic constraint equations can be included in Catalyst models, and are incorporated during conversion to ODEs or steady state equations.\nConservation laws can be detected and applied to reduce system sizes, and generate non-singular Jacobians, during conversion to ODEs, SDEs, and steady state equations.\nBy leveraging ModelingToolkit, users have a variety of options for generating optimized system representations to use in solvers. These include construction of dense or sparse Jacobians, multithreading or parallelization of generated derivative functions, automatic classification of reactions into optimized jump types for Gillespie type simulations, automatic construction of dependency graphs for jump systems, and more.\nGenerated systems can be solved using any DifferentialEquations.jl ODE/SDE/jump solver, and can be used within EnsembleProblems for carrying out parallelized parameter sweeps and statistical sampling. Plot recipes are available for visualizing the solutions.\nSymbolics.jl symbolic expressions and Julia Exprs can be obtained for all rate laws and functions determining the deterministic and stochastic terms within resulting ODE, SDE or jump models.\nLatexify can be used to generate LaTeX expressions corresponding to generated mathematical models or the underlying set of reactions.\nGraphviz can be used to generate and visualize reaction network graphs. (Reusing the Graphviz interface created in Catlab.jl.)","category":"page"},{"location":"#Packages-Supporting-Catalyst","page":"Home","title":"Packages Supporting Catalyst","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst ReactionSystems can be imported from SBML files via SBMLToolkit.jl, and from BioNetGen .net files and various stoichiometric matrix network representations using ReactionNetworkImporters.jl.\nMomentClosure.jl allows generation of symbolic ModelingToolkit ODESystems, representing moment closure approximations to moments of the Chemical Master Equation, from reaction networks defined in Catalyst.\nFiniteStateProjection.jl allows the construction and numerical solution of Chemical Master Equation models from reaction networks defined in Catalyst.\nDelaySSAToolkit.jl can augment Catalyst reaction network models with delays, and can simulate the resulting stochastic chemical kinetics with delays models.  \nBondGraphs.jl a package for constructing and analyzing bond graphs models, which can take Catalyst models as input.\nPEtab.jl a package that implements the PEtab format for fitting reaction network ODEs to data. Input can be provided either as SBML files or as Catalyst ReactionSystems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst can be installed through the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Catalyst\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To solve Catalyst models and visualize solutions, it is also recommended to install DifferentialEquations.jl and Plots.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"DifferentialEquations\")\nPkg.add(\"Plots\")","category":"page"},{"location":"#Illustrative-Example","page":"Home","title":"Illustrative Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example of generating, visualizing and solving an SIR ODE model. We first define the SIR reaction model using Catalyst","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Catalyst\nrn = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assuming Graphviz and is installed and command line accessible, the network can be visualized using the Graph command","category":"page"},{"location":"","page":"Home","title":"Home","text":"Graph(rn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"which in Jupyter notebooks will give the figure","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: SIR Network Graph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To generate and solve a mass action ODE version of the model we use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DifferentialEquations\np     = [:α => .1/1000, :β => .01]\ntspan = (0.0,250.0)\nu0    = [:S => 999.0, :I => 1.0, :R => 0.0]\nop    = ODEProblem(rn, u0, tspan, p)\nsol   = solve(op, Tsit5())       # use Tsit5 ODE solver","category":"page"},{"location":"","page":"Home","title":"Home","text":"which we can plot as","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nplot(sol, lw=2)","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst developers are active on the Julia Discourse, and the Julia Slack's #sciml-bridged and #sciml-sysbio channels. For bugs or feature requests open an issue.","category":"page"},{"location":"#catalyst_citation","page":"Home","title":"Supporting and Citing Catalyst.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The software in this ecosystem was developed as part of academic research. If you would like to help support it, please star the repository as such metrics may help us secure funding in the future. If you use Catalyst as part of your research, teaching, or other activities, we would be grateful if you could cite our work:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{CatalystPLOSCompBio2023,\n    doi = {10.1371/journal.pcbi.1011530},\n    author = {Loman, Torkel E. AND Ma, Yingbo AND Ilin, Vasily AND Gowda, Shashi AND Korsbo, Niklas AND Yewale, Nikhil AND Rackauckas, Chris AND Isaacson, Samuel A.},\n    journal = {PLOS Computational Biology},\n    publisher = {Public Library of Science},\n    title = {Catalyst: Fast and flexible modeling of reaction networks},\n    year = {2023},\n    month = {10},\n    volume = {19},\n    url = {https://doi.org/10.1371/journal.pcbi.1011530},\n    pages = {1-19},\n    number = {10},\n}","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also download the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nprojtoml = joinpath(\"..\", \"..\", \"Project.toml\")\nversion = TOML.parse(read(projtoml, String))[\"version\"]\nname = TOML.parse(read(projtoml, String))[\"name\"]\nlink = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version * \"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nprojtoml = joinpath(\"..\", \"..\", \"Project.toml\")\nversion = TOML.parse(read(projtoml, String))[\"version\"]\nname = TOML.parse(read(projtoml, String))[\"name\"]\nlink = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version * \"/assets/Project.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">project</a> file.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/#parameter_estimation","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"","category":"section"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"In this example we will use Optimization.jl to fit the parameters of an oscillatory system (the Brusselator) to data. Here, special consideration is taken to avoid reaching a local minimum. Instead of fitting the entire time series directly, we will start with fitting parameter values for the first period, and then use those as an initial guess for fitting the next (and then these to find the next one, and so on). Using this procedure is advantageous for oscillatory systems, and enables us to reach the global optimum.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"First, we fetch the required packages.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"using Catalyst\nusing OrdinaryDiffEq\nusing Optimization\nusing OptimizationOptimisers # Required for the ADAM optimizer.\nusing SciMLSensitivity # Required for `Optimization.AutoZygote()` automatic differentiation option.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we declare our model, the Brusselator oscillator.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"brusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\np_real = [:A => 1., :B => 2.]\nnothing # hide","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"We simulate our model, and from the simulation generate sampled data points (to which we add noise). We will use this data to fit the parameters of our model.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"u0 = [:X => 1.0, :Y => 1.0]\ntspan = (0.0, 30.0)\n\nsample_times = range(tspan[1]; stop = tspan[2], length = 100)\nprob = ODEProblem(brusselator, u0, tspan, p_real)\nsol_real = solve(prob, Rosenbrock23(); tstops = sample_times)\nsample_vals = Array(sol_real(sample_times))\nsample_vals .*= (1 .+ .1 * rand(Float64, size(sample_vals)) .- .05)\nnothing   # hide","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"We can plot the real solution, as well as the noisy samples.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"using Plots\ndefault(; lw = 3, framestyle = :box, size = (800, 400))\n\nplot(sol_real; legend = nothing, color = [:darkblue :darkred])\nscatter!(sample_times, sample_vals'; color = [:blue :red], legend = nothing)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we create a function to fit the parameters using the ADAM optimizer. For a given initial estimate of the parameter values, pinit, this function will fit parameter values, p, to our data samples. We use tend to indicate the time interval over which we fit the model.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"function optimise_p(pinit, tend)\n    function loss(p, _)\n        newtimes = filter(<=(tend), sample_times)\n        newprob = remake(prob; tspan = (0.0, tend), p = p)\n        sol = Array(solve(newprob, Rosenbrock23(); saveat = newtimes))\n        loss = sum(abs2, sol .- sample_vals[:, 1:size(sol,2)])\n        return loss, sol\n    end\n\n    # optimize for the parameters that minimize the loss\n    optf = OptimizationFunction(loss, Optimization.AutoZygote())\n    optprob = OptimizationProblem(optf, pinit)\n    sol = solve(optprob, ADAM(0.1); maxiters = 100)\n\n    # return the parameters we found\n    return sol.u\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we will fit a parameter set to the data on the interval (0, 10).","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p([5.0, 5.0], 10.0)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"We can compare this to the real solution, as well as the sample data","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"newprob = remake(prob; tspan = (0., 10.), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times, sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we use this parameter estimate as the input to the next iteration of our fitting process, this time on the interval (0, 20).","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p(p_estimate, 20.)\nnewprob = remake(prob; tspan = (0., 20.), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times, sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Finally, we use this estimate as the input to fit a parameter set on the full time interval of the sampled data.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p(p_estimate, 30.0)\n\nnewprob = remake(prob; tspan = (0., 30.0), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times, sample_vals'; color = [:blue :red],\n        label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"The final parameter estimate is then","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"which is close to the actual parameter set of [1.0, 2.0].","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/#Why-we-fit-the-parameters-in-iterations","page":"Fitting Parameters for an Oscillatory System","title":"Why we fit the parameters in iterations","text":"","category":"section"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"As previously mentioned, the reason we chose to fit the model on a smaller interval to begin with, and then extend the interval, is to avoid getting stuck in a local minimum. Here specifically, we chose our initial interval to be smaller than a full cycle of the oscillation. If we had chosen to fit a parameter set on the full interval immediately we would have obtained poor fit and an inaccurate estimate for the parameters.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p([5.0,5.0], 30.0)\n\nnewprob = remake(prob; tspan = (0.0,30.0), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times,sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"}]
}
