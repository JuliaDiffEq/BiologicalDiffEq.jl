<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization for non-data fitting purposes · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/inverse_problems/behaviour_optimisation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Functionality</span><ul><li><a class="tocitem" href="../../catalyst_functionality/dsl_description/">The Reaction DSL</a></li><li><a class="tocitem" href="../../catalyst_functionality/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../catalyst_functionality/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../catalyst_functionality/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../catalyst_functionality/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../catalyst_functionality/example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../catalyst_functionality/example_networks/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../catalyst_functionality/example_networks/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Catalyst Applications</span><ul><li><a class="tocitem" href="../../catalyst_applications/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../catalyst_applications/advanced_simulations/">Advanced Simulation Options</a></li><li><a class="tocitem" href="../../catalyst_applications/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../catalyst_applications/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl</a></li><li><a class="tocitem" href="../../catalyst_applications/bifurcation_diagrams/">Bifurcation Diagrams</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../optimization_ode_param_fitting/">Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li><li class="is-active"><a class="tocitem" href>Optimization for non-data fitting purposes</a><ul class="internal"><li><a class="tocitem" href="#Maximising-the-pulse-amplitude-of-an-incoherent-feed-forward-loop."><span>Maximising the pulse amplitude of an incoherent feed forward loop.</span></a></li><li><a class="tocitem" href="#Utilising-automatic-differentiation"><span>Utilising automatic differentiation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../structural_identifiability/">Structural Identifiability Analysis</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/catalyst_api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Inverse Problems</a></li><li class="is-active"><a href>Optimization for non-data fitting purposes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization for non-data fitting purposes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/inverse_problems/behaviour_optimisation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="behaviour_optimisation"><a class="docs-heading-anchor" href="#behaviour_optimisation">Optimization for non-data fitting purposes</a><a id="behaviour_optimisation-1"></a><a class="docs-heading-anchor-permalink" href="#behaviour_optimisation" title="Permalink"></a></h1><p>In previous tutorials we have described how to use <a href="../petab_ode_param_fitting/#petab_parameter_fitting">PEtab.jl</a> and <a href="../optimization_ode_param_fitting/#optimization_parameter_fitting">Optimization.jl</a> for parameter fitting. This involves solving an optimisation problem (to find the parameter set yielding the best model-to-data fit). There are, however, other situations that require solving optimisation problems. Typically, these involve the creation of a custom cost function, which optimum can then be found using Optimization.jl. In this tutorial we will describe this process, demonstrating how parameter space can be searched to find values that achieve a desired system behaviour. A more throughout description on how to solve these problems are provided by <a href="https://docs.sciml.ai/Optimization/stable/">Optimization.jl&#39;s documentation</a> and the literature <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. </p><h2 id="Maximising-the-pulse-amplitude-of-an-incoherent-feed-forward-loop."><a class="docs-heading-anchor" href="#Maximising-the-pulse-amplitude-of-an-incoherent-feed-forward-loop.">Maximising the pulse amplitude of an incoherent feed forward loop.</a><a id="Maximising-the-pulse-amplitude-of-an-incoherent-feed-forward-loop.-1"></a><a class="docs-heading-anchor-permalink" href="#Maximising-the-pulse-amplitude-of-an-incoherent-feed-forward-loop." title="Permalink"></a></h2><p>Incoherent feedforward loops (network motifs where a single component both activates and deactivates a downstream component) are able to generate pulses in response to step inputs <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. In this tutorial we will consider such an incoherent feedforward loop, attempting to generate a system with as prominent a response pulse as possible. Our model consists of 3 species: <span>$X$</span> (the input node), <span>$Y$</span> (an intermediary), and <span>$Z$</span> (the output node). In it, <span>$X$</span> activates the production of both <span>$Y$</span> and <span>$Z$</span>, with <span>$Y$</span> also deactivating <span>$Z$</span>. When <span>$X$</span> is activated, there will be a brief time window where <span>$Y$</span> is still inactive, and <span>$Z$</span> is activated. However, as <span>$Y$</span> becomes active, it will turn <span>$Z$</span> off. This creates a pulse of <span>$Z$</span> activity.</p><pre><code class="language-julia hljs">using Catalyst
incoherent_feed_forward = @reaction_network begin
    pX, 0 --&gt; X
    pY*X, 0 --&gt; Y
    pZ*X/Y, 0 --&gt; Z
    1.0, (X,Y,Z) --&gt; 0
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightarrow{pX} \mathrm{X} \\
\varnothing &amp;\xrightarrow{X pY} \mathrm{Y} \\
\varnothing &amp;\xrightarrow{\frac{X pZ}{Y}} \mathrm{Z} \\
\mathrm{X} &amp;\xrightarrow{1.0} \varnothing \\
\mathrm{Y} &amp;\xrightarrow{1.0} \varnothing \\
\mathrm{Z} &amp;\xrightarrow{1.0} \varnothing  
 \end{align*}
 \]</p><p>To demonstrate this pulsing behaviour we will simulate the system for an example parameter set. First, we will create the <code>ODEProblem</code> corresponding to our simulation. Here, we select an initial condition (<code>u0</code>) so the system begins in a steady state.</p><pre><code class="language-julia hljs">using DifferentialEquations
@unpack X, Y, Z, pX, pY, pZ = incoherent_feed_forward
example_p = [pX =&gt; 0.1, pY =&gt; 1.0, pZ =&gt; 1.0]
example_u0 = [X =&gt; 0.1, Y =&gt; 0.1, Z =&gt; 1.0]
ode_prob = ODEProblem(incoherent_feed_forward, example_u0, (0.0,50.0), example_p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem with uType Vector{Float64} and tType Float64. In-place: true
timespan: (0.0, 50.0)
u0: 3-element Vector{Float64}:
 0.1
 0.1
 1.0</code></pre><p>To trigger the activation of <span>$X$</span> we will use a <a href="../../catalyst_applications/advanced_simulations/#advanced_simulations_callbacks">callback</a>, increasing its production rate (<span>$pX$</span>) by a factor of <span>$10$</span> at the time <span>$t=10.0$</span>. We supply the callback to our simulation, and plot the result:</p><pre><code class="language- hljs">using Plots
activation_cb = PresetTimeCallback([10.0], int -&gt; int[pX] *= 10.0)
sol = solve(ode_prob, Tsit5(); callback=activation_cb)
plot(sol; lw=4)</code></pre><p>Here we note that, while <span>$X$</span> and <span>$Y$</span> reach new steady state levels in response to the increase in <span>$pX$</span>, <span>$Z$</span> resumes to its initial concentration after the pulse.</p><p>We will now attempt to find the parameter set <span>$(pX,pY,pZ)$</span> which maximises the response pulse amplitude (defined by the maximum activity of <span>$Z$</span> subtracted by its steady state activity). To do this, we create a custom cost function:</p><pre><code class="language-julia hljs">function pulse_amplitude(p, _)
    u0_new = [X =&gt; p[1], Y =&gt; p[1]*p[2], Z =&gt; p[3]/p[2]^2]
    ode_prob_local = remake(ode_prob; u0=u0_new, p=p)
    sol = solve(ode_prob_local, Tsit5(); callback=activation_cb, verbose=false, maxiters=10000)
    SciMLBase.successful_retcode(sol) || return Inf
    return -(maximum(sol[:Z])-sol[:Z][1])
end
nothing # here</code></pre><p>This cost function takes two arguments (a parameter value <code>p</code>, and an additional one which we will ignore here but discuss later). It first calculates the new initial steady state concentration (for the given parameter set), and then creates an updated <code>ODEProblem</code> using it as initial conditions and the, to the cost function provided, input parameter set. While we could create a new <code>ODEProblem</code> within the cost function, cost functions are often called a large number of times during the optimisation process (making performance important). Here, using <a href="inverse_problems/@id simulation_structure_interfacing_remake"><code>remake</code> on a previously created <code>ODEProblem</code></a> is more performant than creating a new one. Next, we simulate our model (remembering to use the activation callback). Just like <a href="../optimization_ode_param_fitting/#optimization_parameter_fitting">when using Optimization.jl to fit parameters to data</a>, we use the <code>verbose=false</code> options to prevent unnecessary printouts, and a reduced <code>maxiters</code> value to reduce time spent simulating (for the model) unsuitable parameter sets. We also use <code>SciMLBase.successful_retcode(sol)</code> to check whether the simulation return code indicates a successful simulation (and if it did not, returns a large cost function value). Finally, Optimization.jl finds the function&#39;s <em>minimum value</em>, so to find the <em>maximum</em> relative pulse amplitude, we make our cost function return the negative pulse amplitude.</p><p>Just like for <a href="../optimization_ode_param_fitting/#optimization_parameter_fitting">parameter fitting</a>, we create a <code>OptimizationProblem</code> using our cost function, and some initial guess of the parameter value. We also set upper and lower bounds for each parameter using the <code>lb</code> and <code>ub</code> optional arguments (in this case limiting each parameter&#39;s value to the interval <span>$(0.1,10.0)$</span>).</p><pre><code class="language-julia hljs">using Optimization
initial_guess = [1.0, 1.0, 1.0]
opt_prob = OptimizationProblem(pulse_amplitude, initial_guess; lb = [1e-1, 1e-1, 1e-1], ub = [1e1, 1e1, 1e1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OptimizationProblem. In-place: true
u0: 3-element Vector{Float64}:
 1.0
 1.0
 1.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As described in a <a href="../optimization_ode_param_fitting/#optimization_parameter_fitting">previous section on Optimization.jl</a>, <code>OptimizationProblem</code>s do not support setting parameter values using maps. We must instead set <code>initial_guess</code>&#39;s values using a vector. Here, the i&#39;th value corresponds to the value of the i&#39;th parameter in the <code>parameters(incoherent_feed_forward)</code> vector.</p></div></div><p>As <a href="../optimization_ode_param_fitting/#optimization_parameter_fitting">previously described</a>, Optimization.jl supports a wide range of optimisation algorithms. Here we use one from <a href="https://github.com/robertfeldt/BlackBoxOptim.jl">BlackBoxOptim.jl</a>:</p><pre><code class="language- hljs">using OptimizationBBO
opt_sol = solve(opt_prob, BBO_adaptive_de_rand_1_bin_radiuslimited())</code></pre><p>Finally, we plot a simulation using the found parameter set (stored in <code>opt_sol.u</code>):</p><pre><code class="language- hljs">u0_result = [X =&gt; opt_sol.u[1], Y =&gt; opt_sol.u[1]*opt_sol.u[2], Z =&gt; opt_sol.u[3]/opt_sol.u[2]]
oprob_result = remake(ode_prob; u0=u0_result, p=opt_sol.u)
sol_result = solve(oprob_result, Tsit5(); callback=activation_cb)
plot(sol_result; lw=4, idxs=Z)</code></pre><p>For this model, it turns out that <span>$Z$</span>&#39;s maximum pulse amplitude is equal to twice its steady state concentration. Hence, the maximisation of its pulse amplitude is equivalent to maximising its steady state concentration.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Especially if you check Optimization.jl&#39;s documentation, you will note that cost functions have the <code>f(u,p)</code> form. This is because <code>OptimizationProblem</code>s (like e.g. <code>ODEProblem</code>s) can take both variables (which can be varied in the optimisation problem), but also parameters that are fixed. In our case, the <em>optimisation variables</em> correspond to our <em>model parameters</em>. Hence, our model parameter values ar the <code>u</code> input. This is also why we find the optimisation solution (our optimised parameter set) in <code>opt_sol</code>&#39;s <code>u</code> field. Our optimisation problem does not actually have any parameters, hence, the second argument of <code>pulse_amplitude</code> is unused (that is why we call it <code>_</code>, a name commonly indicating unused function arguments). </p><p>There are several modifications to our problem where it would actually have parameters. E.g. our model might have had additional parameters (e.g. a degradation rate) which we would like to keep fixed throughout the optimisation process. If we then would like to run the optimisation process for several different values of these fixed parameters, we could have made them parameters to our <code>OptimizationProblem</code> (and their values provided as a third argument, after <code>initial_guess</code>).</p></div></div><h2 id="Utilising-automatic-differentiation"><a class="docs-heading-anchor" href="#Utilising-automatic-differentiation">Utilising automatic differentiation</a><a id="Utilising-automatic-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Utilising-automatic-differentiation" title="Permalink"></a></h2><p>Optimisation methods can be divided into differentiation-free and differentiation-based optimisation methods. E.g. consider finding the minimum of the function <span>$f(x) = x^2$</span>, given some initial guess of <span>$x$</span>. Here, we can simply compute the differential and descend along it until we find <span>$x=0$</span> (admittedly, for this simple problem the minimum can be computed directly). This principle forms the basis of optimisation methods such as gradient descent, which utilises information of a function&#39;s differential to minimise it. When attempting to find a global minimum, to avoid getting stuck in local minimums, these methods are often augmented by additional routines. While the differentiation of most algebraic functions is trivial, it turns out that even complicated functions (such as the one we used above) can be differentiated computationally through the use of <a href="https://en.wikipedia.org/wiki/Automatic_differentiation"><em>automatic differentiation</em> (AD)</a>.</p><p>Through packages such as <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>, <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff.jl</a>, and <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a>, Julia supports AD for most code. Specifically for code including simulation of differential equations, differentiation is supported by <a href="https://github.com/SciML/SciMLSensitivity.jl">SciMLSensitivity.jl</a>. Generally, AD can be used without specific knowledge from the user, however, it requires an additional step in the construction of our <code>OptimizationProblem</code>. Here, we create a <a href="https://docs.sciml.ai/Optimization/stable/API/optimization_function/#optfunction">specialised <code>OptimizationFunction</code> from our cost function</a>. To it, we will also provide our choice of AD method. There are <a href="https://docs.sciml.ai/Optimization/stable/API/optimization_function/#Automatic-Differentiation-Construction-Choice-Recommendations">several alternatives</a>, and in our case we will use <code>AutoForwardDiff()</code> (a good choice for small optimisation problems). We can then create a new <code>OptimizationProblem</code> using our updated cast function:</p><pre><code class="language-julia hljs">opt_func = OptimizationFunction(pulse_amplitude, AutoForwardDiff())
opt_prob = OptimizationProblem(opt_func, initial_guess; lb = [1e-1, 1e-1, 1e-1], ub = [1e1, 1e1, 1e1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OptimizationProblem. In-place: true
u0: 3-element Vector{Float64}:
 1.0
 1.0
 1.0</code></pre><p>Finally, we can find the optimum using some differentiation-based optimisation methods. Here we will use <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>&#39;s <code>BFGS</code> method:</p><pre><code class="language- hljs">using OptimizationOptimJL
opt_sol = solve(opt_prob, OptimizationOptimJL.BFGS())</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://algorithmsbook.com/optimization/files/optimization.pdf">Mykel J. Kochenderfer, Tim A. Wheeler <em>Algorithms for Optimization</em>, The MIT Press (2019).</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2896310/">Lea Goentoro, Oren Shoval, Marc W Kirschner, Uri Alon <em>The incoherent feedforward loop can provide fold-change detection in gene regulation</em>, Molecular Cell (2009).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../petab_ode_param_fitting/">« Parameter Fitting for ODEs using PEtab.jl</a><a class="docs-footer-nextpage" href="../structural_identifiability/">Structural Identifiability Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 2 February 2024 15:51">Friday 2 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
