var documenterSearchIndex = {"docs":
[{"location":"api/#Catalyst.jl-API","page":"API","title":"Catalyst.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Catalyst","category":"page"},{"location":"api/#Reaction-network-generation-and-representation","page":"API","title":"Reaction network generation and representation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Catalyst provides the @reaction_network macro for generating a complete network, stored as a ReactionSystem, which in turn is composed of Reactions. ReactionSystems can be converted to other ModelingToolkit.AbstractSystems, including a ModelingToolkit.ODESystem, ModelingToolkit.SDESystem, or ModelingToolkit.JumpSystem.","category":"page"},{"location":"api/","page":"API","title":"API","text":"When using the @reaction_network macro, Catalyst will automatically attempt to detect what is a species and what is a parameter. Everything that appear as a substrate or product in some reaction will be treated as a species, while all remaining symbols will be considered parameters (corresponding to those symbols that only appear within rate expressions and/or as stoichiometric coefficients). I.e. in","category":"page"},{"location":"api/","page":"API","title":"API","text":"rn = @reaction_network begin\n    k*X, Y --> W\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"Y and W will all be classified as chemical species, while k and X will be classified as parameters.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The ReactionSystem generated by the @reaction_network macro is a ModelingToolkit.AbstractSystem that symbolically represents a system of chemical reactions. In some cases it can be convenient to bypass the macro and directly generate a collection of symbolic Reactions and a corresponding ReactionSystem encapsulating them. Below we illustrate with a simple SIR example how a system can be directly constructed, and demonstrate how to then generate from the ReactionSystem and solve corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models.","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Catalyst, OrdinaryDiffEq, StochasticDiffEq, JumpProcesses, Plots\nt = default_t()\n@parameters β γ\n@species S(t) I(t) R(t)\n\nrxs = [Reaction(β, [S,I], [I], [1,1], [2])\n       Reaction(γ, [I], [R])]\n@named rs = ReactionSystem(rxs, t)\nrs = complete(rs)\n\nu₀map    = [S => 999.0, I => 1.0, R => 0.0]\nparammap = [β => 1/10000, γ => 0.01]\ntspan    = (0.0, 250.0)\n\n# solve as ODEs\nodesys = convert(ODESystem, rs)\nodesys = complete(odesys)\noprob = ODEProblem(odesys, u₀map, tspan, parammap)\nsol = solve(oprob, Tsit5())\np1 = plot(sol, title = \"ODE\")\n\n# solve as SDEs\nsdesys = convert(SDESystem, rs)\nsdesys = complete(sdesys)\nsprob = SDEProblem(sdesys, u₀map, tspan, parammap)\nsol = solve(sprob, EM(), dt=.01, saveat = 2.0)\np2 = plot(sol, title = \"SDE\")\n\n# solve as jump process\njumpsys = convert(JumpSystem, rs)\njumpsys = complete(jumpsys)\nu₀map    = [S => 999, I => 1, R => 0]\ndprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)\njprob = JumpProblem(jumpsys, dprob, Direct(); save_positions = (false,false))\nsol = solve(jprob, SSAStepper(), saveat = 2.0)\np3 = plot(sol, title = \"jump\")\n\nplot(p1, p2, p3; layout = (3,1))","category":"page"},{"location":"api/","page":"API","title":"API","text":"@reaction_network\nmake_empty_network\n@reaction\nReaction\nReactionSystem","category":"page"},{"location":"api/#Catalyst.@reaction_network","page":"API","title":"Catalyst.@reaction_network","text":"@reaction_network\n\nGenerates a ReactionSystem that encodes a chemical reaction network.\n\nSee The Reaction DSL documentation for details on parameters to the macro.\n\nExamples:\n\n# a basic SIR model, with name SIR\nsir_model = @reaction_network SIR begin\n    c1, s + i --> 2i\n    c2, i --> r\nend\n\n# a basic SIR model, with random generated name\nsir_model = @reaction_network begin\n    c1, s + i --> 2i\n    c2, i --> r\nend\n\n# an empty network with name empty\nemptyrn = @reaction_network empty\n\n# an empty network with random generated name\nemptyrn = @reaction_network\n\nReactionSystems generated through @reaction_network are complete.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Catalyst.make_empty_network","page":"API","title":"Catalyst.make_empty_network","text":"make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))\n\nConstruct an empty ReactionSystem. iv is the independent variable, usually time, and name is the name to give the ReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.@reaction","page":"API","title":"Catalyst.@reaction","text":"@reaction\n\nGenerates a single Reaction object.\n\nExamples:\n\nrx = @reaction k*v, A + B --> C + D\n\n# is equivalent to\nt = default_t()\n@parameters k v\n@species A(t) B(t) C(t) D(t)\nrx == Reaction(k*v, [A,B], [C,D])\n\nHere k and v will be parameters and A, B, C and D will be variables. Interpolation of existing parameters/variables also works\n\nt = default_t()\n@parameters k b\n@species A(t)\nex = k*A^2 + t\nrx = @reaction b*$ex*$A, $A --> C\n\nNotes:\n\nAny symbols arising in the rate expression that aren't interpolated are treated as\n\nparameters. In the reaction part (α*A + B --> C + D), coefficients are treated as parameters, e.g. α, and rightmost symbols as species, e.g. A,B,C,D.\n\nWorks with any single arrow types supported by @reaction_network.\nInterpolation of Julia variables into the macro works similar to the @reaction_network\n\nmacro. See The Reaction DSL tutorial for more details.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Catalyst.Reaction","page":"API","title":"Catalyst.Reaction","text":"struct Reaction{S, T}\n\nOne chemical reaction.\n\nFields\n\nrate: The rate function (excluding mass action terms).\nsubstrates: Reaction substrates.\nproducts: Reaction products.\nsubstoich: The stoichiometric coefficients of the reactants.\nprodstoich: The stoichiometric coefficients of the products.\nnetstoich: The net stoichiometric coefficients of all species changed by the reaction.\nonly_use_rate: false (default) if rate should be multiplied by mass action terms to give the rate law. true if rate represents the full reaction rate law.\n\nmetadata: Contain additional data, such whenever the reaction have a specific noise-scaling expression for the chemical Langevin equation.\n\nExamples\n\nusing Catalyst\nt = default_t()\n@parameters k[1:20]\n@species A(t) B(t) C(t) D(t)\nrxs = [Reaction(k[1], nothing, [A]),            # 0 -> A\n       Reaction(k[2], [B], nothing),            # B -> 0\n       Reaction(k[3],[A],[C]),                  # A -> C\n       Reaction(k[4], [C], [A,B]),              # C -> A + B\n       Reaction(k[5], [C], [A], [1], [2]),      # C -> A + A\n       Reaction(k[6], [A,B], [C]),              # A + B -> C\n       Reaction(k[7], [B], [A], [2], [1]),      # 2B -> A\n       Reaction(k[8], [A,B], [A,C]),            # A + B -> A + C\n       Reaction(k[9], [A,B], [C,D]),            # A + B -> C + D\n       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -> C + D\n       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -> A + B\n       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -> 2C + 3D\n       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -> 0\n       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -> 2A\n       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -> 0 with custom rate\n       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -> B with custom rate.\n       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -> D with non constant rate.\n       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -> 2B with non constant rate.\n       Reaction(k[19]*t, [A], [B]),                                # A -> B with non constant rate.\n       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -> 2C with non constant rate.\n  ]\n\nNotes:\n\nnothing can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to nothing.\nThe three-argument form assumes all reactant and product stoichiometric coefficients are one.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catalyst.ReactionSystem","page":"API","title":"Catalyst.ReactionSystem","text":"struct ReactionSystem{V<:Catalyst.NetworkProperties} <: AbstractTimeDependentSystem\n\nA system of chemical reactions.\n\nFields\n\neqs: The equations (reactions and algebraic/differential) defining the system.\nrxs: The Reactions defining the system.\niv: Independent variable (usually time).\nsivs: Spatial independent variables\nunknowns: All dependent (unknown) variables, species and non-species. Must not contain the independent variable.\nspecies: Dependent unknown variables representing species\nps: Parameter variables. Must not contain the independent variable.\nvar_to_name: Maps Symbol to corresponding variable.\nobserved: Equations for observed variables.\nname: The name of the system\nsystems: Internal sub-systems\ndefaults: The default values to use when initial conditions and/or parameters are not supplied in ODEProblem.\n\nconnection_type: Type of the system\nnetworkproperties: NetworkProperties object that can be filled in by API functions. INTERNAL – not considered part of the public API.\ncombinatoric_ratelaws: Sets whether to use combinatoric scalings in rate laws. true by default.\ncontinuous_events: continuous_events: A Vector{SymbolicContinuousCallback} that model events. The integrator will use root finding to guarantee that it steps at each zero crossing.\n\ndiscrete_events: discrete_events: A Vector{SymbolicDiscreteCallback} that models events. Symbolic analog to SciMLBase.DiscreteCallback that executes an affect when a given condition is true at the end of an integration step.\n\nmetadata: Metadata for the system, to be used by downstream packages.\n\ncomplete: complete: if a model sys is complete, then sys.x no longer performs namespacing.\n\nExample\n\nContinuing from the example in the Reaction definition:\n\n# simple constructor that infers species and parameters\n@named rs = ReactionSystem(rxs, t)\n\n# allows specification of species and parameters\n@named rs = ReactionSystem(rxs, t, [A,B,C,D], k)\n\nKeyword Arguments:\n\nobserved::Vector{Equation}, equations specifying observed variables.\nsystems::Vector{AbstractSystems}, vector of sub-systems. Can be ReactionSystems, ODESystems, or NonlinearSystems.\nname::Symbol, the name of the system (must be provided, or @named must be used).\ndefaults::Dict, a dictionary mapping parameters to their default values and species to their default initial values.\nchecks = true, boolean for whether to check units.\nnetworkproperties = NetworkProperties(), cache for network properties calculated via API functions.\ncombinatoric_ratelaws = true, sets the default value of combinatoric_ratelaws used in calls to convert or calling various problem types with the ReactionSystem.\nbalanced_bc_check = true, sets whether to check that BC species appearing in reactions are balanced (i.e appear as both a substrate and a product with the same stoichiometry).\n\nNotes:\n\nReactionSystems currently do rudimentary unit checking, requiring that all species have the same units, and all reactions have rate laws with units of (species units) / (time units). Unit checking can be disabled by passing the keyword argument checks=false.\n\n\n\n\n\n","category":"type"},{"location":"api/#api_accessor_functions","page":"API","title":"ModelingToolkit and Catalyst accessor functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A ReactionSystem is an instance of a ModelingToolkit.AbstractTimeDependentSystem, and has a number of fields that can be accessed using the Catalyst API and the ModelingToolkit.jl Abstract System Interface. Below we overview these components.","category":"page"},{"location":"api/","page":"API","title":"API","text":"There are three basic sets of convenience accessors that will return information either from a top-level system, the top-level system and all sub-systems that are also ReactionSystems (i.e. the full reaction-network), or the top-level system, all subs-systems, and all constraint systems (i.e. the full model). To retrieve info from just a base ReactionSystem rn, ignoring sub-systems of rn, one can use the ModelingToolkit accessors (these provide direct access to the corresponding internal fields of the ReactionSystem)","category":"page"},{"location":"api/","page":"API","title":"API","text":"ModelingToolkit.get_unknowns(rn) is a vector that collects all the species defined within rn, ordered by species and then non-species variables.\nCatalyst.get_species(rn) is a vector of all the species variables in the system. The entries in get_species(rn) correspond to the first length(get_species(rn)) components in get_unknowns(rn).\nModelingToolkit.get_ps(rn) is a vector that collects all the parameters defined within reactions in rn.\nModelingToolkit.get_eqs(rn) is a vector that collects all the Reactions and Symbolics.Equation defined within rn, ordering all Reactions before Equations.\nCatalyst.get_rxs(rn) is a vector of all the Reactions in rn, and corresponds to the first length(get_rxs(rn)) entries in get_eqs(rn).\nModelingToolkit.get_iv(rn) is the independent variable used in the system (usually t to represent time).\nModelingToolkit.get_systems(rn) is a vector of all sub-systems of rn.\nModelingToolkit.get_defaults(rn) is a dictionary of all the default values for parameters and species in rn.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The preceding accessors do not allocate, directly accessing internal fields of the ReactionSystem.","category":"page"},{"location":"api/","page":"API","title":"API","text":"To retrieve information from the full reaction network represented by a system rn, which corresponds to information within both rn and all sub-systems, one can call:","category":"page"},{"location":"api/","page":"API","title":"API","text":"ModelingToolkit.unknowns(rn) returns all species and variables across the system, all sub-systems, and all constraint systems. Species are ordered before non-species variables in unknowns(rn), with the first numspecies(rn) entires in unknowns(rn) being the same as species(rn).\nspecies(rn) is a vector collecting all the chemical species within the system and any sub-systems that are also ReactionSystems.\nModelingToolkit.parameters(rn) returns all parameters across the system, all sub-systems, and all constraint systems.\nModelingToolkit.equations(rn) returns all Reactions and all Symbolics.Equations defined across the system, all sub-systems, and all constraint systems. Reactions are ordered ahead of Equations with the first numreactions(rn) entries in equations(rn) being the same as reactions(rn).\nreactions(rn) is a vector of all the Reactions within the system and any sub-systems that are also ReactionSystems.","category":"page"},{"location":"api/","page":"API","title":"API","text":"These accessors will generally allocate new arrays to store their output unless there are no subsystems. In the latter case the usually return the same vector as the corresponding get_* function.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Below we list the remainder of the Catalyst API accessor functions mentioned above.","category":"page"},{"location":"api/#Basic-system-properties","page":"API","title":"Basic system properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"See Programmatic Construction of Symbolic Reaction Systems for examples and ModelingToolkit and Catalyst Accessor Functions for more details on the basic accessor functions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"species\nnonspecies\nreactions\nnonreactions\nnumspecies\nnumparams\nnumreactions\nspeciesmap\nparamsmap\nisspecies\nisautonomous\nCatalyst.isconstant\nCatalyst.isbc","category":"page"},{"location":"api/#Catalyst.species","page":"API","title":"Catalyst.species","text":"species(network)\n\nGiven a ReactionSystem, return a vector of all species defined in the system and any subsystems that are of type ReactionSystem. To get the species and non-species variables in the system and all subsystems, including non-ReactionSystem subsystems, uses unknowns(network).\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is non-empty will allocate.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.nonspecies","page":"API","title":"Catalyst.nonspecies","text":"nonspecies(network)\n\nReturn the non-species variables within the network, i.e. those unknowns for which isspecies == false.\n\nNotes:\n\nAllocates a new array to store the non-species variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.reactions","page":"API","title":"Catalyst.reactions","text":"reactions(network)\n\nGiven a ReactionSystem, return a vector of all Reactions in the system.\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is not empty, will allocate.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.nonreactions","page":"API","title":"Catalyst.nonreactions","text":"nonreactions(network)\n\nReturn the non-reaction equations within the network (i.e. algebraic and differnetial equations).\n\nNotes:\n\nAllocates a new array to store the non-species variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.numspecies","page":"API","title":"Catalyst.numspecies","text":"numspecies(network)\n\nReturn the total number of species within the given ReactionSystem and subsystems that are ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.numparams","page":"API","title":"Catalyst.numparams","text":"numparams(network)\n\nReturn the total number of parameters within the given system and all subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.numreactions","page":"API","title":"Catalyst.numreactions","text":"numreactions(network)\n\nReturn the total number of reactions within the given ReactionSystem and subsystems that are ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.speciesmap","page":"API","title":"Catalyst.speciesmap","text":"speciesmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping species that participate in Reactions to their index within species(network).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.paramsmap","page":"API","title":"Catalyst.paramsmap","text":"paramsmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping from all parameters that appear within the system to their index within parameters(network).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isspecies","page":"API","title":"Catalyst.isspecies","text":"isspecies(s)\n\nTests if the given symbolic variable corresponds to a chemical species.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isautonomous","page":"API","title":"Catalyst.isautonomous","text":"isautonomous(rs::ReactionSystem)\n\nChecks if a system is autonomous (i.e. no rate or equation depend on the independent variable(s)). Example:\n\nrs1 = @reaction_system\n    (p,d), 0 <--> X\nend\nisautonomous(rs1) # Returns `true`.\n\nrs2 = @reaction_system\n    (p/t,d), 0 <--> X\nend\nisautonomous(rs2) # Returns `false`.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isconstant","page":"API","title":"Catalyst.isconstant","text":"Catalyst.isconstant(s)\n\nTests if the given symbolic variable corresponds to a constant species.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isbc","page":"API","title":"Catalyst.isbc","text":"Catalyst.isbc(s)\n\nTests if the given symbolic variable corresponds to a boundary condition species.\n\n\n\n\n\n","category":"function"},{"location":"api/#Basic-reaction-properties","page":"API","title":"Basic reaction properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ismassaction\ndependents\ndependants\nsubstoichmat\nprodstoichmat\nnetstoichmat\nreactionrates","category":"page"},{"location":"api/#Catalyst.ismassaction","page":"API","title":"Catalyst.ismassaction","text":"ismassaction(rx, rs; rxvars = get_variables(rx.rate),\n                              haveivdep = nothing,\n                              unknownset = Set(unknowns(rs)),\n                              ivset = nothing)\n\nTrue if a given reaction is of mass action form, i.e. rx.rate does not depend on any chemical species that correspond to unknowns of the system, and does not depend explicitly on the independent variable (usually time).\n\nArguments\n\nrx, the Reaction.\nrs, a ReactionSystem containing the reaction.\nOptional: rxvars, Variables which are not in rxvars are ignored as possible dependencies.\nOptional: haveivdep, true if the Reaction rate field explicitly depends on any independent variable (i.e. t or for spatial systems x,y,etc). If not set, will be automatically calculated.\nOptional: unknownset, set of unknowns which if the rxvars are within mean rx is non-mass action.\nOptional: ivset, a Set of the independent variables of the system. If not provided and the system is spatial, i.e. isspatial(rs) == true, it will be created with all the spatial variables and the time variable. If the rate expression contains any element of ivset, then ismassaction(rx,rs) == false. Pass a custom set to control this behavior.\n\nNotes:\n\nNon-integer stoichiometry is treated as non-mass action. This includes symbolic variables/terms or floating point numbers for stoichiometric coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.dependents","page":"API","title":"Catalyst.dependents","text":"dependents(rx, network)\n\nGiven a Reaction and a ReactionSystem, return a vector of the non-constant species and variables the reaction rate law depends on. e.g., for\n\nk*W, 2X + 3Y --> 5Z + W\n\nthe returned vector would be [W(t),X(t),Y(t)].\n\nNotes:\n\nAllocates\nDoes not check for dependents within any subsystems.\nConstant species are not considered dependents since they are internally treated as parameters.\nIf the rate expression depends on a non-species unknown variable that will be included in the dependents, i.e. in\nt = default_t()\n@parameters k\n@variables V(t)\n@species A(t) B(t) C(t)\nrx = Reaction(k*V, [A, B], [C])\n@named rs = ReactionSystem([rx], t)\nissetequal(dependents(rx, rs), [A,B,V]) == true\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.dependants","page":"API","title":"Catalyst.dependants","text":"dependents(rx, network)\n\nSee documentation for dependents.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.substoichmat","page":"API","title":"Catalyst.substoichmat","text":"substoichmat(rn; sparse=false)\n\nReturns the substrate stoichiometry matrix, S, with S_i j the stoichiometric coefficient of the ith substrate within the jth reaction.\n\nNote:\n\nSet sparse=true for a sparse matrix representation\nNote that constant species are not considered substrates, but just components that modify the associated rate law.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.prodstoichmat","page":"API","title":"Catalyst.prodstoichmat","text":"prodstoichmat(rn; sparse=false)\n\nReturns the product stoichiometry matrix, P, with P_i j the stoichiometric coefficient of the ith product within the jth reaction.\n\nNote:\n\nSet sparse=true for a sparse matrix representation\nNote that constant species are not treated as products, but just components that modify the associated rate law.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.netstoichmat","page":"API","title":"Catalyst.netstoichmat","text":"netstoichmat(rn, sparse=false)\n\nReturns the net stoichiometry matrix, N, with N_i j the net stoichiometric coefficient of the ith species within the jth reaction.\n\nNotes:\n\nSet sparse=true for a sparse matrix representation\nCaches the matrix internally within rn so subsequent calls are fast.\nNote that constant species are not treated as reactants, but just components that modify the associated rate law. As such they do not contribute to the net stoichiometry matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.reactionrates","page":"API","title":"Catalyst.reactionrates","text":"reactionrates(network)\n\nGiven a ReactionSystem, returns a vector of the symbolic reaction rates for each reaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#api_network_extension_and_modification","page":"API","title":"Functions to extend or modify a network","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ReactionSystems can be programmatically extended using ModelingToolkit.extend and ModelingToolkit.compose.","category":"page"},{"location":"api/","page":"API","title":"API","text":"setdefaults!\nModelingToolkit.extend\nModelingToolkit.compose\nCatalyst.flatten","category":"page"},{"location":"api/#Catalyst.setdefaults!","page":"API","title":"Catalyst.setdefaults!","text":"setdefaults!(rn, newdefs)\n\nSets the default (initial) values of parameters and species in the ReactionSystem, rn.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsetdefaults!(sir, [:S => 999.0, :I => 1.0, :R => 1.0, :β => 1e-4, :ν => .01])\n\n# or\nt = default_t()\n@parameter β ν\n@species S(t) I(t) R(t)\nsetdefaults!(sir, [S => 999.0, I => 1.0, R => 0.0, β => 1e-4, ν => .01])\n\ngives initial/default values to each of S, I and β\n\nNotes:\n\nCan not be used to set default values for species, variables or parameters of subsystems or constraint systems. Either set defaults for those systems directly, or flatten to collate them into one system before setting defaults.\nDefaults can be specified in any iterable container of symbols to value pairs or symbolics to value pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.extend","page":"API","title":"ModelingToolkit.extend","text":"extend(\n    sys::ModelingToolkit.AbstractSystem,\n    basesys::ModelingToolkit.AbstractSystem;\n    name,\n    gui_metadata\n) -> ReactionSystem{Catalyst.NetworkProperties{Int64, V}} where V<:SymbolicUtils.BasicSymbolic{Real}\n\n\nextend the basesys with sys, the resulting system would inherit sys's name by default.\n\n\n\n\n\nModelingToolkit.extend(sys::AbstractSystem, rs::ReactionSystem; name::Symbol=nameof(sys))\n\nExtends the indicated ReactionSystem with another AbstractSystem.\n\nNotes:\n\nThe AbstractSystem being added in must be an ODESystem, NonlinearSystem, or ReactionSystem currently.\nReturns a new ReactionSystem and does not modify rs.\nBy default, the new ReactionSystem will have the same name as sys.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.compose","page":"API","title":"ModelingToolkit.compose","text":"compose(sys, systems; name)\n\n\ncompose multiple systems together. The resulting system would inherit the first system's name.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.flatten","page":"API","title":"ModelingToolkit.flatten","text":"Catalyst.flatten(rs::ReactionSystem)\n\nMerges all subsystems of the given ReactionSystem up into rs.\n\nNotes:\n\nReturns a new ReactionSystem that represents the flattened system.\nAll Reactions within subsystems are namespaced and merged into the list of Reactions of rs. The merged list is then available as reactions(rs).\nAll algebraic and differential equations are merged in the equations of rs.\nCurrently only ReactionSystems, NonlinearSystems and ODESystems are supported as sub-systems when flattening.\nrs.networkproperties is reset upon flattening.\nThe default value of combinatoric_ratelaws will be the logical or of all ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#Network-analysis-and-representations","page":"API","title":"Network analysis and representations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).","category":"page"},{"location":"api/","page":"API","title":"API","text":"conservationlaws\nconservedquantities\nconservedequations\nconservationlaw_constants\nReactionComplexElement\nReactionComplex\nreactioncomplexmap\nreactioncomplexes\nincidencemat\ncomplexstoichmat\ncomplexoutgoingmat\nincidencematgraph\nlinkageclasses\ndeficiency\nsubnetworks\nlinkagedeficiencies\nisreversible\nisweaklyreversible\nreset_networkproperties!","category":"page"},{"location":"api/#Catalyst.conservationlaws","page":"API","title":"Catalyst.conservationlaws","text":"conservationlaws(netstoichmat::AbstractMatrix)::Matrix\n\nGiven the net stoichiometry matrix of a reaction system, computes a matrix of conservation laws, each represented as a row in the output.\n\n\n\n\n\nconservationlaws(rs::ReactionSystem)\n\nReturn the conservation law matrix of the given ReactionSystem, calculating it if it is not already stored within the system, or returning an alias to it.\n\nNotes:\n\nThe first time being called it is calculated and cached in rn, subsequent calls should be fast.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.conservedquantities","page":"API","title":"Catalyst.conservedquantities","text":"conservedquantities(state, cons_laws)\n\nCompute conserved quantities for a system with the given conservation laws.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.conservedequations","page":"API","title":"Catalyst.conservedequations","text":"conservedequations(rn::ReactionSystem)\n\nCalculate symbolic equations from conservation laws, writing dependent variables as functions of independent variables and the conservation law constants.\n\nNotes:\n\nCaches the resulting equations in rn, so will be fast on subsequent calls.\n\nExamples:\n\nrn = @reaction_network begin\n    k, A + B --> C\n    k2, C --> A + B\n    end\nconservedequations(rn)\n\ngives\n\n2-element Vector{Equation}:\n B(t) ~ A(t) + Γ[1]\n C(t) ~ Γ[2] - A(t)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.conservationlaw_constants","page":"API","title":"Catalyst.conservationlaw_constants","text":"conservationlaw_constants(rn::ReactionSystem)\n\nCalculate symbolic equations from conservation laws, writing the conservation law constants in terms of the dependent and independent variables.\n\nNotes:\n\nCaches the resulting equations in rn, so will be fast on subsequent calls.\n\nExamples:\n\nrn = @reaction_network begin\n    k, A + B --> C\n    k2, C --> A + B\n    end\nconservationlaw_constants(rn)\n\ngives\n\n2-element Vector{Equation}:\n Γ[1] ~ B(t) - A(t)\n Γ[2] ~ A(t) + C(t)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.ReactionComplexElement","page":"API","title":"Catalyst.ReactionComplexElement","text":"struct ReactionComplexElement{T}\n\nOne reaction complex element\n\nFields\n\nspeciesid: The integer id of the species representing this element.\nspeciesstoich: The stoichiometric coefficient of this species.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catalyst.ReactionComplex","page":"API","title":"Catalyst.ReactionComplex","text":"struct ReactionComplex{V<:Integer} <: AbstractArray{Catalyst.ReactionComplexElement{V<:Integer}, 1}\n\nOne reaction complex.\n\nFields\n\nspeciesids: The integer ids of all species participating in this complex.\nspeciesstoichs: The stoichiometric coefficients of all species participating in this complex.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catalyst.reactioncomplexmap","page":"API","title":"Catalyst.reactioncomplexmap","text":"reactioncomplexmap(rn::ReactionSystem)\n\nFind each ReactionComplex within the specified system, constructing a mapping from the complex to vectors that indicate which reactions it appears in as substrates and products.\n\nNotes:\n\nEach ReactionComplex is mapped to a vector of pairs, with each pair having the form reactionidx => ± 1, where -1 indicates the complex appears as a substrate and +1 as a product in the reaction with integer label reactionidx.\nConstant species are ignored as part of a complex. i.e. if species A is constant then the reaction A + B --> C + D is considered to consist of the complexes B and C + D. Likewise A --> B would be treated as the same as 0 --> B.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.reactioncomplexes","page":"API","title":"Catalyst.reactioncomplexes","text":"reactioncomplexes(network::ReactionSystem; sparse=false)\n\nCalculate the reaction complexes and complex incidence matrix for the given ReactionSystem.\n\nNotes:\n\nreturns a pair of a vector of ReactionComplexs and the complex incidence matrix.\nAn empty ReactionComplex denotes the null (∅) state (from reactions like ∅ -> A or A -> ∅).\nConstant species are ignored in generating a reaction complex. i.e. if A is constant then A –> B consists of the complexes ∅ and B.\nThe complex incidence matrix, B, is number of complexes by number of reactions with\n\nB_i j = begincases\n-1 textif the ith complex is the substrate of the jth reaction\n1 textif the ith complex is the product of the jth reaction\n0 textotherwise\nendcases\n\nSet sparse=true for a sparse matrix representation of the incidence matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.incidencemat","page":"API","title":"Catalyst.incidencemat","text":"incidencemat(rn::ReactionSystem; sparse=false)\n\nCalculate the incidence matrix of rn, see reactioncomplexes.\n\nNotes:\n\nIs cached in rn so that future calls, assuming the same sparsity, will also be fast.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.complexstoichmat","page":"API","title":"Catalyst.complexstoichmat","text":"complexstoichmat(network::ReactionSystem; sparse=false)\n\nGiven a ReactionSystem and vector of reaction complexes, return a matrix with positive entries of size number of species by number of complexes, where the non-zero positive entries in the kth column denote stoichiometric coefficients of the species participating in the kth reaction complex.\n\nNotes:\n\nSet sparse=true for a sparse matrix representation\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.complexoutgoingmat","page":"API","title":"Catalyst.complexoutgoingmat","text":"complexoutgoingmat(network::ReactionSystem; sparse=false)\n\nGiven a ReactionSystem and complex incidence matrix, B, return a matrix of size num of complexes by num of reactions that identifies substrate complexes.\n\nNotes:\n\nThe complex outgoing matrix, Delta, is defined by\n\nDelta_i j = begincases\n    = 0    textif  B_i j = 1 \n    = B_i j textotherwise\nendcases\n\nSet sparse=true for a sparse matrix representation\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.incidencematgraph","page":"API","title":"Catalyst.incidencematgraph","text":"incidencematgraph(rn::ReactionSystem)\n\nConstruct a directed simple graph where nodes correspond to reaction complexes and directed edges to reactions converting between two complexes.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\ncomplexes,incidencemat = reactioncomplexes(sir)\nincidencematgraph(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.linkageclasses","page":"API","title":"Catalyst.linkageclasses","text":"linkageclasses(rn::ReactionSystem)\n\nGiven the incidence graph of a reaction network, return a vector of the connected components of the graph (i.e. sub-groups of reaction complexes that are connected in the incidence graph).\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\ncomplexes,incidencemat = reactioncomplexes(sir)\nlinkageclasses(sir)\n\ngives\n\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [3, 4]\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.deficiency","page":"API","title":"Catalyst.deficiency","text":"deficiency(rn::ReactionSystem)\n\nCalculate the deficiency of a reaction network.\n\nHere the deficiency, delta, of a network with n reaction complexes, ell linkage classes and a rank s stoichiometric matrix is\n\ndelta = n - ell - s\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nrcs,incidencemat = reactioncomplexes(sir)\nδ = deficiency(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.subnetworks","page":"API","title":"Catalyst.subnetworks","text":"subnetworks(rn::ReactionSystem)\n\nFind subnetworks corresponding to each linkage class of the reaction network.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\ncomplexes,incidencemat = reactioncomplexes(sir)\nsubnetworks(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.linkagedeficiencies","page":"API","title":"Catalyst.linkagedeficiencies","text":"linkagedeficiencies(network::ReactionSystem)\n\nCalculates the deficiency of each sub-reaction network within network.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nrcs,incidencemat = reactioncomplexes(sir)\nlinkage_deficiencies = linkagedeficiencies(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isreversible","page":"API","title":"Catalyst.isreversible","text":"isreversible(rn::ReactionSystem)\n\nGiven a reaction network, returns if the network is reversible or not.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nrcs,incidencemat = reactioncomplexes(sir)\nisreversible(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isweaklyreversible","page":"API","title":"Catalyst.isweaklyreversible","text":"isweaklyreversible(rn::ReactionSystem, subnetworks)\n\nDetermine if the reaction network with the given subnetworks is weakly reversible or not.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nrcs,incidencemat = reactioncomplexes(sir)\nsubnets = subnetworks(rn)\nisweaklyreversible(rn, subnets)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.reset_networkproperties!","page":"API","title":"Catalyst.reset_networkproperties!","text":"reset_networkproperties!(rn::ReactionSystem)\n\nClears the cache of various properties (like the netstoichiometry matrix). Use if such properties need to be recalculated for some reason.\n\n\n\n\n\n","category":"function"},{"location":"api/#Network-comparison","page":"API","title":"Network comparison","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"==(rn1::Reaction, rn2::Reaction)\nisequivalent\n==(rn1::ReactionSystem, rn2::ReactionSystem)","category":"page"},{"location":"api/#Base.:==-Tuple{Reaction, Reaction}","page":"API","title":"Base.:==","text":"==(rx1::Reaction, rx2::Reaction)\n\nTests whether two Reactions are identical.\n\nNotes:\n\nIgnores the order in which stoichiometry components are listed.\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\n\n\n\n\n\n","category":"method"},{"location":"api/#Catalyst.isequivalent","page":"API","title":"Catalyst.isequivalent","text":"isequivalent(rn1::ReactionSystem, rn2::ReactionSystem; ignorenames = true)\n\nTests whether the underlying species, parameters and reactions are the same in the two ReactionSystems. Ignores the names of the systems in testing equality.\n\nNotes:\n\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\nDoes not include defaults in determining equality.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.:==-Tuple{ReactionSystem, ReactionSystem}","page":"API","title":"Base.:==","text":"==(rn1::ReactionSystem, rn2::ReactionSystem)\n\nTests whether the underlying species, parameters and reactions are the same in the two ReactionSystems. Requires the systems to have the same names too.\n\nNotes:\n\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\nDoes not include defaults in determining equality.\n\n\n\n\n\n","category":"method"},{"location":"api/#Network-visualization","page":"API","title":"Network visualization","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Latexify can be used to convert networks to LaTeX equations by","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Latexify\nlatexify(rn)","category":"page"},{"location":"api/","page":"API","title":"API","text":"An optional argument, form allows using latexify to display a reaction network's ODE (as generated by the reaction rate equation) or SDE (as generated by the chemical Langevin equation) form:","category":"page"},{"location":"api/","page":"API","title":"API","text":"latexify(rn; form=:ode)","category":"page"},{"location":"api/","page":"API","title":"API","text":"latexify(rn; form=:sde)","category":"page"},{"location":"api/","page":"API","title":"API","text":"(As of writing this, an upstream bug causes the SDE form to be erroneously displayed as the ODE form)","category":"page"},{"location":"api/","page":"API","title":"API","text":"Finally, another optional argument (expand_functions=true) automatically expands functions defined by Catalyst (such as mm). To disable this, set expand_functions=false.","category":"page"},{"location":"api/","page":"API","title":"API","text":"If Graphviz is installed and commandline accessible, it can be used to create and save network diagrams using Graph and savegraph.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Graph\ncomplexgraph\nsavegraph","category":"page"},{"location":"api/#Catalyst.Graph","page":"API","title":"Catalyst.Graph","text":"Graph(rn::ReactionSystem)\n\nConverts a ReactionSystem into a Graphviz graph. Reactions correspond to small green circles, and species to blue circles.\n\nNotes:\n\nBlack arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.\nBlack arrows from reactions to species indicate products, and are labelled with their output stoichiometry.\nRed arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction k*A, B --> C, there would be a red arrow from A to the reaction node. In k*A, A+B --> C, there would be red and black arrows from A to the reaction node.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catalyst.complexgraph","page":"API","title":"Catalyst.complexgraph","text":"complexgraph(rn::ReactionSystem; complexdata=reactioncomplexes(rn))\n\nCreates a Graphviz graph of the ReactionComplexs in rn. Reactions correspond to arrows and reaction complexes to blue circles.\n\nNotes:\n\nBlack arrows from complexes to complexes indicate reactions whose rate is a parameter or a Number. i.e. k, A --> B.\nRed dashed arrows from complexes to complexes indicate reactions whose rate depends on species. i.e. k*C, A --> B for C a species.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.savegraph","page":"API","title":"Catalyst.savegraph","text":"savegraph(g::Graph, fname, fmt=\"png\")\n\nGiven a Graph generated by Graph, save the graph to the file with name fname and extension fmt.\n\nNotes:\n\nfmt=\"png\" is the default output format.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/#api_rate_laws","page":"API","title":"Rate laws","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"As the underlying ReactionSystem is comprised of ModelingToolkit expressions, one can directly access the generated rate laws, and using ModelingToolkit tooling generate functions or Julia Exprs from them.","category":"page"},{"location":"api/","page":"API","title":"API","text":"oderatelaw\njumpratelaw\nmm\nmmr\nhill\nhillr\nhillar","category":"page"},{"location":"api/#Catalyst.oderatelaw","page":"API","title":"Catalyst.oderatelaw","text":"oderatelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the symbolic reaction rate law used in generated ODEs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X(t)^2*Y(t)*Z(t). For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe expression that is returned will be k * (X(t)^2/2) * (Y(t)^3/6).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses factorial scaling factors in calculating the   rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If   combinatoric_ratelaw=false then the ratelaw is k*S^2, i.e. the scaling   factor is ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.jumpratelaw","page":"API","title":"Catalyst.jumpratelaw","text":"jumpratelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the symbolic reaction rate law used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X^2*Y*Z. For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe expression that is returned will be k * binomial(X,2) * binomial(Y,3).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaw=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.mm","page":"API","title":"Catalyst.mm","text":"mm(X,v,K) = v*X / (X + K)\n\nA Michaelis-Menten rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.mmr","page":"API","title":"Catalyst.mmr","text":"mmr(X,v,K) = v*K / (X + K)\n\nA repressive Michaelis-Menten rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.hill","page":"API","title":"Catalyst.hill","text":"hill(X,v,K,n) = v*(X^n) / (X^n + K^n)\n\nA Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.hillr","page":"API","title":"Catalyst.hillr","text":"hillr(X,v,K,n) = v*(K^n) / (X^n + K^n)\n\nA repressive Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.hillar","page":"API","title":"Catalyst.hillar","text":"hillar(X,Y,v,K,n) = v*(X^n) / (X^n + Y^n + K^n)\n\nAn activation/repressing Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Transformations","page":"API","title":"Transformations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Base.convert\nModelingToolkit.structural_simplify","category":"page"},{"location":"api/#Base.convert","page":"API","title":"Base.convert","text":"Base.convert(::Type{<:ODESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.ODESystem.\n\nKeyword args and default values:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\n\n\n\n\n\nBase.convert(::Type{<:NonlinearSystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.NonlinearSystem.\n\nKeyword args and default values:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\n\n\n\n\n\nBase.convert(::Type{<:SDESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.SDESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\nDoes not currently support ReactionSystems that include coupled algebraic or differential equations.\n\n\n\n\n\nBase.convert(::Type{<:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)\n\nConvert a ReactionSystem to an ModelingToolkit.JumpSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaws=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nDoes not currently support ReactionSystems that include coupled algebraic or differential equations.\nDoes not currently support continuous events as these are not supported by ModelingToolkit.JumpSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.structural_simplify","page":"API","title":"ModelingToolkit.structural_simplify","text":"structural_simplify(sys; ...)\nstructural_simplify(sys, io; simplify, split, kwargs...)\n\n\nStructurally simplify algebraic equations in a system and compute the topological sort of the observed equations. When simplify=true, the simplify function will be applied during the tearing process. It also takes kwargs allow_symbolic=false and allow_parameter=true which limits the coefficient types during tearing.\n\nThe optional argument io may take a tuple (inputs, outputs). This will convert all inputs to parameters and allow them to be unconnected, i.e., simplification will allow models where n_unknowns = n_equations - n_inputs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chemistry-related-functionalities","page":"API","title":"Chemistry-related functionalities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Various functionalities primarily relevant to modelling of chemical systems (but potentially also in biology).","category":"page"},{"location":"api/","page":"API","title":"API","text":"@compound\n@compounds\niscompound\ncomponents\ncoefficients\ncomponent_coefficients","category":"page"},{"location":"api/#Catalyst.@compound","page":"API","title":"Catalyst.@compound","text":"@compound\n\nMacro that creates a compound species, which is composed of smaller component species.\n\nExample:\n\nt = default_t()\n@species C(t) O(t)\n@compound CO2(t) ~ C + 2O\n\nNotes: \n\nThe component species must be defined before using the @compound macro.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Catalyst.@compounds","page":"API","title":"Catalyst.@compounds","text":"@compounds\n\nMacro that creates several compound species, which each is composed of smaller component species. Uses the same syntax as @compound, but with one compound species one each line.\n\nExample:\n\nt = default_t()\n@species C(t) H(t) O(t) \n@compounds\n    CH4(t) = C + 4H\n    O2(t) = 2O\n    CO2(t) = C + 2O\n    H2O(t) = 2H + O\nend\n\nNotes: \n\nThe component species must be defined before using the @compound macro.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Catalyst.iscompound","page":"API","title":"Catalyst.iscompound","text":"iscompound(s)\n\nReturns true if the input is a compound species (else false).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.components","page":"API","title":"Catalyst.components","text":"components(s)\n\nReturns a vector with a list of all the components of a compound species (created using e.g. the @compound macro).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.coefficients","page":"API","title":"Catalyst.coefficients","text":"coefficients(s)\n\nReturns a vector with a list of all the stoichiometric coefficients of the components of a compound species (created using e.g. the @compound macro).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.component_coefficients","page":"API","title":"Catalyst.component_coefficients","text":"component_coefficients(s)\n\nReturns a Vector{Pari{Symbol,Int64}}, listing a compounds species (created using e.g. the @compound macro) all the coefficients and their stoichiometric coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Unit-validation","page":"API","title":"Unit validation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"validate(rx::Reaction; info::String = \"\")\nvalidate(rs::ReactionSystem, info::String=\"\")","category":"page"},{"location":"api/#ModelingToolkit.validate-Tuple{Reaction}","page":"API","title":"ModelingToolkit.validate","text":"validate(rx::Reaction; info::String = \"\")\n\nCheck that all substrates and products within the given Reaction have the same units, and that the units of the reaction's rate expression are internally consistent (i.e. if the rate involves sums, each term in the sum has the same units).\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelingToolkit.validate","page":"API","title":"ModelingToolkit.validate","text":"validate(rs::ReactionSystem, info::String=\"\")\n\nCheck that all species in the ReactionSystem have the same units, and that the rate laws of all reactions reduce to units of (species units) / (time units).\n\nNotes:\n\nDoes not check subsystems, constraint equations, or non-species variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utility-functions","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"symmap_to_varmap","category":"page"},{"location":"api/#Catalyst.symmap_to_varmap","page":"API","title":"Catalyst.symmap_to_varmap","text":"symmap_to_varmap(sys, symmap)\n\nGiven a system and map of Symbols to values, generates a map from corresponding symbolic variables/parameters to the values that can be used to pass initial conditions and parameter mappings.\n\nFor example,\n\nsir = @reaction_network sir begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsubsys = @reaction_network subsys begin\n    k, A --> B\nend\n@named sys = compose(sir, [subsys])\n\ngives\n\nModel sys with 3 equations\nUnknowns (5):\n  S(t)\n  I(t)\n  R(t)\n  subsys₊A(t)\n  subsys₊B(t)\nParameters (3):\n  β\n  ν\n  subsys₊k\n\nto specify initial condition and parameter mappings from symbols we can use\n\nsymmap = [:S => 1.0, :I => 1.0, :R => 1.0, :subsys₊A => 1.0, :subsys₊B => 1.0]\nu0map  = symmap_to_varmap(sys, symmap)\npmap   = symmap_to_varmap(sys, [:β => 1.0, :ν => 1.0, :subsys₊k => 1.0])\n\nu0map and pmap can then be used as input to various problem types.\n\nNotes:\n\nAny Symbol, sym, within symmap must be a valid field of sys. i.e. sys.sym must be defined.\n\n\n\n\n\n","category":"function"},{"location":"#Catalyst.jl-for-Reaction-Network-Modeling","page":"Home","title":"Catalyst.jl for Reaction Network Modeling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst.jl is a symbolic modeling package for analysis and high performance simulation of chemical reaction networks. Catalyst defines symbolic ReactionSystems, which can be created programmatically or easily specified using Catalyst's domain specific language (DSL). Leveraging ModelingToolkit.jl and Symbolics.jl, Catalyst enables large-scale simulations through auto-vectorization and parallelism. Symbolic ReactionSystems can be used to generate ModelingToolkit-based models, allowing the easy simulation and parameter estimation of mass action ODE models, Chemical Langevin SDE models, stochastic chemical kinetics jump process models, and more. Generated models can be used with solvers throughout the broader SciML ecosystem, including higher level SciML packages (e.g. for sensitivity analysis, parameter estimation, machine learning applications, etc).","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A DSL provides a simple and readable format for manually specifying chemical reactions.\nCatalyst ReactionSystems provide a symbolic representation of reaction networks, built on ModelingToolkit.jl and Symbolics.jl.\nNon-integer (e.g. Float64) stoichiometric coefficients are supported for generating ODE models, and symbolic expressions for stoichiometric coefficients are supported for all system types.\nThe Catalyst.jl API provides functionality for extending networks, building networks programmatically, network analysis, and for composing multiple networks together.\nReactionSystems generated by the DSL can be converted to a variety of ModelingToolkit.AbstractSystems, including symbolic ODE, SDE and jump process representations.\nCoupled differential and algebraic constraint equations can be included in Catalyst models, and are incorporated during conversion to ODEs or steady state equations.\nConservation laws can be detected and applied to reduce system sizes, and generate non-singular Jacobians, during conversion to ODEs, SDEs, and steady state equations.\nBy leveraging ModelingToolkit, users have a variety of options for generating optimized system representations to use in solvers. These include construction of dense or sparse Jacobians, multithreading or parallelization of generated derivative functions, automatic classification of reactions into optimized jump types for Gillespie type simulations, automatic construction of dependency graphs for jump systems, and more.\nGenerated systems can be solved using any DifferentialEquations.jl ODE/SDE/jump solver, and can be used within EnsembleProblems for carrying out parallelized parameter sweeps and statistical sampling. Plot recipes are available for visualizing the solutions.\nSymbolics.jl symbolic expressions and Julia Exprs can be obtained for all rate laws and functions determining the deterministic and stochastic terms within resulting ODE, SDE or jump models.\nLatexify can be used to generate LaTeX expressions corresponding to generated mathematical models or the underlying set of reactions.\nGraphviz can be used to generate and visualize reaction network graphs. (Reusing the Graphviz interface created in Catlab.jl.)","category":"page"},{"location":"#Packages-Supporting-Catalyst","page":"Home","title":"Packages Supporting Catalyst","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst ReactionSystems can be imported from SBML files via SBMLToolkit.jl, and from BioNetGen .net files and various stoichiometric matrix network representations using ReactionNetworkImporters.jl.\nMomentClosure.jl allows generation of symbolic ModelingToolkit ODESystems, representing moment closure approximations to moments of the Chemical Master Equation, from reaction networks defined in Catalyst.\nFiniteStateProjection.jl allows the construction and numerical solution of Chemical Master Equation models from reaction networks defined in Catalyst.\nDelaySSAToolkit.jl can augment Catalyst reaction network models with delays, and can simulate the resulting stochastic chemical kinetics with delays models.  \nBondGraphs.jl a package for constructing and analyzing bond graphs models, which can take Catalyst models as input.\nPEtab.jl a package that implements the PEtab format for fitting reaction network ODEs to data. Input can be provided either as SBML files or as Catalyst ReactionSystems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst can be installed through the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Catalyst\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To solve Catalyst models and visualize solutions, it is also recommended to install DifferentialEquations.jl and Plots.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"DifferentialEquations\")\nPkg.add(\"Plots\")","category":"page"},{"location":"#Illustrative-Example","page":"Home","title":"Illustrative Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example of generating, visualizing and solving an SIR ODE model. We first define the SIR reaction model using Catalyst","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Catalyst\nrn = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assuming Graphviz and is installed and command line accessible, the network can be visualized using the Graph command","category":"page"},{"location":"","page":"Home","title":"Home","text":"Graph(rn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"which in Jupyter notebooks will give the figure","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: SIR Network Graph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To generate and solve a mass action ODE version of the model we use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DifferentialEquations\np     = [:α => .1/1000, :β => .01]\ntspan = (0.0,250.0)\nu0    = [:S => 999.0, :I => 1.0, :R => 0.0]\nop    = ODEProblem(rn, u0, tspan, p)\nsol   = solve(op, Tsit5())       # use Tsit5 ODE solver","category":"page"},{"location":"","page":"Home","title":"Home","text":"which we can plot as","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nplot(sol, lw=2)","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst developers are active on the Julia Discourse, and the Julia Slack's #sciml-bridged and #sciml-sysbio channels. For bugs or feature requests open an issue.","category":"page"},{"location":"#catalyst_citation","page":"Home","title":"Supporting and Citing Catalyst.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The software in this ecosystem was developed as part of academic research. If you would like to help support it, please star the repository as such metrics may help us secure funding in the future. If you use Catalyst as part of your research, teaching, or other activities, we would be grateful if you could cite our work:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{CatalystPLOSCompBio2023,\n    doi = {10.1371/journal.pcbi.1011530},\n    author = {Loman, Torkel E. AND Ma, Yingbo AND Ilin, Vasily AND Gowda, Shashi AND Korsbo, Niklas AND Yewale, Nikhil AND Rackauckas, Chris AND Isaacson, Samuel A.},\n    journal = {PLOS Computational Biology},\n    publisher = {Public Library of Science},\n    title = {Catalyst: Fast and flexible modeling of reaction networks},\n    year = {2023},\n    month = {10},\n    volume = {19},\n    url = {https://doi.org/10.1371/journal.pcbi.1011530},\n    pages = {1-19},\n    number = {10},\n}","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"}]
}
