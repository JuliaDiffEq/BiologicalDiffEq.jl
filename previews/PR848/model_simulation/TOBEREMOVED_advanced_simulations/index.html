<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Simulation Options · Catalyst.jl</title><meta name="title" content="Advanced Simulation Options · Catalyst.jl"/><meta property="og:title" content="Advanced Simulation Options · Catalyst.jl"/><meta property="twitter:title" content="Advanced Simulation Options · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/TOBEREMOVED_advanced_simulations/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/TOBEREMOVED_advanced_simulations/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_simulation/TOBEREMOVED_advanced_simulations/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../home/"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../home/">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../home/">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../../model_creation/dsl_description/">The Reaction DSL</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li class="is-active"><a class="tocitem" href>Advanced Simulation Options</a><ul class="internal"><li><a class="tocitem" href="#advanced_simulations_ensemble_problems"><span>Monte Carlo simulations using <code>EnsembleProblem</code>s</span></a></li><li><a class="tocitem" href="#advanced_simulations_callbacks"><span>Event handling using callbacks</span></a></li><li><a class="tocitem" href="#Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations"><span>Scaling the noise magnitude in the chemical Langevin equations</span></a></li><li><a class="tocitem" href="#Useful-plotting-options"><span>Useful plotting options</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial modelling</span></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model simulation</a></li><li class="is-active"><a href>Advanced Simulation Options</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced Simulation Options</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_simulation/TOBEREMOVED_advanced_simulations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="advanced_simulations"><a class="docs-heading-anchor" href="#advanced_simulations">Advanced Simulation Options</a><a id="advanced_simulations-1"></a><a class="docs-heading-anchor-permalink" href="#advanced_simulations" title="Permalink"></a></h1><p>Throughout the preceding tutorials, we have shown the basics of how to solve ODE, SDE, and jump process models generated from Catalyst <code>ReactionSystem</code>s. In this tutorial we&#39;ll illustrate some more advanced functionality that can be useful in many modeling contexts, and that provide conveniences for common workflows. For a comprehensive overview of solver properties, parameters, and manipulating solution objects, please read the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">documentation of the DifferentialEquations package</a>, which Catalyst uses for all simulations.</p><h2 id="advanced_simulations_ensemble_problems"><a class="docs-heading-anchor" href="#advanced_simulations_ensemble_problems">Monte Carlo simulations using <code>EnsembleProblem</code>s</a><a id="advanced_simulations_ensemble_problems-1"></a><a class="docs-heading-anchor-permalink" href="#advanced_simulations_ensemble_problems" title="Permalink"></a></h2><p>In many contexts one needs to run multiple simulations of a model, for example to collect statistics of SDE or jump process solutions, or to systematically vary parameter values within a model. While it is always possible to manually run such ensembles of simulations via a <code>for</code> loop, DifferentialEquations.jl provides the <code>EnsembleProblem</code> as a convenience to manage structured collections of simulations. <code>EnsembleProblem</code>s provide a simple interface for modifying a problem between individual simulations, and offers several options for batching and/or parallelizing simulation runs. For a more thorough description, please read <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/ensemble/#ensemble">the Parallel Ensemble Simulations section of the DifferentialEquations documentation</a>. Here, we will give a brief introduction to the use of <code>EnsembleProblem</code>s from Catalyst-generated models.</p><p>Let&#39;s look at a single-component bistable self-activation model:</p><pre><code class="language-julia hljs">using Catalyst, DifferentialEquations, Plots

rn = @reaction_network begin
    v0 + hill(X,v,K,n), ∅ --&gt; X
    deg, X --&gt; ∅
end
u0 = [:X =&gt; 0.0]
tspan = (0.0,1000.0)
p = [:v0 =&gt; 0.1, :v =&gt; 2.5, :K =&gt; 75.0, :n =&gt; 2.0, :deg =&gt; 0.01];
sprob = SDEProblem(rn, u0, tspan, p)</code></pre><p>we can then use our <code>SDEProblem</code> as input to an <code>EnsembleProblem</code>:</p><pre><code class="language-julia hljs">eprob = EnsembleProblem(sprob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleProblem with problem SDEProblem</code></pre><p>The <code>EnsembleProblem</code> can now be used as input to the <code>solve</code> command. It has the same options as when simulating the <code>SDEProblem</code> directly, however, it has an additional argument <code>trajectories</code> to determine how many simulations should be performed.</p><pre><code class="language-julia hljs">esol = solve(eprob; trajectories=5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleSolution Solution of length 5 with uType:
SciMLBase.RODESolution{Float64, 2, Vector{Vector{Float64}}, Nothing, Nothing, Vector{Float64}, DiffEqNoiseProcess.NoiseProcess{Float64, 2, Float64, Vector{Float64}, Nothing, Nothing, typeof(DiffEqNoiseProcess.INPLACE_WHITE_NOISE_DIST), typeof(DiffEqNoiseProcess.INPLACE_WHITE_NOISE_BRIDGE), true, ResettableStacks.ResettableStack{Tuple{Float64, Vector{Float64}, Nothing}, true}, ResettableStacks.ResettableStack{Tuple{Float64, Vector{Float64}, Nothing}, true}, DiffEqNoiseProcess.RSWM{Float64}, Nothing, RandomNumbers.Xorshifts.Xoroshiro128Plus}, SDEProblem{Vector{Float64}, Tuple{Float64, Float64}, true, ModelingToolkit.MTKParameters{Tuple{Vector{Float64}}, Tuple{}, Tuple{}, Tuple{}, Tuple{}, Nothing, Nothing}, Nothing, SDEFunction{true, SciMLBase.FullSpecialize, ModelingToolkit.var&quot;#f#641&quot;{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var&quot;#_RGF_ModTag&quot;, ModelingToolkit.var&quot;#_RGF_ModTag&quot;, (0x1c904955, 0xa2829964, 0x2f68bf4c, 0xf81e5d71, 0xcf5de71b), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var&quot;#_RGF_ModTag&quot;, ModelingToolkit.var&quot;#_RGF_ModTag&quot;, (0xc7b89953, 0xd87680cc, 0x98b8125f, 0xfba3f9ee, 0x9f521184), Nothing}}, ModelingToolkit.var&quot;#g#642&quot;{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var&quot;#_RGF_ModTag&quot;, ModelingToolkit.var&quot;#_RGF_ModTag&quot;, (0xe2cc7ce5, 0x7b14a39f, 0xd8cc6fb9, 0xa3ab20c0, 0x6ef35888), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var&quot;#_RGF_ModTag&quot;, ModelingToolkit.var&quot;#_RGF_ModTag&quot;, (0x347b02cd, 0x5a5795e0, 0x2d107673, 0xb4bf1eae, 0x7ca5fd9a), Nothing}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, ModelingToolkit.var&quot;#generated_observed#651&quot;{Bool, SDESystem, Dict{Any, Any}}, Nothing, SDESystem}, ModelingToolkit.var&quot;#g#642&quot;{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var&quot;#_RGF_ModTag&quot;, ModelingToolkit.var&quot;#_RGF_ModTag&quot;, (0xe2cc7ce5, 0x7b14a39f, 0xd8cc6fb9, 0xa3ab20c0, 0x6ef35888), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var&quot;#_RGF_ModTag&quot;, ModelingToolkit.var&quot;#_RGF_ModTag&quot;, (0x347b02cd, 0x5a5795e0, 0x2d107673, 0xb4bf1eae, 0x7ca5fd9a), Nothing}}, Base.Pairs{Symbol, Nothing, Tuple{Symbol}, @NamedTuple{callback::Nothing}}, Matrix{Float64}}, StochasticDiffEq.LambaEM{true}, StochasticDiffEq.LinearInterpolationData{Vector{Vector{Float64}}, Vector{Float64}}, SciMLBase.DEStats, Nothing}</code></pre><p>This simulation is automatically multithreaded over all available threads. Please read <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/ensemble/#EnsembleAlgorithms">this documentation</a> for more information on parallelisation alternatives. The ensemble simulations can be plotted using the <code>plot</code> function, which by default displays all trajectories:</p><pre><code class="language-julia hljs">plot(esol)</code></pre><img src="6486f59c.svg" alt="Example block output"/><p>Sometimes when performing a large number of ensemble simulations, the plots get very dense. In these cases, the plot argument <code>linealpha</code> (which sets trajectory transparency) may be useful:</p><pre><code class="language-julia hljs">esol = solve(eprob; trajectories = 100)
plot(esol; linealpha = 0.5)</code></pre><img src="c7da8e99.svg" alt="Example block output"/><p>Sometimes, one wishes to perform the same simulation a large number of times, while making minor modifications to the problem each time. This can be done by giving a problem function, <code>prob_func</code>, argument to the <code>EnsembleProblem</code>. Let us consider ODE simulations of a simple birth/death process:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    (b,1.0), ∅ &lt;--&gt; X
end
u0 = [:X =&gt; 1.0]
tspan = (0.0, 1.0)
p = [:b =&gt; 1.];
oprob = ODEProblem(rn, u0, tspan, p)</code></pre><p>We wish to simulate this model for a large number of values of <code>b</code>. We do this by creating a <code>prob_func</code> that will make a modification to the problem at the start of each Monte Carlo simulation:</p><pre><code class="language-julia hljs">b_values = 1.0:0.1:2.0
function prob_func(prob, i, repeat)
    @unpack b = prob.f.sys    # Fetches the b parameter to be used in the local scope.
    remake(prob; p = [b =&gt; b_values[i]])
end</code></pre><p>Here, <code>prob_func</code> takes three arguments:</p><ul><li><code>prob</code>: The problem given to our <code>EnsembleProblem</code>, this is the problem that <code>prob_func</code> modifies in each iteration.</li><li><code>i</code>: The number of this specific Monte Carlo iteration in the interval <code>1:trajectories</code>.</li><li><code>repeat</code>: The repeat of this specific Monte Carlo simulation (We will ignore</li></ul><p>this argument in this brief overview). In our case, for each Monte Carlo simulation, our <code>prob_func</code> takes our original <code>ODEProblem</code> and uses the <code>remake</code> function to change the parameter vector. Here, for the <code>i</code>th Monte Carlo simulation, the value of <code>b</code> is also the <code>i</code>th value of our <code>b_values</code> vector. Finally, we can simulate and plot our problem:</p><pre><code class="language-julia hljs">eprob = EnsembleProblem(oprob; prob_func = prob_func)
esol = solve(eprob; trajectories = length(b_values))
plot(esol)</code></pre><img src="2f6fd277.svg" alt="Example block output"/><p>Note that plot legends are disabled when plotting ensemble solutions. These can be re-enabled using the <code>legend</code> plotting keyword. However, when plotting a large number of trajectories, each will generate a label. Sometimes the best approach is to remove these and add a label manually:</p><pre><code class="language-julia hljs">p = plot(esol; label = nothing)
plot!(p, Float64[], Float64[]; label = &quot;X&quot;, legend = :topleft)</code></pre><img src="dbbf341a.svg" alt="Example block output"/><h2 id="advanced_simulations_callbacks"><a class="docs-heading-anchor" href="#advanced_simulations_callbacks">Event handling using callbacks</a><a id="advanced_simulations_callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#advanced_simulations_callbacks" title="Permalink"></a></h2><p>Sometimes one wishes to add discrete events during simulations. Examples could include:</p><ul><li>A chemical system where an amount of some species is added at a time point after the simulation&#39;s initiation.</li><li>A simulation of a circadian rhythm, where light is turned on/off every 12 hours.</li><li>A cell divides when some size variable reaches a certain threshold, randomly allocating all species to two daughter cells.</li></ul><p>In simple cases events such as these can be modelled symbolically, as described in the <a href="../../model_creation/constraint_equations/#constraint_equations">Constraint Equations and Events</a> tutorial. A more flexible, but low-level, interface is also available via the callback functionality of DifferentialEquations.jl. A callback is a function that is passed to the <code>solve()</code> command, combing an <code>affect!</code> function (defining how the callback changes the system) with a <code>condition</code> function (a condition for triggering a callback). For a thorough introduction, please read <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/">the section about callbacks in the DifferentialEquations.jl documentation</a>.</p><p>There exist three types of callbacks, <code>PresetTimeCallback</code>s <code>DiscreteCallback</code>s, and <code>ContinuousCallback</code>s. Here, we will limit ourselves to introducing the <code>PresetTimeCallback</code>. For our example, we are going to use a simple network where a single component, <code>X</code>, degrades linearly.</p><pre><code class="language-julia hljs">using Catalyst
degradation_model = @reaction_network begin
    d, X --&gt; 0
end</code></pre><p>we can simulate the model without using a callback:</p><pre><code class="language-julia hljs">using DifferentialEquations, Plots
u0 = [:X =&gt; 10.0]
tspan = (0.0, 10.0)
p = [:d =&gt; 1.0]

oprob = ODEProblem(degradation_model, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><img src="5239a75b.svg" alt="Example block output"/><p>We now wish to modify our simulation so that at the times <code>t = 3.0</code> and <code>t = 7.0</code> we add <code>5</code> units of <code>X</code> to the system. For this we create a <code>PresetTimeCallback</code>:</p><pre><code class="language-julia hljs">condition = [3.0, 7.0]
function affect!(integrator)
    integrator[:X] += 5.0
end
ps_cb = PresetTimeCallback(condition, affect!)</code></pre><p>Here, <code>condition</code> is simply a vector with all the time points during which we want the callback to trigger. The <code>affect!</code> function determines what happens to the simulation when the callback is triggered. It takes a single object, an <code>integrator</code> and makes some modification to it (please read more about integrators <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/">here</a>). Here, we access the system&#39;s unknown <code>X</code> through the <code>integrator</code>, and add <code>5.0</code> to its amount. We can now simulate our system using the callback:</p><pre><code class="language-julia hljs">sol = solve(oprob, Tsit5(); callback = ps_cb)
plot(sol)</code></pre><img src="2a60ed41.svg" alt="Example block output"/><p>Next, we can also use a callback to change the parameters of a system. The following code plots the concentration of a two-state system, as we change the equilibrium constant between the two states:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    (k,1), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0, :X2 =&gt; 0.0]
tspan = (0.0, 20.0)
p = [:k =&gt; 1.0]
oprob = ODEProblem(rn, u0, tspan, p)

condition = [5.0]
affect!(integrator) = integrator.ps[:k] = 5.0
ps_cb = PresetTimeCallback(condition, affect!)

sol = solve(oprob, Tsit5(); callback = ps_cb)
plot(sol)</code></pre><img src="5c3513de.svg" alt="Example block output"/><p>The result looks as expected. However, what happens if we attempt to run the simulation again?</p><pre><code class="language-julia hljs">sol = solve(oprob, Tsit5(); callback = ps_cb)
plot(sol)</code></pre><img src="6d37da1d.svg" alt="Example block output"/><p>The plot looks different, even though we simulate the same problem. Furthermore, the callback does not seem to have any effect on the system. If we check our <code>ODEProblem</code></p><pre><code class="language-julia hljs">oprob.p</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ModelingToolkit.MTKParameters{Tuple{Vector{Float64}}, Tuple{}, Tuple{}, Tuple{}, Tuple{}, Nothing, Nothing}(([5.0],), (), (), (), (), nothing, nothing)</code></pre><p>we note that <code>k = 5.0</code>, rather than <code>k = 1.0</code> as we initially specified. This is because the callback modifies our <code>ODEProblem</code> during the simulation, and this modification remains during the second simulation. An improved workflow to avoid this issue is:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    (k,1), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0,:X2 =&gt; 0.0]
tspan = (0.0, 20.0)
p = [:k =&gt; 1.0]
oprob = ODEProblem(rn, u0, tspan, p)

condition = [5.0]
affect!(integrator) = integrator.ps[:k] = 5.0
ps_cb = PresetTimeCallback(condition, affect!)

sol = solve(deepcopy(oprob), Tsit5(); callback = ps_cb)
plot(sol)</code></pre><img src="81d52d0f.svg" alt="Example block output"/><p>where we parse a copy of our <code>ODEProblem</code> to the solver (using <code>deepcopy</code>). We can now run</p><pre><code class="language-julia hljs">sol = solve(deepcopy(oprob), Tsit5(); callback = ps_cb)
plot(sol)</code></pre><img src="bf6c0153.svg" alt="Example block output"/><p>and get the expected result.</p><p>It is possible to give several callbacks to the <code>solve()</code> command. To do so, one has to bundle them together in a <code>CallbackSet</code>, here follows one example:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    (k,1), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0, :X2 =&gt; 0.0]
tspan = (0.0, 20.0)
p = [:k =&gt; 1.0]
oprob = ODEProblem(rn, u0, tspan, p)

ps_cb_1 = PresetTimeCallback([3.0, 7.0], integ -&gt; integ[:X1] += 5.0)
ps_cb_2 = PresetTimeCallback([5.0], integ -&gt; integ.ps[:k] = 5.0)

sol = solve(deepcopy(oprob), Tsit5(); callback=CallbackSet(ps_cb_1, ps_cb_2))
plot(sol)</code></pre><img src="e6325e69.svg" alt="Example block output"/><p>The difference between the <code>PresetTimeCallback</code>s and the <code>DiscreteCallback</code>s and <code>ContiniousCallback</code>s is that the latter two allow the condition to be a function, permitting the user to give more general conditions for the callback to be triggered. An example could be a callback that triggers whenever a species surpasses some threshold value.</p><h3 id="advanced_simulations_ssa_callbacks"><a class="docs-heading-anchor" href="#advanced_simulations_ssa_callbacks">Callbacks during SSA simulations</a><a id="advanced_simulations_ssa_callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#advanced_simulations_ssa_callbacks" title="Permalink"></a></h3><p>An assumption of (most) SSA simulations is that the state of the system is unchanged between reaction events. However, callbacks that affect the system&#39;s state can violate this assumption. To prevent erroneous simulations, users must inform a SSA solver when the state has been updated in a callback. This allows the solver to reinitialize any internal state information that may have changed. This can be done through the <code>reset_aggregated_jumps!</code> function, see the following example:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    (k,1), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0,:X2 =&gt; 0.0]
tspan = (0.0, 20.0)
p = [:k =&gt; 1.0]
dprob = DiscreteProblem(rn, u0, tspan, p)
jprob = JumpProblem(rn, dprob, Direct())

condition = [5.0]
function affect!(integrator)
    integrator[:X1] += 5.0
    integrator.ps[:k] += 2.0
    reset_aggregated_jumps!(integrator)
    nothing
end
cb = PresetTimeCallback(condition, affect!)

sol = solve(deepcopy(jprob), SSAStepper(); callback=cb)
plot(sol)</code></pre><img src="08df4fba.svg" alt="Example block output"/><h2 id="Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations"><a class="docs-heading-anchor" href="#Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations">Scaling the noise magnitude in the chemical Langevin equations</a><a id="Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Scaling-the-noise-magnitude-in-the-chemical-Langevin-equations" title="Permalink"></a></h2><p>When using the CLE to generate SDEs from a CRN, it can sometimes be desirable to scale the magnitude of the noise terms. Here, each reaction of the system generates a separate noise term in the CLE. If you require identical scaling for all reactions, the <code>@default_noise_scaling</code> option can be used. Else, you can supply a <code>noise_scaling</code> metadata for each individual reaction, describing how to scale the noise for that reaction.</p><p>We begin with considering the first approach. First, we simulate a simple two-state CRN model using the CLE:</p><pre><code class="language-julia hljs">using Catalyst, StochasticDiffEq, Plots

rn_1 = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0, :X2 =&gt; 10.0]
tspan = (0.0, 10.0)
p_1 = [:k1 =&gt; 1.0, :k2 =&gt; 1.0]

sprob_1 = SDEProblem(rn_1, u0, tspan, p_1)
sol_1 = solve(sprob_1, ImplicitEM())
plot(sol_1; idxs = :X1, ylimit = (0.0, 20.0))</code></pre><img src="9323e1ce.svg" alt="Example block output"/><p>Here we can see that the <span>$X$</span> concentration fluctuates around a steady state of <span>$X≈10.0$</span>.</p><p>Next, we wish increase the amount of noise by a factor 2. To do so, we use the <code>@default_noise_scaling</code> option, to which we provide the desired scaling </p><pre><code class="language-julia hljs">rn_2 = @reaction_network begin
    @default_noise_scaling 2
    (k1,k2), X1 &lt;--&gt; X2
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X1} &amp;\xrightleftharpoons[k2]{k1} \mathrm{X2}  
 \end{align*}
 \]</p><p>If we re-simulate the system we see that the amount of noise have increased:</p><pre><code class="language-julia hljs">sprob_1 = SDEProblem(rn_2, u0, tspan, p_1)
sol_1 = solve(sprob_1, ImplicitEM())
plot(sol_1; idxs = :X1, ylimit = (0.0, 20.0))</code></pre><img src="502e0c71.svg" alt="Example block output"/><p>It is possible to scale the amount of noise using any expression. A common use of this is to set a parameter which determines the amount of noise. Here we create a parameter <span>$η$</span>, and uses its value to scale the noise.</p><pre><code class="language-julia hljs">using Catalyst, StochasticDiffEq, Plots

rn_3 = @reaction_network begin
    @parameters η
    @default_noise_scaling η
    (k1,k2), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 10.0, :X2 =&gt; 10.0]
tspan = (0.0, 10.0)
p_3 = [:k1 =&gt; 1.0, :k2 =&gt; 1.0, :η =&gt; 0.2]

sprob_3 = SDEProblem(rn_3, u0, tspan, p_3)
sol_3 = solve(sprob_3, ImplicitEM())
plot(sol_3; idxs = :X1, ylimit = (0.0, 20.0))</code></pre><img src="0ea00136.svg" alt="Example block output"/><p>Here we saw how, by setting a small <span>$η$</span> value, the amount of noise was reduced.</p><p>It is possible to use a different noise scaling expression for each reaction. Here, each reaction&#39;s noise scaling expression is provided using the <code>noise_scaling</code> metadata. In the following example, we use this to tune the noise of for both reactions involving the species <span>$Y$</span>.</p><pre><code class="language-julia hljs">rn_4 = @reaction_network begin
    (p, d), 0 &lt;--&gt; X
    (p, d), 0 &lt;--&gt; Y, ([noise_scaling=0.0], [noise_scaling=0.0])
end

u0_4 = [:X =&gt; 10.0, :Y =&gt; 10.0]
tspan = (0.0, 10.0)
p_4 = [:p =&gt; 10.0, :d =&gt; 1.]

sprob_4 = SDEProblem(rn_4, u0_4, tspan, p_4)
sol_4 = solve(sprob_4, ImplicitEM())
plot(sol_4; ylimit = (0.0, 20.0))</code></pre><img src="d0983272.svg" alt="Example block output"/><p>Here, we not that there is n fluctuation in the value of <span>$Y$</span>. If the <code>@default_noise_scaling</code> option is used, its value is used for all reactions for which the <code>noise_scaling</code> metadata is unused. If <code>@default_noise_scaling</code> is not used, the default noise scaling value is <code>1.0</code> (i.e. no scaling).</p><h2 id="Useful-plotting-options"><a class="docs-heading-anchor" href="#Useful-plotting-options">Useful plotting options</a><a id="Useful-plotting-options-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-plotting-options" title="Permalink"></a></h2><p>Catalyst, just like DifferentialEquations, uses the Plots package for all plotting. For a detailed description of differential equation plotting, see <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/plot/">DifferentialEquations documentation on the subject</a>. Furthermore, the <a href="https://docs.juliaplots.org/stable/">Plots package documentation</a> contains additional information and describes <a href="https://docs.juliaplots.org/stable/attributes/">a large number of plotting options</a>. Here follows a very short tutorial with a few useful options.</p><p>Let us consider the Brusselator model:</p><pre><code class="language-julia hljs">using Catalyst, DifferentialEquations, Plots

brusselator = @reaction_network begin
    A, ∅ --&gt; X
    1, 2X + Y --&gt; 3X
    B, X --&gt; Y
    1, X --&gt; ∅
end
u0 = [:X =&gt; 1.0, :Y =&gt; 0.0]
tspan = (0.0, 50.0)
p = [:A =&gt; 1.0, :B =&gt; 4.0]

oprob = ODEProblem(brusselator, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><img src="ec99180a.svg" alt="Example block output"/><p>If we want to plot only the <code>X</code> species, we can use the <code>idxs</code> command:</p><pre><code class="language-julia hljs">plot(sol; idxs = [:X])</code></pre><img src="7e5361a0.svg" alt="Example block output"/><p>If we wish to plot a single species (such as we do in this case), vector notation is not required and we could simply write <code>plot(sol; idxs=:X)</code>.</p><p>Next, if we wish to plot a solution in phase space (instead of across time) we again use the <code>idxs</code> notation, but use <code>()</code> instead of <code>[]</code> when designating the species we wish to plot. Here, we plot the solution in <code>(X,Y)</code> space:</p><pre><code class="language-julia hljs">plot(sol; idxs=(:X, :Y))</code></pre><img src="4001cd98.svg" alt="Example block output"/><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl online documentation.</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://openresearchsoftware.metajnl.com/articles/10.5334/jors.151">Chris Rackauckas, Qing Nie, <em>DifferentialEquations.jl – A Performant and Feature-Rich Ecosystem for Solving Differential Equations in Julia</em>, Journal of Open Resource Software (2017).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simulation_structure_interfacing/">« Interfacing problems, integrators, and solutions</a><a class="docs-footer-nextpage" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Saturday 25 May 2024 02:51">Saturday 25 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
