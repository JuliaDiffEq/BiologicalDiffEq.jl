<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structural Identifiability Analysis · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/catalyst_applications/structural_identifiability/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Functionality</span><ul><li><a class="tocitem" href="../../catalyst_functionality/dsl_description/">The Reaction DSL</a></li><li><a class="tocitem" href="../../catalyst_functionality/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../catalyst_functionality/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../catalyst_functionality/network_analysis/">Network Analysis in Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Applications</span><ul><li><a class="tocitem" href="../simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../advanced_simulations/">Advanced Simulation Options</a></li><li><a class="tocitem" href="../homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter Estimation</a></li><li class="is-active"><a class="tocitem" href>Structural Identifiability Analysis</a><ul class="internal"><li><a class="tocitem" href="#Global-identifiability-analysis"><span>Global identifiability analysis</span></a></li><li><a class="tocitem" href="#Local-identifiability-analysis"><span>Local identifiability analysis</span></a></li><li><a class="tocitem" href="#Finding-identifiable-functions"><span>Finding identifiable functions</span></a></li><li><a class="tocitem" href="#Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems"><span>Creating StructuralIdentifiability compatible ODE models from Catalyst <code>ReactionSystem</code>s</span></a></li><li><a class="tocitem" href="#structural_identifiability_citation"><span>Citation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Example Networks</span><ul><li><a class="tocitem" href="../../example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../example_networks/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../example_networks/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/catalyst_api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Catalyst Applications</a></li><li class="is-active"><a href>Structural Identifiability Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Structural Identifiability Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/catalyst_applications/structural_identifiability.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="structural_identifiability"><a class="docs-heading-anchor" href="#structural_identifiability">Structural Identifiability Analysis</a><a id="structural_identifiability-1"></a><a class="docs-heading-anchor-permalink" href="#structural_identifiability" title="Permalink"></a></h1><p>During parameter fitting, parameter values are inferred from data. Identifiability is a concept describing to what extent the identification of parameter values for a certain model is actually feasible. Ideally, parameter fitting should always be accompanied with an identifiability analysis of the problem. Identifiability can be divided into <em>structural</em> and <em>practical</em> identifiability<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. Structural identifiability considers only  the system and what quantities we can measure to determine which quantities can be identified. Practical identifiability instead considers the available data, and determines what system quantities can be infeed from it. Generally, in the hypothetical case of an infinite amount of without noise, practical identifiability becomes identical to structural identifiability. Generally, structural identifiability is assessed before parameters are fitted, while practical identifiability is assessed afterwards.</p><p>Structural identifiability can be illustrated in the following example network: <span>${dx \over dt} = p1*p2*x(t)$</span> where, however much data is collected on <em>x</em>, it is impossible to determine the distinct values of <em>p1</em> and <em>p2</em> (these are non-identifiable).</p><p>Catalyst contains a special extension for carrying out structural identifiability analysis using the <a href="https://github.com/SciML/StructuralIdentifiability.jl">StructuralIdentifiability.jl</a> package. This enables StructuralIdentifiability&#39;s <code>assess_identifiability</code>, <code>assess_local_identifiability</code>, and <code>find_identifiable_functions</code> functions to be called directly on Catalyst <code>ReactionSystems</code>. It also implements specialised routines to make these more efficient when applied to reaction network models. How to use these functions are described in the following tutorial, with <a href="https://docs.sciml.ai/StructuralIdentifiability/stable/">StructuralIdentifiability providing a more extensive documentation</a>. If you use this in your research, please <a href="#structural_identifiability_citation">cite the StructuralIdentifiability.jl</a> and <a href="../../#catalyst_citation">Catalyst.jl</a> publications.</p><p>Structural identifiability can be divided into <em>local</em> and <em>global</em> identifiability. If a model quantity (which can either be a parameter or an initial condition) is locally identifiable, it means that its true value can be determined down to a finite-number of possible options. This also means that there is some limited region around its true value, where the true value is the only possible value. Globally identifiable quantities&#39; values, on the other hand, can be uniquely determined. Again, while parameter (and initial condition) identifiability can be confirmed structurally for a model, it does not necessarily mean that they are practically* identifiable for some given data.</p><h2 id="Global-identifiability-analysis"><a class="docs-heading-anchor" href="#Global-identifiability-analysis">Global identifiability analysis</a><a id="Global-identifiability-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Global-identifiability-analysis" title="Permalink"></a></h2><h3 id="Basic-example"><a class="docs-heading-anchor" href="#Basic-example">Basic example</a><a id="Basic-example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-example" title="Permalink"></a></h3><p>Local identifiability can be assessed using the <code>assess_identifiability</code> function. For each model quantity (parameters and initial conditions), it will asses whether they are:</p><ul><li>globally identifiable.</li><li>locally identifiable.</li><li>Unidentifiable.</li></ul><p>To it, we provide our <code>ReactionSystem</code> model and a list of quantities that we are able to measure. Here, we consider a ... model. Let us say that we are able to measure teh values of ... and ..., we provide these at the <code>measured_quantities</code> argument. We can now assess identifiability in the following way:</p><pre><code class="language-example hljs"></code></pre><p>Here, ... are determined to be globally identifiable (and could theoretically be determined from data) and ... are locally identifiable (and for each, a finite number of candidate values can be determined from the data). Finally, ... are unidentifiable, and cannot be determined from data.</p><h3 id="Indicating-known-parameters"><a class="docs-heading-anchor" href="#Indicating-known-parameters">Indicating known parameters</a><a id="Indicating-known-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Indicating-known-parameters" title="Permalink"></a></h3><p>In the previous case we assumed that all parameters are unknown, however, this is not necessarily true. If there are parameters which value&#39;s are known, we can supply these using the <code>known_ps</code> argument. Indeed, this might turn other, previously unidentifiable, parameters identifiable. Let us consider this simple example:</p><pre><code class="language-example hljs">using Catalyst, StructuralIdentifiability # hide
rn = @reaction_network begin
    (p1+p2, d), 0 &lt;--&gt; X
end</code></pre><p>Typically, the two production parameters (<span>$p1$</span> and <span>$p2$</span>) are unidentifiable. However, we we already know the value of <span>$p1$</span>, then <span>$p2$</span>#s value becomes identifiable:</p><pre><code class="language-example hljs">assess_identifiability(rn; measured_quantities=[:X], known_ps=[:p1])</code></pre><h3 id="Providing-non-trivial-measured-quantities"><a class="docs-heading-anchor" href="#Providing-non-trivial-measured-quantities">Providing non-trivial measured quantities</a><a id="Providing-non-trivial-measured-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Providing-non-trivial-measured-quantities" title="Permalink"></a></h3><p>Sometimes, we are not actually measuring species species, but rather some combinations of species (or possibly parameters). Here, any algebraic expression can be used in <code>measured_quantities</code>. If so, used species and parameters have to first be <code>@unpack</code>&#39;ed from the model. Say that we have a model where an enzyme (<span>$E$</span>) is converted between an active and inactive form, which in turns activates the production of a product, <span>$P$</span>:</p><pre><code class="language-example hljs">using Catalyst, StructuralIdentifiability # hide
enzyme_activation = @reaction_network begin
    (kA,kD), Ei &lt;--&gt; Ea
    (Ea, d), 0 &lt;--&gt;P
end</code></pre><p>and we can measure the total amount of <span>$E$</span> (<span>$=$</span>Ei+Ea<span>$), as well as the amount of $P$</span>, we can use the following to assess identifiability:</p><pre><code class="language-example hljs">@unpack Ea, Ei = enzyme_activation
assess_identifiability(enzyme_activation; measured_quantities=[Ei+Ea, :P])</code></pre><h3 id="Checking-identifiability-of-specific-quantities"><a class="docs-heading-anchor" href="#Checking-identifiability-of-specific-quantities">Checking identifiability of specific quantities</a><a id="Checking-identifiability-of-specific-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-identifiability-of-specific-quantities" title="Permalink"></a></h3><p>By default, <code>asses_identifiability</code> assesses the identifiability of all parameters and species initial conditions. Sometimes, it is desirable to assess the identifiability of specific quantities. This can be done through the <code>funcs_to_check</code> argument. Let us consider our previous example, but say that we can only measure the amount of active enzyme (<span>$Ea$</span>), as well as the product (<span>$P$</span>). If we wish to determine whether the total amount of enzyme (<span>$Ei+Ea$</span>) is identifiable, we could use the following (again using <code>@unpack</code> to enable the formation of algebraic expression using the specific quantities):</p><pre><code class="language-example hljs">assess_identifiability(enzyme_activation; measured_quantities=[:Ei, :P], funcs_to_check=[Ei+Ea])</code></pre><h3 id="Probability-of-correctness"><a class="docs-heading-anchor" href="#Probability-of-correctness">Probability of correctness</a><a id="Probability-of-correctness-1"></a><a class="docs-heading-anchor-permalink" href="#Probability-of-correctness" title="Permalink"></a></h3><p>The identifiabiltiy methods used can, in theory, produce erroneous results. However, it is possible to adjust the lower bound for the probability of correctness using the argument <code>p</code> (by default set to <code>0.99</code>, that is, at least a <span>$99%$</span> chance of correctness). We can e.g. increase the bound through:</p><pre><code class="language-example hljs">assess_identifiability(rn; measured_quantities=[:X], p=0.999)
nothing # hide</code></pre><p>giving a minimum bound of <span>$99.9%$</span>  chance of correctness. In practise, the bounds used by StructuralIdentifiability are very conservative, which means that while the minimum guaranteed probability of correctness in the default case is <span>$99%$</span>, in practise it is higher. While increasing teh value of <code>p</code> increases the certainty of correctness, it will also increase the time required to assess correctness.</p><h2 id="Local-identifiability-analysis"><a class="docs-heading-anchor" href="#Local-identifiability-analysis">Local identifiability analysis</a><a id="Local-identifiability-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Local-identifiability-analysis" title="Permalink"></a></h2><p>Local identifiability can be assessed using the <code>assess_local_identifiability</code> function. While this is already determined by the <code>assess_identifiability</code> function, local identifiability have the advantage that it is easier to compute. Hence, there might be models where global identifiability analysis fails (or takes prohibitively long time), where instead <code>assess_local_identifiability</code> can be used. This functions takes the same inputs as <code>assess_identifiability</code> and returns, for each quantity, <code>true</code> if iti is locally identifiable and <code>false</code> if it is not. Here we assesses local identifiability for the same model as used in the previous example:</p><pre><code class="language-example hljs"></code></pre><p>We note that all parameters that <code>assess_identifiability</code> determined as either globally or locally identifiable are determined to be locally identifiable, while teh remaining are considered unidentifiable.</p><h2 id="Finding-identifiable-functions"><a class="docs-heading-anchor" href="#Finding-identifiable-functions">Finding identifiable functions</a><a id="Finding-identifiable-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-identifiable-functions" title="Permalink"></a></h2><p>Finally, StructuralIdentifiability provides the <code>find_identifiable_functions</code> function. Rather than determining the identifiability of each parameter and initial condition of the model, it finds a minimal set of identifiable functions, such as any other identifiable expression of the model can be generated by these. Here, let us consider the following model ...</p><pre><code class="language-example hljs"></code></pre><p>The <code>find_identifiable_functions</code> functions tries to simplify its output functions to create nice expression. The degree to which it does this can be adjusted using the <code>simplify</code> keywords. Using the <code>:weak</code>, <code>:standard</code> (default), and <code>:strong</code> arguments, increased simplification can be forced (at the expense of longer runtimes).</p><h2 id="Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems"><a class="docs-heading-anchor" href="#Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems">Creating StructuralIdentifiability compatible ODE models from Catalyst <code>ReactionSystem</code>s</a><a id="Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems" title="Permalink"></a></h2><p>While the functionality described above covers the vast majority of analysis as user might want to perform, the StructuralIdentifiability package supports several additional features . While these does not have inherent Catalyst support, we do provide the <code>make_si_ode</code> function to simplify their use. Similarly to the previous functions, it takes a <code>ReactionSystem</code> and lists of measured quantities and known parameter values. The output is a <a href="https://docs.sciml.ai/StructuralIdentifiability/stable/tutorials/creating_ode/#Defining-the-model-using-@ODEmodel-macro">ode of the standard form supported by StructuralIdentifiability</a>. It can be created using the following syntax:</p><pre><code class="language-example hljs">using Catalyst, StructuralIdentifiability # hide
</code></pre><p>and then used as input to various StructuralIdentifiability functions. In the following example we use the produced ode to</p><pre><code class="language-example hljs"></code></pre><hr/><h2 id="structural_identifiability_citation"><a class="docs-heading-anchor" href="#structural_identifiability_citation">Citation</a><a id="structural_identifiability_citation-1"></a><a class="docs-heading-anchor-permalink" href="#structural_identifiability_citation" title="Permalink"></a></h2><p>If you use this functionality in your research, please cite the following paper to support the authors of the StructuralIdentifiability package:</p><pre><code class="nohighlight hljs">@article{structidjl,
  author  = {Dong, R. and Goodbrake, C. and Harrington, H. and Pogudin G.},
  title   = {Differential Elimination for Dynamical Models via Projections with Applications to Structural Identifiability},
  journal = {SIAM Journal on Applied Algebra and Geometry},
  url     = {https://doi.org/10.1137/22M1469067},
  year    = {2023}
  volume  = {7},
  number  = {1},
  pages   = {194-235}
}</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://www.sciencedirect.com/science/article/pii/S1364815218307278">Guillaume H.A. Joseph et al., <em>Introductory overview of identifiability analysis: A guide to evaluating whether you have the right type of data for your modeling purpose</em>, Environmental Modelling &amp; Software (2019).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../parameter_estimation/">« Parameter Estimation</a><a class="docs-footer-nextpage" href="../../example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 7 November 2023 00:48">Tuesday 7 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
