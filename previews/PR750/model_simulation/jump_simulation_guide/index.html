<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advice for Stochastic Chemical Kinetics Jump Simulations · Catalyst.jl</title><meta name="title" content="Advice for Stochastic Chemical Kinetics Jump Simulations · Catalyst.jl"/><meta property="og:title" content="Advice for Stochastic Chemical Kinetics Jump Simulations · Catalyst.jl"/><meta property="twitter:title" content="Advice for Stochastic Chemical Kinetics Jump Simulations · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/jump_simulation_guide/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/jump_simulation_guide/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_simulation/jump_simulation_guide/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../sde_simulation_performance/">Advice for performant SDE simulations</a></li><li class="is-active"><a class="tocitem" href>Advice for Stochastic Chemical Kinetics Jump Simulations</a><ul class="internal"><li><a class="tocitem" href="#[Basic-simulation-behavior]"><span>[Basic simulation behavior]</span></a></li><li><a class="tocitem" href="#jump_simulation_guide_solution_saving"><span>Managing of solution saving</span></a></li><li><a class="tocitem" href="#jump_simulation_guide_jump_types"><span>Types of jumps</span></a></li><li><a class="tocitem" href="#jump_simulation_guide_solver_selection"><span>Jump solver selection</span></a></li><li><a class="tocitem" href="#jump_simulation_guide_hybrid_simulations"><span>Hybrid simulations</span></a></li><li><a class="tocitem" href="#jump_simulation_guide_parallelisation"><span>Simulation parallelisation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-8" type="checkbox"/><label class="tocitem" for="menuitem-4-8"><span class="docs-label">Model simulation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li></ul></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial Modelling</span><ul><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model simulation</a></li><li class="is-active"><a href>Advice for Stochastic Chemical Kinetics Jump Simulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advice for Stochastic Chemical Kinetics Jump Simulations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_simulation/jump_simulation_guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="jump_simulation_guide"><a class="docs-heading-anchor" href="#jump_simulation_guide">Advice for Stochastic Chemical Kinetics Jump Simulations</a><a id="jump_simulation_guide-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_guide" title="Permalink"></a></h1><p>We have previously introduced how Catalyst <em>chemical reaction network</em> (CRN) models can be converted to <em>stochastic chemical kinetics</em> jump process models, which can then be (exactly) simulated (i.e. sampled) using Stochastic Simulation Algorithms (SSAs) such as Gillespie&#39;s Direct method.</p><p>In this tutorial we will review basic information and configuration options for such simulations, and discuss several ways to increase their performance (thus reducing run time). All jump simulations arising from stochastic chemical kinetics representations of Catalyst models are performed using SSAs from JumpProcesses.jl. Please see the <a href="https://github.com/SciML/JumpProcesses.jl">JumpProcesses documentation</a> for a more extensive introduction to the package and its available solvers.</p><h3 id="jump_simulation_guide_intro"><a class="docs-heading-anchor" href="#jump_simulation_guide_intro">Brief (and optional) introduction to stochastic chemical kinetics jump simulations</a><a id="jump_simulation_guide_intro-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_guide_intro" title="Permalink"></a></h3><p>Jump processes are continuous-time, discrete-space, stochastic processes. Exact realizations of these processes can be generated using SSAs (of which Gillespie&#39;s Direct method is the most well-known choice). In the chemical reaction modelling context, the discrete-state variables typically correspond to the integer-valued number of each chemical species at each time. A system&#39;s state changes at discrete time points corresponding to when reactions occur (the jump times). A these these times the amount of one (or more) species are changed by integer amount(s) (for example, the creation of a new protein due to translation, or the removal of one protein due to degradation).</p><p>The frequency of each reaction&#39;s occurrence depends on its <em>propensity</em> function (which in turn depends on its <em>rate constant</em> and <em>substrate</em> amounts). The propensity of a reaction is analogous to the reaction&#39;s <em>rate law</em> in the ODE context, and represents the probability per unit time the reaction can occur given the current state of the system. In probability and statistics propensities are also often called intensity functions or transition rate functions. For example, the reaction <span>$A + A \overset{k}{\to} B$</span> has a rate constant of <span>$k$</span> and a propensity of <span>$k A (A-1) / 2$</span>, while the reaction <span>$A + B \overset{\gamma}{\to} C + D$</span> has a rate constant of <span>$\gamma$</span> and a propensity of <span>$k A B$</span>. See <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst_ratelaws">Reaction rate laws used in simulations</a> for more details of what propensity functions Catalyst generates for a given reaction, and <a href="../../introduction_to_catalyst/math_models_intro/#math_models_in_catalyst">Mathematical Models Catalyst can Generate</a> for details on both propensity functions and the mathematical jump process models Catalyst can generate from a CRN (called the time-change representation in the stochastic chemical kinetics literature).</p><p>During a typical simulation of a jump process model, the simulation algorithm samples both the time to the next reaction and which reaction will occur at this time point. The sampled time determines the timestep within a simulation, while the sampled reaction determines how the state is updated after stepping to the new time. Both are computed by sampling probability distributions that depend on the current values for the reaction propensities. More precisely, in the notation of the <a href="../../introduction_to_catalyst/math_models_intro/#math_models_in_catalyst">Mathematical Models Catalyst can Generate</a> guide, when the current time is <span>$t$</span>, the current system state is <span>$X(t)$</span> (i.e. the vector of the number of each chemical species), and the current propensity values are <span>$\{a_k(X(t))\}_{k=1}^K$</span>, a typical timestep of an SSA</p><ol><li>Samples both a <em>random</em> time <span>$\Delta t$</span> until the next reaction occurs and which reaction, <span>$k \in \{1,\dots,K\}$</span>, occurs at this time. This sampling process uses probability distributions that are built from the current propensity values, i.e. <span>$\{a_k(X(t))\}_{k=1}^K$</span>.</li><li>Executes the <span>$k$</span>&#39;th reaction calculating <span>$X(t + \Delta t)$</span> from <span>$X(t)$</span>.</li><li>Recalculates one or more propensity functions, <span>$a_k(X(t + \Delta t))$</span>, based on the new state.</li><li>Updates the time <span>$t \to t + \Delta t$</span>.</li></ol><p>Hence, the average work per one time step of a jump simulation is heavily dependent on how many propensities must typically be recomputed when a reaction occurs. Similarly, the total work across a full jump simulation will also depend on typical values for the timestep. Propensity function values generally increase as populations increase (i.e. for <span>$A + B \overset{k}{\to} C$</span> the propensity is <span>$k A B$</span> which increases in the amount of <span>$A$</span> or <span>$B$</span>). Larger propensities mean that reactions occur more frequently, and hence typical values for <span>$\Delta t$</span> will decrease and more timesteps will be taken when simulating to a fixed (physical) time, <span>$T$</span>.</p><p>A variety of factors can therefore impact the run time of different SSAs. Such simulations can become increasingly expensive for:</p><ul><li>Simulations of large models (i.e. with many different species, where some species occur in large copy numbers, or where many reactions are present in a system).</li><li>Simulations over long time spans or with large numbers of reactions occurring over the desired time span.</li><li>Simulations that are performed a large number of times for statistical sampling.</li><li>Simulations that are saving large amounts of data (such as saving the values of all species each time a reaction occurs).</li></ul><p>A more thorough overview of simulation methods for Stochastic Chemical Kinetics jump process models and their computational efficiency is given in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><h2 id="[Basic-simulation-behavior]"><a class="docs-heading-anchor" href="#[Basic-simulation-behavior]">[Basic simulation behavior]</a><a id="[Basic-simulation-behavior]-1"></a><a class="docs-heading-anchor-permalink" href="#[Basic-simulation-behavior]" title="Permalink"></a></h2><h2 id="jump_simulation_guide_solution_saving"><a class="docs-heading-anchor" href="#jump_simulation_guide_solution_saving">Managing of solution saving</a><a id="jump_simulation_guide_solution_saving-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_guide_solution_saving" title="Permalink"></a></h2><p>By default, <code>solve</code> saves the value of the solution at the time of every jump. For simulations with a large number of jump events, this can cause memory to quickly fill up. Typically, for simulations with a large number of jumps, we want to <a href="https://docs.sciml.ai/JumpProcesses/dev/tutorials/discrete_stochastic_example/#save_positions_docs">disable this feature</a> and instead set the save frequency manually. Let us consider a simple <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_bd">birth-death model</a>:</p><pre><code class="language-julia hljs">using Catalyst, JumpProcesses, Plots

bd_model = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
u0 = [:X =&gt; 10]
tspan = (0.0, 1000.0)
ps = [:p =&gt; 1000.0, :d =&gt; 100.0]

dprob = DiscreteProblem(bd_model, u0, tspan, ps)</code></pre><p>Let us simulate it using the default options, and plot the results. Furthermore, we use <a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl&#39;s</a> <code>@btime</code> macro to measure the time it takes to plot the output solution:</p><pre><code class="language-julia hljs">using BenchmarkTools
jprob = JumpProblem(bd_model, dprob, Direct())
sol = solve(jprob, SSAStepper())
@btime plot(sol)</code></pre><img src="1fbf82fe.svg" alt="Example block output"/><p>This simulation generates a very large number of jumps, with the solution saved and plotted at each time such a jump occurs. If the number of jumps is high enough, the memory limits may be exceeded (causing Julia to crash). Here, we do not reach this limit, however, the run time of the <code>plot(sol)</code> is affected by the number of points it must render (rendering too much in a single plot is another potential cause of crashed due to memory strain).</p><p>Next, we provide the <code>save_positions = (false, false)</code> option to <code>JumpProblem</code>. This turns off the saving of the solution both before and after each jump.</p><pre><code class="language-julia hljs">jprob = JumpProblem(bd_model, dprob, Direct(); save_positions = (false, false))</code></pre><p>However, if we were to simulate our model now, the solution would only actually be saved at its initial and final times. To remedy this, we provide the <code>saveat = 1.0</code> argument to the <code>solve</code> command, ensuring that the solution to be saved at every <code>1.0</code>th time unit (that is, at <code>t</code> = <code>0.0</code>, <code>1.0</code>, <code>2.0</code>, ... <code>999.0</code>, <code>1000.0</code>).</p><pre><code class="language-julia hljs">sol = solve(jprob, SSAStepper(); saveat = 1.0)</code></pre><p>we can now plot the new solution:</p><pre><code class="language-julia hljs">@btime plot(sol)</code></pre><img src="53294ee0.svg" alt="Example block output"/><p>Here, we note that the time to plot the simulation was reduced (for this example, admittedly from an already low level). Furthermore, the plots look different since the trajectory is sampled at much sparser time points.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>With the default saving behaviour, <a href="../simulation_structure_interfacing/#simulation_structure_interfacing_solutions">evaluating <code>sol(t)</code></a> at any time <code>t</code> within the <code>tspan</code> gives the <em>exact</em> value of the solution at that time (i.e. the vector of the exact number of each species). When using <code>saveat</code> and <code>save_positions = (false,false)</code> the solution is only saved at the selected time points, and as such <code>sol(t)</code> should not be evaluated except at times at which the solution was saved. While evaluating the solution at other times will return values they will not be the exact value of the jump process!</p></div></div><h2 id="jump_simulation_guide_jump_types"><a class="docs-heading-anchor" href="#jump_simulation_guide_jump_types">Types of jumps</a><a id="jump_simulation_guide_jump_types-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_guide_jump_types" title="Permalink"></a></h2><p>Each reaction in a chemical reaction network model corresponds to a possible jump of the jump simulation. These jumps can be divided into 3 categories:</p><ul><li><code>MassActionJump</code>s: These correspond to reactions which rates remain constant throughout the simulation.They are typically generated by reactions&#39; which rates contain time-independent parameters only.</li><li><code>ConstantRateJump</code>s: These correspond to reactions which rates remain constant between individual jumps, but may change in response to a jump occurring. They are typically generated by reactions&#39; which rates contain species and time-independent parameters only.</li><li><code>VariableRateJump</code>s: These correspond to reactions which rates may change at any time during the simulation. They are typically generated by reactions&#39; which rates contain the time variable (<span>$t$</span>).</li></ul><p>Here are some example reactions for the different types of jumps:</p><pre><code class="language-julia hljs"># `MassActionJump`s
@reaction 1.0, X --&gt; Y
@reaction k, 2X + Y --&gt; X2Y
@reaction k1*k2+k3, 0 --&gt; X

# `ConstantRateJump`s
@reaction k*log(X), Y --&gt; X
@reaction mm(X,v,K), 0 --&gt; X

# `VariableRateJump`s
@reaction k*(1+sin(t)), 0 --&gt; X
@reaction X/t, X + Y --&gt; XY</code></pre><p>Updating <code>MassActionJump</code>s&#39; propensities is more computationally efficient (due to their constrained form) than updating them for <code>ConstantRateJump</code>s. Thus simulations are more performant if a larger fraction of reactions are of the <code>MassActionJump</code> form (rather than the <code>ConstantRateJump</code> form). Furthermore, simulations containing <code>VariableRateJump</code> requires additional routines to find the times between jump events (as unlike non-<code>VariableRateJump</code> simulations, jump propensities change <em>between</em> jump events, making this computation more difficult). Hence, the existence of <code>VariableRateJump</code> can significantly slow down a simulation Primarily, there exist two common situation where models are written in a way so that sub-optimal jump types are generated, both of which we describe below.</p><h3 id="jump_simulation_guide_jump_types_unnecessary_constantratejumps"><a class="docs-heading-anchor" href="#jump_simulation_guide_jump_types_unnecessary_constantratejumps">Unnecessarily putting species in rates rather than in reactions</a><a id="jump_simulation_guide_jump_types_unnecessary_constantratejumps-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_guide_jump_types_unnecessary_constantratejumps" title="Permalink"></a></h3><p>Sometimes, a rate has been made dependent on a species, where that species instead could have been made part of the actual reaction. Consider a reaction where an enzyme (<span>$E$</span>) catalyses the phosphorylation of a protein (<span>$X$</span>) to phosphorylated form (<span>$Xᵖ$</span>). It can be written in two different forms:</p><pre><code class="language-julia hljs">r1 = @reaction k*E, X --&gt; Xᵖ
r2 = @reaction k, X + E --&gt; Xᵖ + E</code></pre><p>These two reactions will generate identical simulations (this holds for ODE, SDE, and Jump simulations). However, while <code>r1</code> will generate a <code>ConstantRateJump</code>, <code>r2</code> will generate a <code>MassActionJump</code>. Hence, if the <code>r2</code> form is used, jump simulation performance is (at no cost) improved. Since the two forms are otherwise identical, it is always preferable to, whenever possible, put species in the reactions, rather than the rates.</p><h3 id="jump_simulation_guide_jump_types_unnecessary_variableratejumps"><a class="docs-heading-anchor" href="#jump_simulation_guide_jump_types_unnecessary_variableratejumps">Using piecewise constant, time-dependant, function instead of events</a><a id="jump_simulation_guide_jump_types_unnecessary_variableratejumps-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_guide_jump_types_unnecessary_variableratejumps" title="Permalink"></a></h3><p>Let us consider a reaction with some input that depends on time. We assume that the input is initially <span>$0$</span>, but after some critical time <span>$t = 5.0$</span> it is increased to <span>$1$</span>. This can be implemented through a step function:</p><pre><code class="language-julia hljs">input(t) = t &gt; 5.0
r = @reaction input(t), 0 --&gt; X</code></pre><p>Here, the production of species <span>$X$</span> is switched on at the time <span>$t = 5.0$</span>. This reaction (for which the rate depends on <code>t</code>) will generate a <code>VariableRateJump</code>, which is the least performant jump type in simulations. However, since the rate is piecewise constant, it can alternatively be implemented by setting it to a constant parameter <span>$i$</span>, and then using a <a href="../../model_creation/constraint_equations/#constraint_equations_events"><em>discrete event</em></a> to update it at the switching times. This will again generate an equivalent model, but with the reaction encoded as a <code>MassActionJump</code> (rather than a <code>VariableRateJump</code>). Generally such explicit time-discontinuities should be encoded via discrete callbacks instead of as <code>VariableRateJump</code>s if possible (as simulation methods for the latter typically assume the system&#39;s propensities evolve continuously in-between jumps).</p><h2 id="jump_simulation_guide_solver_selection"><a class="docs-heading-anchor" href="#jump_simulation_guide_solver_selection">Jump solver selection</a><a id="jump_simulation_guide_solver_selection-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_guide_solver_selection" title="Permalink"></a></h2><p>When creating a <code>JumpProblem</code>, a specific solver is designated using its third argument.</p><pre><code class="language-julia hljs">using Catalyst, JumpProcesses, Plots

bd_model = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
u0 = [:X =&gt; 10]
tspan = (0.0, 1000.0)
ps = [:p =&gt; 1000.0, :d =&gt; 100.0]

dprob = DiscreteProblem(bd_model, u0, tspan, ps)
jprob = JumpProblem(bd_model, dprob, Direct())</code></pre><p>Here (as throughout most of Catalyst&#39;s documentation) we have used the <code>Direct()</code> SSA solver (which corresponds to Gillespie&#39;s original direct method <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup><sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>). This method was originally published in 1976, and since then, many additional methods for simulating stochastic chemical kinetics models have been developed.</p><p>Gillespie&#39;s direct method will, after a jump has been performed, recompute the propensities of <em>all</em> possible jumps in the system (i.e. of all reactions). This is typically not required. E.g. consider the following system:</p><pre><code class="language-julia hljs">@reaction_network begin
    k1, X1 --&gt; X2
    k2, X2 --&gt; X3
    k3, X3 --&gt; 0
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X1} &amp;\xrightarrow{k1} \mathrm{X2} \\
\mathrm{X2} &amp;\xrightarrow{k2} \mathrm{X3} \\
\mathrm{X3} &amp;\xrightarrow{k3} \varnothing  
 \end{align*}
 \]</p><p>Here, the propensities of the <code>k1, X1 --&gt; X2</code> and <code>k2, X2 --&gt; X3</code> reactions (<code>k1*X1*X2</code> and <code>k2*X2</code> respectively) do not depend on the amount of <span>$X3$</span> in the system. Hence, the value of their propensities are unchanged by the occurrence of the <code>k3, X3 --&gt; 0</code> reaction. Performant jump simulation methods have several ways to determine which rates require recomputing after the occurrence of a reaction, which improves their computational performance. Many of these requires a dependency graphs, which track which other reactions&#39; propensities must be recomputed after the occurrence of a given reaction. Catalyst automatically builds such dependency graphs, which means that all JumpProcesses SSAs can be used without any additional inputs.</p><p>A full list of jump simulation method implemented by JumpProcesses can be found <a href="https://docs.sciml.ai/JumpProcesses/stable/jump_types/#Jump-Aggregators-for-Exact-Simulation">here</a>. Generally, <code>RSSA()</code> (the rejection SSA method <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup><sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup>) is recommended for small models, with <code>RSSACR()</code> (the rejection SSA with composition-rejection method <sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup>) typically being more performant for larger models. For models that are simulated a large number of times, it can be worthwhile to try a few different jump simulation methods to determine which one is most performant in each given case.</p><h2 id="jump_simulation_guide_hybrid_simulations"><a class="docs-heading-anchor" href="#jump_simulation_guide_hybrid_simulations">Hybrid simulations</a><a id="jump_simulation_guide_hybrid_simulations-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_guide_hybrid_simulations" title="Permalink"></a></h2><p>For some models, copy numbers may vary greatly between different species. E.g. consider a genetic promoter which can either be in an inactive form (<span>$Pᵢ$</span>) or an active form (<span>$Pₐ$</span>). The active promoter produces a molecule (<span>$M$</span>):</p><pre><code class="language-julia hljs">promoter = @reaction_network begin
    (kA,kI), Pᵢ &lt;--&gt; Pₐ
    p, Pₐ --&gt; Pₐ + M
    d, M --&gt; ∅
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{P_i} &amp;\xrightleftharpoons[kI]{kA} \mathrm{P_a} \\
\mathrm{P_a} &amp;\xrightarrow{p} \mathrm{P_a} + \mathrm{M} \\
\mathrm{M} &amp;\xrightarrow{d} \varnothing  
 \end{align*}
 \]</p><p>Let us simulate this model and consider the copy numbers of each individual component:</p><pre><code class="language-julia hljs">u0 = [:Pᵢ =&gt; 1, :Pₐ =&gt; 0, :M =&gt; 10000]
tspan = (0.0, 5000.0)
p = [:kA =&gt; 0.05, :kI =&gt; .01, :p =&gt; 500.0, :d =&gt; 0.0005]

dprob = DiscreteProblem(promoter, u0, tspan, p)
jprob = JumpProblem(promoter, dprob, RSSA())
sol = solve(jprob, SSAStepper())

plt_1 = plot(sol; idxs=2)
plt_2 = plot(sol; idxs=3)
plot(plt_1, plt_2, size=(1200, 400))</code></pre><img src="7e99b011.svg" alt="Example block output"/><p>We note that the copy numbers <span>$Pₐ$</span> are highly stochastic. Meanwhile, <span>$M$</span> exists in so large copy numbers that its trajectory can be considered approximately deterministic. For models like this one, jump simulations are required to capture the stochastic behaviour of the promoter. However, the large number of jumps generated by <span>$M$</span> makes such simulations excessively expensive. Here, <em>hybrid simulations</em> can be used. Hybrid simulations employ different simulation strategies for their different components. In our example, the state of the promoter could be simulated using a jump simulation, while <span>$M$</span> could be simulated using an ODE.</p><p>Hybrid simulations for Catalyst models are currently not supported, though they are supported by the lower-level solvers in JumpProcesses and OrdinaryDiffEq. It is work in progress to interface Catalyst to such lower-level solvers, and to provide better optimised hybrid methods. If you require such simulations, please <a href="https://github.com/SciML/Catalyst.jl/issues">raise an issue</a> and we can notify you of the current state of our implementation, or give suggestions on how one can directly interface with the lower-level hybrid solver interface.</p><h2 id="jump_simulation_guide_parallelisation"><a class="docs-heading-anchor" href="#jump_simulation_guide_parallelisation">Simulation parallelisation</a><a id="jump_simulation_guide_parallelisation-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_guide_parallelisation" title="Permalink"></a></h2><p>When multiple simulations are carried out, simulations can be improved by running these in parallel. We have <a href="../ode_simulation_performance/#ode_simulation_performance_parallelisation">previously described</a> how to do so for ODE simulation. Jump simulations can be parallelised in the same manner, with the exception that GPU parallelisation is currently not supported.</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://link.springer.com/book/10.1007/978-3-319-63113-4">L. Marchetti, C. Priami, V. H. Thanh, <em>Simulation Algorithms for Computational Systems Biology</em>, Springer (2017).</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://www.sciencedirect.com/science/article/abs/pii/0021999176900413">D. T. Gillespie, <em>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</em>, Journal of Computational Physics (1976).</a></li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a><a href="https://pubs.acs.org/doi/10.1021/j100540a008">D. T. Gillespie, <em>Exact Stochastic Simulation of Coupled Chemical Reactions</em>, The Journal of Physical Chemistry (1977).</a></li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a><a href="https://pubmed.ncbi.nlm.nih.gov/25296793/">V. H. Thanh, C. Priami and R. Zunino, <em>Efficient rejection-based simulation of biochemical reactions with stochastic noise and delays</em>, Journal of Chemical Physics (2014).</a></li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a><a href="https://pubmed.ncbi.nlm.nih.gov/26133409/">V. H. Thanh, R. Zunino and C. Priami, <em>On the rejection-based algorithm for simulation and analysis of large-scale reaction networks</em>, Journal of Chemical Physics (2015).</a></li><li class="footnote" id="footnote-6"><a class="tag is-link" href="#citeref-6">6</a><a href="https://pubmed.ncbi.nlm.nih.gov/26890923/">V. H. Thanh, R. Zunino, and C. Priami, <em>Efficient constant-time complexity algorithm for stochastic simulation of large reaction networks</em>, IEEE/ACM Transactions on Computational Biology and Bioinformatics (2017).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sde_simulation_performance/">« Advice for performant SDE simulations</a><a class="docs-footer-nextpage" href="../examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 9 August 2024 20:56">Friday 9 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
