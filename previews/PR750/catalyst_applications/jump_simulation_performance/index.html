<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advice for performant jump simulations · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/catalyst_applications/jump_simulation_performance/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Functionality</span><ul><li><a class="tocitem" href="../../catalyst_functionality/dsl_description/">The Reaction DSL</a></li><li><a class="tocitem" href="../../catalyst_functionality/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../catalyst_functionality/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../catalyst_functionality/network_analysis/">Network Analysis in Catalyst</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../catalyst_functionality/example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../catalyst_functionality/example_networks/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../catalyst_functionality/example_networks/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Catalyst Applications</span><ul><li><a class="tocitem" href="../simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../advanced_simulations/">Advanced Simulation Options</a></li><li class="is-active"><a class="tocitem" href>Advice for performant jump simulations</a><ul class="internal"><li><a class="tocitem" href="#Managing-of-solution-saving"><span>Managing of solution saving</span></a></li><li><a class="tocitem" href="#Types-of-jumps"><span>Types of jumps</span></a></li><li><a class="tocitem" href="#Jump-solver-selection"><span>Jump solver selection</span></a></li><li><a class="tocitem" href="#Hybrid-simulations"><span>Hybrid simulations</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../nonlinear_solve/">Finding Steady States using NonlinearSolve.jl</a></li><li><a class="tocitem" href="../bifurcation_diagrams/">Bifurcation Diagrams</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/parameter_estimation/">Parameter Estimation</a></li><li><a class="tocitem" href="../../inverse_problems/petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/catalyst_api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Catalyst Applications</a></li><li class="is-active"><a href>Advice for performant jump simulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advice for performant jump simulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/catalyst_applications/jump_simulation_performance.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="jump_simulation_performance"><a class="docs-heading-anchor" href="#jump_simulation_performance">Advice for performant jump simulations</a><a id="jump_simulation_performance-1"></a><a class="docs-heading-anchor-permalink" href="#jump_simulation_performance" title="Permalink"></a></h1><p>We have previously described how to perform simulations of stochastic chemical kinetics <em>chemical reaction network</em> (CRN) jump process models using e.g. Gillespie&#39;s algorithm. These simulations can, however, be highly computationally intensive. Fortunately, there are several ways to increase their performance (thus reducing runtime). Here, we describe various considerations for performant stochastic chemical kinetics simulations, which we will subsequently refer to as jump process simulations. All jump process simulations arising from stochastic chemical kinetics representations of Catalyst models are performed using stochastic simulation algorithms (SSAs) from JumpProcesses.jl. Please see the <a href="https://github.com/SciML/JumpProcesses.jl">JumpProcesses documentation</a> for a more extensive introduction to the package and the available solvers.</p><h4 id="Brief-(and-optional)-introduction-to-jump-simulations"><a class="docs-heading-anchor" href="#Brief-(and-optional)-introduction-to-jump-simulations">Brief (and optional) introduction to jump simulations</a><a id="Brief-(and-optional)-introduction-to-jump-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Brief-(and-optional)-introduction-to-jump-simulations" title="Permalink"></a></h4><p>Jump processes are continuous-time, discrete-space stochastic processes. Exact realizations of these processes can be generated using Stochastic Simulation Algorithms (SSAs), of which Gillespie&#39;s Direct method is one popular choice. In the chemical reaction modeling context the discrete-state variables typically correspond to the integer-valued number of each chemical species at each time. A system&#39;s state changes at discrete time points, the jump times, when the amount of one or more species are increased by integer amounts (for example, the creation of a new protein due to translation, or the removal of one protein due to degradation). For CRNs, these jumps correspond to the occurrence of individual reactions. Typically, the frequency of each reaction depends on its <em>propensity</em> (which in turn depends on its <em>rate</em> and <em>substrates</em>). The propensity of a reaction represents its rate law, i.e. probability per time that it occurs (also known as the associated jump process&#39; intensity function). For example, the reaction <code>k, A + B --&gt; C + D</code> has a propensity of <span>$k*A(t)*B(t)$</span> at time <span>$t$</span>. See <a href="../../introduction_to_catalyst/introduction_to_catalyst/#Reaction-rate-laws-used-in-simulations">Reaction rate laws used in simulations</a> for more details of what propensity function Catalyst generates for a given stochastic chemical kinetics reaction.</p><p>The time of the next occurrence of some reaction, and the type of reaction that occurs, are sampled from distributions that depend on the current values of the propensity. As the latter depend on the state of the system, they must be recomputed whenever the system&#39;s state changes (for example due to a reaction occurring). Hence, jump simulations&#39; run-times are heavily dependent on how frequently these propensities must be recomputed, and how many must be recomputed when a reaction occurs.</p><p>Typically, propensities are recomputed only whenever a jump occurs. This means that jump simulations&#39; runtimes, very roughly, scale with the number of jumps. Runtimes typically become prohibitively expensive for:</p><ul><li>Simulations of large models (i.e. with many different species, where some species occur in large copy numbers, or where many reactions are present in a system).</li><li>Simulations over long time spans.</li><li>Simulations that are performed a large number of times.</li></ul><p>A more thorough overview of simulation methods for Stochastic Chemical Kinetics jump process models and their computational efficiency is given in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><h2 id="Managing-of-solution-saving"><a class="docs-heading-anchor" href="#Managing-of-solution-saving">Managing of solution saving</a><a id="Managing-of-solution-saving-1"></a><a class="docs-heading-anchor-permalink" href="#Managing-of-solution-saving" title="Permalink"></a></h2><p>By default, <code>solve</code> saves the value of the solution at the time of every jump. For simulations where a large number of jumps occur, this can cause memory to quickly fill up. Typically, for simulations with a large number of jumps, we want to <a href="https://docs.sciml.ai/JumpProcesses/dev/tutorials/discrete_stochastic_example/#save_positions_docs">disable this feature</a> and instead set the save frequency manually. To exemplify this, let us consider a simple production/degradation model:</p><pre><code class="language- hljs">using Catalyst, JumpProcesses, Plots

rn = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
u0 = [:X =&gt; 10]
tspan = (0.0, 1000.0)
ps = [:p =&gt; 1000.0, :d =&gt; 100.0]

dprob = DiscreteProblem(rn, u0, tspan, ps)
nothing # hide</code></pre><p>Let us simulate this model using the default options, and plot the results. Furthermore, we use <a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl&#39;s</a> <code>@btime</code> macro to measure the time it takes to plot the output solution:</p><pre><code class="language- hljs">using BenchmarkTools
jprob = JumpProblem(rn, dprob, Direct())
sol = solve(jprob, SSAStepper())
@btime plot(sol)</code></pre><p>This simulation generates a very large number of jumps, with the solution saved and plotted at each time such a jump occurs. If the number of jumps is high enough, the memory limits may be exceeded (causing Julia to crash). Here, we do not reach that limit, however, the performance of the <code>plot(sol)</code> is affected by the number of points it must render (rendering too much in a single plot is another potential cause of crashed due to memory strain).</p><p>Next, we provide the <code>save_positions = (false, false)</code> option to <code>JumpProblem</code>. This turns off the saving of the solution both before and after each jump. </p><pre><code class="language- hljs">jprob = JumpProblem(rn, dprob, Direct(); save_positions = (false, false))
nothing # hide</code></pre><p>However, if we were to simulate our model now, the solution would only actually be saved at its initial and final times. To remedy this, we provide the <code>saveat = 1.0</code> argument to the <code>solve</code> command, causing the solution to be saved at every <code>1.0</code>th time unit (at <code>t</code> = <code>0.0</code>, <code>1.0</code>, <code>2.0</code>, ... <code>999.0</code>, <code>1000.0</code>).</p><pre><code class="language- hljs">sol = solve(jprob, SSAStepper(),saveat=1.0)
nothing # hide</code></pre><p>we can now plot the new solution:</p><pre><code class="language- hljs">@btime plot(sol)</code></pre><p>Here, we note that the time to plot the simulation was reduced (for this example, admittedly from an already low level). Furthermore, the plots look different since the trajectory is sampled at much sparser time points.</p><h2 id="Types-of-jumps"><a class="docs-heading-anchor" href="#Types-of-jumps">Types of jumps</a><a id="Types-of-jumps-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-jumps" title="Permalink"></a></h2><p>Each reaction in a chemical reaction network model corresponds to a possible jump of the jump simulation. These jumps can be divided into 3 categories:</p><ul><li><code>MassActionJump</code>s: These correspond to reactions which rates are constant throughout the simulation. They are typically generated when the rate contains parameters only. </li><li><code>ConstantRateJump</code>s: These correspond to reactions which rates remain constant between individual jumps, but may change in response to a jump occurring. They are typically generated when the rate contains variables and parameters only. </li><li><code>VariableRateJump</code>s: These correspond to reactions which rates may change at any time during the simulation. They are typically generated when the rate depends on the time variable (<span>$t$</span>).</li></ul><p>Here are some example reactions for the different types of jumps:</p><pre><code class="language-julia hljs"># `MassActionJump`s
@reaction 1.0, X --&gt; Y
@reaction k, 2X + Y --&gt; X2Y
@reaction k1*k2+k3, 0 --&gt; X

# `ConstantRateJump`s
@reaction k*log(X), Y --&gt; X
@reaction mm(X,v,K), 0 --&gt; X

# `VariableRateJump`s
@reaction k*(1+sin(t)), 0 --&gt; X
@reaction X/t, X + Y --&gt; XY</code></pre><p>Throughout a simulation, <code>VariableRateJump</code>s&#39; rates require updating more frequently than <code>ConstantRateJump</code>s&#39; rates, which in turn requires updating more frequently than <code>MassActionJump</code>s&#39; rates. Since the performance of jump simulations is heavily affected by how frequently jump rates are computed, keeping the number of <code>ConstantRateJump</code>s and <code>VariableRateJump</code>s as small as possible is advantageous. Primarily, there exist two common cases where models are written in a way so that sub-optimal jump types are generated, both of which we describe below.</p><h4 id="Unnecessarily-putting-species-in-rates-rather-than-in-reactions"><a class="docs-heading-anchor" href="#Unnecessarily-putting-species-in-rates-rather-than-in-reactions">Unnecessarily putting species in rates rather than in reactions</a><a id="Unnecessarily-putting-species-in-rates-rather-than-in-reactions-1"></a><a class="docs-heading-anchor-permalink" href="#Unnecessarily-putting-species-in-rates-rather-than-in-reactions" title="Permalink"></a></h4><p>Sometimes, a rate has been made dependent on a species, where that species instead could have been made part of the actual reaction. Consider a reaction where an enzyme (<span>$E$</span>) catalyses the phosphorylation of a protein (<span>$X$</span>) to phosphorylated form (<span>$Xᵖ$</span>). It can be written in two different forms:</p><pre><code class="language-julia hljs">r1 = @reaction k*E, X --&gt; Xᵖ
r2 = @reaction k, X + E --&gt; Xᵖ + E</code></pre><p>These two reactions will generate identical simulations (this holds for ODE, SDE, and Jump simulations). However, while <code>r1</code> will generate a <code>ConstantRateJump</code>, <code>r2</code> will generate a <code>MassActionJump</code>. Hence, if the <code>r2</code> form is used, jump simulation performance is, at no cost, improved. Since the two forms are otherwise identical, it is always preferable to, whenever possible, put species in the reactions, rather than the rates.</p><h4 id="Using-piecewise-constant,-time-dependant,-function-instead-of-callbacks."><a class="docs-heading-anchor" href="#Using-piecewise-constant,-time-dependant,-function-instead-of-callbacks.">Using piecewise constant, time-dependant, function instead of callbacks.</a><a id="Using-piecewise-constant,-time-dependant,-function-instead-of-callbacks.-1"></a><a class="docs-heading-anchor-permalink" href="#Using-piecewise-constant,-time-dependant,-function-instead-of-callbacks." title="Permalink"></a></h4><p>Let us consider a reaction with some input that depends on time. We assume that the input is initially <span>$0$</span>, but after some critical time <span>$t=5.0$</span> it is increased to <span>$1$</span>. This can be implemented through a step function:</p><pre><code class="language-julia hljs">input(t) = t &gt; 5.0
r = @reaction input(t), 0 --&gt; X</code></pre><p>Here, the production of species <span>$X$</span> is switched on at the time <span>$t=5.0$</span>. This reaction (which rate depends on <code>t</code>) will generate a <code>VariableRateJump</code>, which is bad for jump simulation performance. However, since the rate is piecewise constant, it can instead be implemented by setting it to a constant parameter <span>$i$</span>, and then use a <a href="../advanced_simulations/#advanced_simulations_callbacks"><em>callback</em></a> to update it at the critical times. This will again generate an equivalent model, but with the reaction encoded as a <code>MassActionJump</code> (rather than a <code>VariableRateJump</code>).</p><h2 id="Jump-solver-selection"><a class="docs-heading-anchor" href="#Jump-solver-selection">Jump solver selection</a><a id="Jump-solver-selection-1"></a><a class="docs-heading-anchor-permalink" href="#Jump-solver-selection" title="Permalink"></a></h2><p>When creating a <code>JumpProblem</code>, a specific solver is designated using its third argument.</p><pre><code class="language- hljs">using Catalyst, JumpProcesses, Plots

rn = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
u0 = [:X =&gt; 10]
tspan = (0.0, 1000.0)
ps = [:p =&gt; 1000.0, :d =&gt; 100.0]

dprob = DiscreteProblem(rn, u0, tspan, ps)
jprob = JumpProblem(rn, dprob, Direct())
nothing # hide</code></pre><p>Here (as throughout most of Catalyst&#39;s documentation) we have used the <code>Direct()</code> solver (which corresponds to Gillespie&#39;s original direct method <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup><sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>, also called the <em>stochastic simulation algorithm</em>). This method was originally published in 1976, and since then, many additional methods for performing jump simulations of CRN models have been developed. </p><p>Gillespie&#39;s direct method will, after a jump has been performed, recompute the rates of <em>all</em> possible jumps in the system. This is typically not required. E.g. consider the following system:</p><pre><code class="language-julia hljs">@reaction_network begin
    k1, X1 --&gt; X2
    k2, X2 --&gt; X3
    k3, X3 --&gt; 0
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X1} &amp;\xrightarrow{k1} \mathrm{X2} \\
\mathrm{X2} &amp;\xrightarrow{k2} \mathrm{X3} \\
\mathrm{X3} &amp;\xrightarrow{k3} \varnothing  
 \end{align*}
 \]</p><p>Here, the rate of the <code>k1, X1 --&gt; X2</code> and <code>k2, X2 --&gt; X3</code> reactions does not depend on the amount of <span>$X3$</span> in the system. Hence, their rates are unaffected by the occurrence of the <code>k3, X3 --&gt; 0</code> reaction. Performant jump simulation methods have clever ways to determine which rates require recomputing after the occurrence of each reaction, which improves their performance. Many of these depend on so-called dependency graphs (which track which reactions&#39; rates are affected by the occurrence of which reactions). Catalyst automatically builds such dependency graphs, which means that most jump simulators can be used without any additional input.</p><p>A full list of jump simulation method implemented by JumpProcesses can be found <a href="https://docs.sciml.ai/JumpProcesses/stable/jump_types/#Jump-Aggregators-for-Exact-Simulation">here</a>. Generally, <code>RSSA()</code> (the rejection SSA method <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup><sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup>) is recommended for small models, with <code>RSSACR()</code> (the rejection SSA with composition-rejection method <sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup>) typically being more performant for larger models. For models that are simulated a large number of times, it can be worthwhile to try a few different jump simulation methods to determine which one is most performant in each given case.</p><h2 id="Hybrid-simulations"><a class="docs-heading-anchor" href="#Hybrid-simulations">Hybrid simulations</a><a id="Hybrid-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Hybrid-simulations" title="Permalink"></a></h2><p>For some models, copy numbers may vary greatly between different species. E.g. consider a genetic promoter which can either be in an inactive form (<span>$Pᵢ$</span>) or an active form (<span>$Pₐ$</span>). The active promoter produces a molecule (<span>$M$</span>):</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    (kA,kI), Pᵢ &lt;--&gt; Pₐ
    p, Pₐ --&gt; Pₐ + M
    d, M --&gt; ∅
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{P_i} &amp;\xrightleftharpoons[kI]{kA} \mathrm{P_a} \\
\mathrm{P_a} &amp;\xrightarrow{p} \mathrm{P_a} + \mathrm{M} \\
\mathrm{M} &amp;\xrightarrow{d} \varnothing  
 \end{align*}
 \]</p><p>Let us simulate this model and consider the copy numbers of each individual component:</p><pre><code class="language- hljs">using JumpProcesses, Plots # hide
u0 = [:Pᵢ =&gt; 1, :Pₐ =&gt; 0, :M =&gt; 10000]
tspan = (0.0, 5000.0)
p = [:kA =&gt; 0.05, :kI =&gt; .01, :p =&gt; 500.0, :d =&gt; 0.0005]

dprob = DiscreteProblem(rn, u0, tspan, p)
jprob = JumpProblem(rn, dprob, RSSA())
sol = solve(jprob, SSAStepper())

plt_1 = plot(sol; idxs=2)
plt_2 = plot(sol; idxs=3)
plot(plt_1, plt_2, size=(1200,400))</code></pre><p>We note that the copy numbers <span>$Pₐ$</span> are highly stochastic. Meanwhile, <span>$M$</span> exists in so large copy numbers that its trajectory can be considered approximately deterministic. For models like this one, jump simulations are required to capture the stochastic behaviour of the promoter. However, the large number of jumps generated by <span>$M$</span> makes such simulations excessively expensive. Here, <em>hybrid simulations</em> can be used. Hybrid simulations employ different simulation strategies for their different components. In our example, the state of the promoter could be simulated using a jump simulation, while <span>$M$</span> could be simulated using an ODE.</p><p>Hybrid simulations for Catalyst models are currently not supported. However, it is a work in progress. If you require such simulations, please <a href="https://github.com/SciML/Catalyst.jl/issues">raise an issue</a> and we can notify you of the current state of our implementation. Alternatively, other CRN modelling tools that support hybrid simulations exist.</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://link.springer.com/book/10.1007/978-3-319-63113-4">L. Marchetti, C. Priami, V. H. Thanh, <em>Simulation Algorithms for Computational Systems Biology</em>, Springer (2017).</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://www.sciencedirect.com/science/article/abs/pii/0021999176900413">D. T. Gillespie, <em>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</em>, Journal of Computational Physics (1976).</a></li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a><a href="https://pubs.acs.org/doi/10.1021/j100540a008">D. T. Gillespie, <em>Exact Stochastic Simulation of Coupled Chemical Reactions</em>, The Journal of Physical Chemistry (1977).</a></li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a><a href="https://pubmed.ncbi.nlm.nih.gov/25296793/">V. H. Thanh, C. Priami and R. Zunino, <em>Efficient rejection-based simulation of biochemical reactions with stochastic noise and delays</em>, Journal of Chemical Physics (2014).</a></li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a><a href="https://pubmed.ncbi.nlm.nih.gov/26133409/">V. H. Thanh, R. Zunino and C. Priami, <em>On the rejection-based algorithm for simulation and analysis of large-scale reaction networks</em>, Journal of Chemical Physics (2015).</a></li><li class="footnote" id="footnote-6"><a class="tag is-link" href="#citeref-6">6</a><a href="https://pubmed.ncbi.nlm.nih.gov/26890923/">V. H. Thanh, R. Zunino, and C. Priami, <em>Efficient constant-time complexity algorithm for stochastic simulation of large reaction networks</em>, IEEE/ACM Transactions on Computational Biology and Bioinformatics (2017).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../advanced_simulations/">« Advanced Simulation Options</a><a class="docs-footer-nextpage" href="../homotopy_continuation/">Finding Steady States through Homotopy Continuation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 30 December 2023 12:58">Saturday 30 December 2023</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
