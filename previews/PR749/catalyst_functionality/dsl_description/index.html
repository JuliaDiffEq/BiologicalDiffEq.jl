<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Reaction DSL · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/catalyst_functionality/dsl_description/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Functionality</span><ul><li class="is-active"><a class="tocitem" href>The Reaction DSL</a><ul class="internal"><li><a class="tocitem" href="#basic_examples"><span>Basic syntax</span></a></li><li><a class="tocitem" href="#Defining-parameters-and-species"><span>Defining parameters and species</span></a></li><li><a class="tocitem" href="#Production,-Destruction,-and-Stoichiometry"><span>Production, Destruction, and Stoichiometry</span></a></li><li><a class="tocitem" href="#Arrow-variants"><span>Arrow variants</span></a></li><li><a class="tocitem" href="#Bi-directional-arrows-for-reversible-reactions"><span>Bi-directional arrows for reversible reactions</span></a></li><li><a class="tocitem" href="#Combining-several-reactions-in-one-line"><span>Combining several reactions in one line</span></a></li><li><a class="tocitem" href="#Variable-reaction-rates"><span>Variable reaction rates</span></a></li><li><a class="tocitem" href="#dsl_description_explicit_species"><span>Explicit specification of network species and parameters</span></a></li><li><a class="tocitem" href="#dsl_description_defaults"><span>Setting default values for initial conditions and parameters</span></a></li><li><a class="tocitem" href="#Constant/fixed-species"><span>Constant/fixed species</span></a></li><li><a class="tocitem" href="#dsl_description_parametric_initial_conditions"><span>Setting initial conditions that depend on parameters</span></a></li><li><a class="tocitem" href="#Naming-the-generated-ReactionSystem"><span>Naming the generated <code>ReactionSystem</code></span></a></li><li><a class="tocitem" href="#Pre-defined-functions"><span>Pre-defined functions</span></a></li><li><a class="tocitem" href="#Including-non-species-variables"><span>Including non-species variables</span></a></li><li><a class="tocitem" href="#Specifying-alternative-time-variables-and/or-extra-independent-variables"><span>Specifying alternative time variables and/or extra independent variables</span></a></li><li><a class="tocitem" href="#dsl_description_interpolation_of_variables"><span>Interpolation of Julia variables</span></a></li><li><a class="tocitem" href="#Including-observables"><span>Including observables</span></a></li></ul></li><li><a class="tocitem" href="../programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../example_networks/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../example_networks/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Catalyst Applications</span><ul><li><a class="tocitem" href="../../catalyst_applications/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../catalyst_applications/advanced_simulations/">Advanced Simulation Options</a></li><li><a class="tocitem" href="../../catalyst_applications/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../catalyst_applications/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl</a></li><li><a class="tocitem" href="../../catalyst_applications/bifurcation_diagrams/">Bifurcation Diagrams</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/catalyst_api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Catalyst Functionality</a></li><li class="is-active"><a href>The Reaction DSL</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Reaction DSL</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/catalyst_functionality/dsl_description.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="dsl_description"><a class="docs-heading-anchor" href="#dsl_description">The Reaction DSL</a><a id="dsl_description-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_description" title="Permalink"></a></h1><p>This tutorial describes the syntax for building chemical reaction network models using Catalyst&#39;s domain-specific language (DSL). Examples showing how to both construct and solve ODE, SDE, and jump models are provided in <a href="../example_networks/basic_CRN_examples/#basic_CRN_examples">Basic Chemical Reaction Network Examples</a>. To learn more about the symbolic <a href="../../api/catalyst_api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s generated by the DSL, and how to use them directly, see the tutorial on <a href="../programmatic_CRN_construction/#programmatic_CRN_construction">Programmatic Construction of Symbolic Reaction Systems</a>.</p><p>We first load the <code>Catalyst</code> package, which is required for the code in this tutorial to run</p><pre><code class="language-julia hljs">using Catalyst</code></pre><h2 id="basic_examples"><a class="docs-heading-anchor" href="#basic_examples">Basic syntax</a><a id="basic_examples-1"></a><a class="docs-heading-anchor-permalink" href="#basic_examples" title="Permalink"></a></h2><p>The <code>@reaction_network</code> macro allows the (symbolic) specification of reaction networks with a simple format. Its input is a set of chemical reactions, and from them it generates a symbolic <a href="../../api/catalyst_api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> reaction network object. The <code>ReactionSystem</code> can be used as input to ModelingToolkit <code>ODEProblem</code>, <code>NonlinearProblem</code>, <code>SteadyStateProblem</code>, <code>SDEProblem</code>, <code>JumpProblem</code>, and more. <code>ReactionSystem</code>s can also be incrementally extended as needed, allowing for programmatic construction of networks and network composition.</p><p>The basic syntax is:</p><pre><code class="language- hljs">rn = @reaction_network begin
  2.0, X + Y --&gt; XY
  1.0, XY --&gt; Z1 + Z2
end</code></pre><p>where each line of the <a href="../../api/catalyst_api/#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro corresponds to a chemical reaction. Each reaction consists of a reaction rate (the expression on the left-hand side of  <code>,</code>), a set of substrates (the expression in-between <code>,</code> and <code>--&gt;</code>), and a set of products (the expression on the right-hand side of <code>--&gt;</code>). The substrates and the products may contain one or more reactants, separated by <code>+</code>. The naming convention for these is the same as for normal variables in Julia.</p><p>The chemical reaction model is generated by the <code>@reaction_network</code> macro and stored in the <code>rn</code> variable (a normal Julia variable, which does not need to be called <code>rn</code>). It corresponds to a <a href="../../api/catalyst_api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, a symbolic representation of the chemical network.  The generated <code>ReactionSystem</code> can be converted to a symbolic differential equation model via</p><pre><code class="language- hljs">osys  = convert(ODESystem, rn)</code></pre><p>We can then convert the symbolic ODE model into a compiled, optimized representation for use in the SciML ODE solvers by constructing an <code>ODEProblem</code>. Creating an <code>ODEProblem</code> also requires our specifying the initial conditions for the model. We do this by creating a mapping from each symbolic variable representing a chemical species to its initial value</p><pre><code class="language-julia hljs"># define the symbolic variables
@variables t
@species X(t) Y(t) Z(t) XY(t) Z1(t) Z2(t)

# create the mapping
u0 = [X =&gt; 1.0, Y =&gt; 1.0, XY =&gt; 1.0, Z1 =&gt; 1.0, Z2 =&gt; 1.0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Pair{Num, Float64}}:
  X(t) =&gt; 1.0
  Y(t) =&gt; 1.0
 XY(t) =&gt; 1.0
 Z1(t) =&gt; 1.0
 Z2(t) =&gt; 1.0</code></pre><p>Alternatively, we can create a mapping using Julia <code>Symbol</code>s for each variable, and then convert them to a mapping involving symbolic variables like</p><pre><code class="language- hljs">u0 = symmap_to_varmap(rn, [:X =&gt; 1.0, :Y =&gt; 1.0, :XY =&gt; 1.0, :Z1 =&gt; 1.0, :Z2 =&gt; 1.0])</code></pre><p>Given the mapping, we can then create an <code>ODEProblem</code> from our symbolic <code>ODESystem</code></p><pre><code class="language- hljs">tspan = (0.0, 1.0)  # the time interval to solve on
oprob = ODEProblem(osys, u0, tspan, [])</code></pre><p>Catalyst provides a shortcut to avoid having to explicitly <code>convert</code> to an <code>ODESystem</code> and/or use <code>symmap_to_varmap</code>, allowing direct construction of the <code>ODEProblem</code> like</p><pre><code class="language- hljs">u0 = [:X =&gt; 1.0, :Y =&gt; 1.0, :XY =&gt; 1.0, :Z1 =&gt; 1.0, :Z2 =&gt; 1.0]
oprob = ODEProblem(rn, u0, tspan, [])</code></pre><p>For more detailed examples, see the <a href="../example_networks/basic_CRN_examples/#basic_CRN_examples">Basic Chemical Reaction Network Examples</a>.</p><h2 id="Defining-parameters-and-species"><a class="docs-heading-anchor" href="#Defining-parameters-and-species">Defining parameters and species</a><a id="Defining-parameters-and-species-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-parameters-and-species" title="Permalink"></a></h2><p>Numeric parameter values do not need to be set when the model is created, i.e. Catalyst supports symbolic parameters too:</p><pre><code class="language- hljs">rn = @reaction_network begin
  k1, X --&gt; Y
  k2, Y --&gt; X
end</code></pre><p>All symbols that do not appear as a substrate or product in a reaction are designated by Catalyst as a parameter (i.e. all symbols appearing only within rate expressions and/or as <a href="../parametric_stoichiometry/#parametric_stoichiometry">stoichiometric coefficients</a>). In this example <code>X</code> and <code>Y</code> appear as a substrates and products, but neither <code>k1</code> nor <code>k2</code>. Hence <code>k1</code> and <code>k2</code> are designated as parameters. Later in this tutorial, we will describe how to manually specify what should be considered a species or parameter.</p><h2 id="Production,-Destruction,-and-Stoichiometry"><a class="docs-heading-anchor" href="#Production,-Destruction,-and-Stoichiometry">Production, Destruction, and Stoichiometry</a><a id="Production,-Destruction,-and-Stoichiometry-1"></a><a class="docs-heading-anchor-permalink" href="#Production,-Destruction,-and-Stoichiometry" title="Permalink"></a></h2><p>Sometimes reactants are produced/destroyed from/to nothing. This can be designated using either <code>0</code> or <code>∅</code>:</p><pre><code class="language- hljs">rn = @reaction_network begin
  2.0, 0 --&gt; X
  1.0, X --&gt; 0
end</code></pre><p>If several molecules of the same reactant are involved in a reaction, the stoichiometry of a reactant in a reaction can be set using a number. Here, two molecules of species <code>X</code> form the dimer <code>X2</code>:</p><pre><code class="language- hljs">rn = @reaction_network begin
  1.0, 2X --&gt; Y
end</code></pre><p>this corresponds to the differential equation:</p><pre><code class="language- hljs">convert(ODESystem, rn)</code></pre><p>Other numbers than 2 can be used, and parenthesis can be used to reuse the same stoichiometry for several reactants:</p><pre><code class="language- hljs">rn = @reaction_network begin
  1.0, X + 2(Y + Z) --&gt; W
end</code></pre><p>Note, one can explicitly multiply by integer coefficients too, i.e.</p><pre><code class="language- hljs">rn = @reaction_network begin
  1.0, X + 2*(Y + Z) --&gt; W
end</code></pre><h2 id="Arrow-variants"><a class="docs-heading-anchor" href="#Arrow-variants">Arrow variants</a><a id="Arrow-variants-1"></a><a class="docs-heading-anchor-permalink" href="#Arrow-variants" title="Permalink"></a></h2><p>A variety of Unicode arrows are accepted by the DSL in addition to <code>--&gt;</code>. All of these work:  <code>&gt;</code>, <code>→</code> <code>↣</code>, <code>↦</code>, <code>⇾</code>, <code>⟶</code>, <code>⟼</code>, <code>⥟</code>, <code>⥟</code>, <code>⇀</code>, <code>⇁</code>. Backwards arrows can also be used to write the reaction in the opposite direction. For example, these reactions are equivalent:</p><pre><code class="language- hljs">rn = @reaction_network begin
  1.0, X + Y --&gt; XY
  1.0, X + Y → XY
  1.0, XY ← X + Y
  1.0, XY &lt;-- X + Y
end</code></pre><h2 id="Bi-directional-arrows-for-reversible-reactions"><a class="docs-heading-anchor" href="#Bi-directional-arrows-for-reversible-reactions">Bi-directional arrows for reversible reactions</a><a id="Bi-directional-arrows-for-reversible-reactions-1"></a><a class="docs-heading-anchor-permalink" href="#Bi-directional-arrows-for-reversible-reactions" title="Permalink"></a></h2><p>Bi-directional arrows, including bidirectional Unicode arrows like ↔, can be used to designate a reversible reaction. For example, these two models are equivalent:</p><pre><code class="language- hljs">rn = @reaction_network begin
  2.0, X + Y --&gt; XY
  2.0, X + Y &lt;-- XY
end</code></pre><pre><code class="language- hljs">rn2 = @reaction_network begin
  (2.0,2.0), X + Y &lt;--&gt; XY
end</code></pre><p>If the reaction rates in the backward and forward directions are different, they can be designated in the following way:</p><pre><code class="language- hljs">rn = @reaction_network begin
  (2.0,1.0), X + Y &lt;--&gt; XY
end</code></pre><p>which is identical to</p><pre><code class="language- hljs">rn = @reaction_network begin
  2.0, X + Y --&gt; XY
  1.0, X + Y &lt;-- XY
end</code></pre><h2 id="Combining-several-reactions-in-one-line"><a class="docs-heading-anchor" href="#Combining-several-reactions-in-one-line">Combining several reactions in one line</a><a id="Combining-several-reactions-in-one-line-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-several-reactions-in-one-line" title="Permalink"></a></h2><p>Several similar reactions can be combined in one line by providing a tuple of reaction rates and/or substrates and/or products. If several tuples are provided, they must all be of identical length. These pairs of reaction networks are all identical.</p><p>Pair 1:</p><pre><code class="language- hljs">rn1 = @reaction_network begin
  1.0, S --&gt; (P1,P2)
end</code></pre><pre><code class="language- hljs">rn2 = @reaction_network begin
  1.0, S --&gt; P1
  1.0, S --&gt; P2
end</code></pre><p>Pair 2:</p><pre><code class="language- hljs">rn1 = @reaction_network begin
  (1.0,2.0), (S1,S2) --&gt; P
end</code></pre><pre><code class="language- hljs">rn2 = @reaction_network begin
  1.0, S1 --&gt; P
  2.0, S2 --&gt; P
end</code></pre><p>Pair 3:</p><pre><code class="language- hljs">rn1 = @reaction_network begin
  (1.0,2.0,3.0), (S1,S2,S3) --&gt; (P1,P2,P3)
end</code></pre><pre><code class="language- hljs">rn2 = @reaction_network begin
  1.0, S1 --&gt; P1
  2.0, S2 --&gt; P2
  3.0, S3 --&gt; P3
end</code></pre><p>This can also be combined with bi-directional arrows, in which case separate tuples can be provided for the backward and forward reaction rates. These reaction networks are identical</p><pre><code class="language- hljs">rn1 = @reaction_network begin
 (1.0,(1.0,2.0)), S &lt;--&gt; (P1,P2)
end</code></pre><pre><code class="language- hljs">rn2 = @reaction_network begin
  1.0, S --&gt; P1
  1.0, S --&gt; P2
  1.0, P1 --&gt; S
  2.0, P2 --&gt; S
end</code></pre><h2 id="Variable-reaction-rates"><a class="docs-heading-anchor" href="#Variable-reaction-rates">Variable reaction rates</a><a id="Variable-reaction-rates-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-reaction-rates" title="Permalink"></a></h2><p>Reaction rates do not need to be a single parameter or a number, but can also be expressions depending on time or the current amounts of system species (when, for example, one species can activate the production of another). For instance, this is a valid notation:</p><pre><code class="language- hljs">rn = @reaction_network begin
  1.0, X --&gt; ∅
  k*X, Y --&gt; ∅
end</code></pre><p>corresponding to the ODE model</p><pre><code class="language- hljs">convert(ODESystem,rn)</code></pre><p>With respect to the corresponding mass action ODE model, this is actually equivalent to the reaction system</p><pre><code class="language- hljs">rn = @reaction_network begin
  1.0, X --&gt; ∅
  k, X + Y --&gt; X
end</code></pre><pre><code class="language- hljs">convert(ODESystem,rn)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>While the ODE models corresponding to the preceding two reaction systems are identical, in the latter example the <code>Reaction</code> stored in <code>rn</code> will be classified as <a href="../../api/catalyst_api/#Catalyst.ismassaction"><code>ismassaction</code></a> while in the former it will not, which can impact optimizations used in generating <code>JumpSystem</code>s. For this reason, it is recommended to use the latter representation when possible.</p></div></div><p>Most expressions and functions are valid reaction rates, e.g.:</p><pre><code class="language- hljs">using SpecialFunctions
rn = @reaction_network begin
  2.0*X^2, 0 --&gt; X + Y
  t*gamma(Y), X --&gt; ∅
  pi*X/Y, Y --&gt; ∅
end</code></pre><p>where here <code>t</code> always denotes Catalyst&#39;s time variable. Please note that many user-defined functions can be called directly, but others will require registration with Symbolics.jl (<a href="../../faqs/#user_functions">see the faq</a>).</p><h2 id="dsl_description_explicit_species"><a class="docs-heading-anchor" href="#dsl_description_explicit_species">Explicit specification of network species and parameters</a><a id="dsl_description_explicit_species-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_description_explicit_species" title="Permalink"></a></h2><p>Recall that the <code>@reaction_network</code> macro automatically designates symbols used in the macro as either parameters or species, with symbols that appear as a substrate or product being species, and all other symbols becoming parameters (i.e. those that only appear within a rate expression and/or as <a href="../parametric_stoichiometry/#parametric_stoichiometry">stoichiometric coefficients</a>). Sometimes, one might want to manually override this default behavior for a given symbol. E.g one might want something to be considered as a species, even if it only appears within a rate expression. In the following network</p><pre><code class="language- hljs">rn = @reaction_network begin
  k*X, Y --&gt; 0
end</code></pre><p><code>X</code> (as well as <code>k</code>) will be considered a parameter.</p><p>By using the <code>@species</code> and <code>@parameters</code> options within the <code>@reaction_network</code> macro, one can manually declare that specified symbols should be considered a species or parameter. E.g in:</p><pre><code class="language- hljs">rn = @reaction_network begin
  @species X(t) Y(t)
  k*X, Y --&gt; 0
end</code></pre><p><code>X</code> and <code>Y</code> are set as species. Please note that when declaring species using the <code>@species</code> option, their dependant variable (almost always <code>t</code>) also needs to be designated. Similarly in</p><pre><code class="language- hljs">rn = @reaction_network begin
  @parameters k
  k*X, Y --&gt; 0
end</code></pre><p>both <code>X</code> and <code>k</code> will be considered as parameters. It is also possible to use both options simultaneously, allowing users to fully specify which symbols are species and/or parameters:</p><pre><code class="language- hljs">rn = @reaction_network begin
  @species X(t) Y(t)
  @parameters k
  k*X, Y --&gt; 0
end</code></pre><p>Here, <code>X</code> and <code>Y</code> are designated as species and <code>k</code> as a parameter.</p><p>The lists provided to the <code>@species</code> and <code>@parameters</code> options do not need to be extensive. Any symbol that appears in neither list will use the default option as determined by the macro. E.g. in the previous example, where we only want to change the default designation of <code>X</code> (making it a species rather than a parameter), we can simply write:</p><pre><code class="language- hljs">rn = @reaction_network begin
  @species X(t)
  k*X, Y --&gt; 0
end</code></pre><p>Finally, note that the <code>@species</code> and <code>@parameters</code> options can also be used in <code>begin ... end</code> block form, allowing more formatted lists of species/parameters:</p><pre><code class="language- hljs">rn = @reaction_network begin
  @parameters begin
      d1
      d2
  end
  @species begin
      X1(t)
      X2(t)
  end
  d2, X2 --&gt; 0
  d1, X1 --&gt; 0
end</code></pre><p>This can be especially useful when declaring default values for clarity of model specification (see the next section).</p><h2 id="dsl_description_defaults"><a class="docs-heading-anchor" href="#dsl_description_defaults">Setting default values for initial conditions and parameters</a><a id="dsl_description_defaults-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_description_defaults" title="Permalink"></a></h2><p>When using the <code>@species</code> and <code>@parameters</code> macros to declare species and/or parameters, one can also provide default initial conditions for each species and values for each parameter:</p><pre><code class="language- hljs">rn = @reaction_network begin
  @species X(t)=1.0
  @parameters p=1.0 d=0.1
  p, 0 --&gt; X
  d, X --&gt; ∅
end</code></pre><p>This system can now be simulated without providing initial condition or parameter vectors to the DifferentialEquations.jl solvers:</p><pre><code class="language- hljs">using DifferentialEquations, Plots
u0 = []
tspan = (0.0, 10.0)
p = []
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><p>When providing default values, it is possible to do so for only a subset of the species or parameters, in which case the rest can be specified when constructing the problem type to solve:</p><pre><code class="language- hljs">rn = @reaction_network begin
  @species X(t)
  @parameters p=1.0 d
  p, 0 --&gt; X
  d, X --&gt; 0
end

u0 = [:X =&gt; 1.0]
tspan = (0.0, 10.0)
p = [:d =&gt; .1]
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><p>Finally, default values can be overridden by passing mapping vectors to the DifferentialEquations.jl problem being constructed. Only those initial conditions or parameters for which we want to change their value from the default will need to be passed</p><pre><code class="language- hljs">u0 = [:X =&gt; 1.0]
tspan = (0.0, 10.0)
p = [:p =&gt; 2.0, :d =&gt; .1]   # we change p to 2.0
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><h2 id="Constant/fixed-species"><a class="docs-heading-anchor" href="#Constant/fixed-species">Constant/fixed species</a><a id="Constant/fixed-species-1"></a><a class="docs-heading-anchor-permalink" href="#Constant/fixed-species" title="Permalink"></a></h2><p>It is possible to fix the amount of a species in a reaction. Without fixing a species, a reaction could look like</p><pre><code class="language- hljs">rn = @reaction_network begin
    k, X + Y --&gt; 0
end</code></pre><pre><code class="language- hljs">ode_sys = convert(ODESystem, rn)</code></pre><pre><code class="language- hljs">equations(ode_sys)</code></pre><p>Fixing a species could either be achieved by modifying the reaction specification and specifying constant species explicitly as species as described <a href="#dsl_description_explicit_species">above</a>, i.e.,</p><pre><code class="language- hljs">rn = @reaction_network begin
    @species X(t)
    k * X, Y --&gt; 0
end</code></pre><pre><code class="language- hljs">ode_sys = convert(ODESystem, rn)</code></pre><pre><code class="language- hljs">equations(ode_sys)</code></pre><p>The species can of course also just be used as parameter - using the same modification of the reaction, i.e.,</p><pre><code class="language- hljs">rn = @reaction_network begin
    k * X, Y --&gt; 0
end</code></pre><pre><code class="language- hljs">ode_sys = convert(ODESystem, rn)</code></pre><pre><code class="language- hljs">equations(ode_sys)</code></pre><p>The same result can also be achieved by declaring a species as fixed/constant without having to change the reaction itself, i.e.,</p><pre><code class="language- hljs">rn = @reaction_network begin
    @parameters X [isconstantspecies = true]
    k, X + Y --&gt; 0
end</code></pre><pre><code class="language- hljs">ode_sys = convert(ODESystem, rn)</code></pre><pre><code class="language- hljs">equations(ode_sys)</code></pre><h2 id="dsl_description_parametric_initial_conditions"><a class="docs-heading-anchor" href="#dsl_description_parametric_initial_conditions">Setting initial conditions that depend on parameters</a><a id="dsl_description_parametric_initial_conditions-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_description_parametric_initial_conditions" title="Permalink"></a></h2><p>It is possible to set the initial condition of one (or several) species so that they depend on some system parameter. This is done in a similar way as default initial conditions, but giving the parameter instead of a value. When doing this, we also need to ensure that the initial condition parameter is a variable of the system:</p><pre><code class="language- hljs">rn = @reaction_network begin
  @parameters X0
  @species X(t)=X0
  p, 0 --&gt; X
  d, X --&gt; ∅
end</code></pre><p>We can now simulate the network without providing any initial conditions:</p><pre><code class="language- hljs">u0 = []
tspan = (0.0, 10.0)
p = [:p =&gt; 2.0, :d =&gt; .1, :X0 =&gt; 1.0]
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><h2 id="Naming-the-generated-ReactionSystem"><a class="docs-heading-anchor" href="#Naming-the-generated-ReactionSystem">Naming the generated <code>ReactionSystem</code></a><a id="Naming-the-generated-ReactionSystem-1"></a><a class="docs-heading-anchor-permalink" href="#Naming-the-generated-ReactionSystem" title="Permalink"></a></h2><p>ModelingToolkit uses system names to allow for compositional and hierarchical models. To specify a name for the generated <code>ReactionSystem</code> via the <a href="../../api/catalyst_api/#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro, just place the name before <code>begin</code>:</p><pre><code class="language- hljs">rn = @reaction_network production_degradation begin
  p, ∅ --&gt; X
  d, X --&gt; ∅
end
ModelingToolkit.nameof(rn) == :production_degradation</code></pre><h2 id="Pre-defined-functions"><a class="docs-heading-anchor" href="#Pre-defined-functions">Pre-defined functions</a><a id="Pre-defined-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-defined-functions" title="Permalink"></a></h2><p>Hill functions and a Michaelis-Menten function are pre-defined and can be used as rate laws. Below, the pair of reactions within <code>rn1</code> are equivalent, as are the pair of reactions within <code>rn2</code>:</p><pre><code class="language- hljs">rn1 = @reaction_network begin
  hill(X,v,K,n), ∅ --&gt; X
  v*X^n/(X^n+K^n), ∅ --&gt; X
end</code></pre><pre><code class="language- hljs">rn2 = @reaction_network begin
  mm(X,v,K), ∅ --&gt; X
  v*X/(X+K), ∅ --&gt; X
end</code></pre><p>Repressor Hill (<code>hillr</code>) and Michaelis-Menten (<code>mmr</code>) functions are also provided:</p><pre><code class="language- hljs">rn1 = @reaction_network begin
  hillr(X,v,K,n), ∅ --&gt; X
  v*K^n/(X^n+K^n), ∅ --&gt; X
end</code></pre><pre><code class="language- hljs">rn2 = @reaction_network begin
  mmr(X,v,K), ∅ --&gt; X
  v*K/(X+K), ∅ --&gt; X
end</code></pre><p>Please see the API <a href="../../api/catalyst_api/#api_rate_laws">Rate Laws</a> section for more details.</p><h2 id="Including-non-species-variables"><a class="docs-heading-anchor" href="#Including-non-species-variables">Including non-species variables</a><a id="Including-non-species-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Including-non-species-variables" title="Permalink"></a></h2><p>Non-species state variables can be specified in the DSL using the <code>@variables</code> macro. These are declared similarly to species. For example,</p><pre><code class="language- hljs">rn_with_volume = @reaction_network begin
  @variables V(t)
  k*V, 0 --&gt; A
end</code></pre><p>creates a network with one species</p><pre><code class="language- hljs">species(rn_with_volume)</code></pre><p>and one non-species</p><pre><code class="language- hljs">nonspecies(rn_with_volume)</code></pre><p>giving two state variables, always internally ordered by species and then nonspecies:</p><pre><code class="language- hljs">states(rn_with_volume)</code></pre><p><code>rn_with_volume</code> could then be extended with constraint equations for how <code>V(t)</code> evolves in time, see the <a href="../constraint_equations/#constraint_equations">associated tutorial</a>.</p><h2 id="Specifying-alternative-time-variables-and/or-extra-independent-variables"><a class="docs-heading-anchor" href="#Specifying-alternative-time-variables-and/or-extra-independent-variables">Specifying alternative time variables and/or extra independent variables</a><a id="Specifying-alternative-time-variables-and/or-extra-independent-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-alternative-time-variables-and/or-extra-independent-variables" title="Permalink"></a></h2><p>While the DSL defaults to allowing <code>t</code> as the time variable, one can use the <code>@ivs</code> macro to specify an alternative independent variable. For example, to make <code>s</code> the default time variable one can say</p><pre><code class="language- hljs">rn_with_s = @reaction_network begin
    @ivs s
    @variables V(s)
    @species B(s)
    k, A + V*B --&gt; C
end
show(stdout, MIME&quot;text/plain&quot;(), rn_with_s)  # hide</code></pre><p>where we see all states are now functions of <code>s</code>.</p><p>Similarly, if one wants states to be functions of more than one independent variable, for example to encode a spatial problem, one can list more than one variable, i.e. <code>@ivs t x y</code>. Here the first listed independent variable is always chosen to represent time. For example,</p><pre><code class="language- hljs">rn_with_many_ivs = @reaction_network begin
    @ivs s x
    @variables V1(s) V2(s,x)
    @species A(s) B(s,x)
    k, V1*A --&gt; V2*B + C
end
show(stdout, MIME&quot;text/plain&quot;(), rn_with_many_ivs)  # hide</code></pre><p>Here again <code>s</code> will be the time variable, and any inferred species, <code>C</code> in this case, are made functions of both variables, i.e. <code>C(s, x)</code>.</p><h2 id="dsl_description_interpolation_of_variables"><a class="docs-heading-anchor" href="#dsl_description_interpolation_of_variables">Interpolation of Julia variables</a><a id="dsl_description_interpolation_of_variables-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_description_interpolation_of_variables" title="Permalink"></a></h2><p>The DSL allows Julia variables to be interpolated for the network name, within rate constant expressions, or for species/stoichiometry within reactions. Using the lower-level symbolic interface we can then define symbolic variables and parameters outside of the macro, which can then be used within expressions in the DSL (see the <a href="../programmatic_CRN_construction/#programmatic_CRN_construction">Programmatic Construction of Symbolic Reaction Systems</a> tutorial for details on the lower-level symbolic interface). For example,</p><pre><code class="language- hljs">@parameters k α
@variables t
@species A(t)
spec = A
par = α
rate = k*A
name = :network
rn = @reaction_network $name begin
    $rate*B, 2*$spec + $par*B --&gt; $spec + C
  end</code></pre><p>As the parameters <code>k</code> and <code>α</code> were pre-defined and appeared via interpolation, we did not need to declare them within the <code>@reaction_network</code> macro, i.e. they are automatically detected as parameters:</p><pre><code class="language- hljs">parameters(rn)</code></pre><p>as are the species coming from interpolated variables</p><pre><code class="language- hljs">species(rn)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When using interpolation, expressions like <code>2$spec</code> won&#39;t work; the multiplication symbol must be explicitly included like <code>2*$spec</code>.</p></div></div><h2 id="Including-observables"><a class="docs-heading-anchor" href="#Including-observables">Including observables</a><a id="Including-observables-1"></a><a class="docs-heading-anchor-permalink" href="#Including-observables" title="Permalink"></a></h2><p>Sometimes, one might want to include observable variables. These are variables that can be computed directly from the other system variables (rather than having their values implicitly given through some differential equation). These can be introduced through the <code>@observables</code> option.</p><p>Let us consider a simple example where two species (<span>$X$</span> and <span>$Y$</span>) are produced and degraded at constant rates. They can also bind, forming a complex (<span>$XY$</span>). If we want to access the total amount of <span>$X$</span> in the system we can create an observable that denotes this quantity (<span>$Xtot = X + XY$</span>). Here, we create observables for the total amount of <span>$X$</span> and <span>$Y$</span>:</p><pre><code class="language- hljs">using Catalyst # hide
rn = @reaction_network begin
  @observables begin
    Xtot ~ X + XY
    Ytot ~ Y + XY
  end
  (pX,dX), 0 &lt;--&gt; X
  (pY,dY), 0 &lt;--&gt; Y
  (kB,kD), X + Y &lt;--&gt; XY
end</code></pre><p>The <code>@observables</code> option is followed by one line for each observable formula (enclosed by a <code>begin ... end</code> block). The left-hand sides indicate the observables&#39; names, and the right-hand sides how their values are computed. The two sides are separated by a <code>~</code>. </p><p>If we now simulate our model:</p><pre><code class="language- hljs">using DifferentialEquations # hide
u0 = [:X =&gt; 0.0, :Y =&gt; 0.0, :XY =&gt; 0.0]
tspan = (0.0, 10.0)
ps = [:pX =&gt; 1.0, :dX =&gt; 0.2, :pY =&gt; 1.0, :dY =&gt; 0.5, :kB =&gt; 1.0, :kD =&gt; 0.2]
oprob = ODEProblem(rn, u0, tspan, ps)
sol = solve(oprob)
nothing # hide</code></pre><p>we can index the solution using our observables (just like for <a href="../../catalyst_applications/simulation_structure_interfacing/#simulation_structure_interfacing_solutions">other variables</a>). E.g. we can receive a vector with all <span>$Xtot$</span> values using</p><pre><code class="language- hljs">sol[:Xtot]</code></pre><p>similarly, we can plot the values of <span>$Xtot$</span> and <span>$Ytot$</span> using</p><pre><code class="language- hljs">plot(sol; idxs=[:Xtot, :Ytot], label=[&quot;Total X&quot; &quot;Total Y&quot;])</code></pre><p>If we only wish to provide a single observable, the <code>begin ... end</code> block is note required. E.g., to record only the total amount of <span>$X$</span> we can use:</p><pre><code class="language- hljs">using Catalyst # hide
rn = @reaction_network begin
  @observables Xtot ~ X + XY
  (pX,dX), 0 &lt;--&gt; X
  (pY,dY), 0 &lt;--&gt; Y
  (kB,kD), X + Y &lt;--&gt; XY
end</code></pre><p>Finally, some general rules for creating observables:</p><ul><li>Observables can depend on any species, parameters, or variables, but not on other observables.</li><li>All observables components appearing on the right side of the <code>~</code> must be declared somewhere (i.e., they cannot only appear as a part of the observables formula).</li><li>Only a single <code>@observables</code> option block can be used in each <code>@reaction_network</code> call.</li><li>The left-hand side of the observables expression must be a single symbol, indicating the observable&#39;s name.</li><li>Metadata can, however, be provided, e.g through <code>@observables (Xtot, [description=&quot;Total amount of X&quot;]) ~ X + XY</code>.</li><li>The right-hand side of the observables expression can be any valid algebraic expression.</li><li>Observables are (by default, but this can be changed) considered <code>variables</code> (and not <code>species</code>). This can be changed by e.g. pre-declaring them using the <code>@species</code> option:</li></ul><pre><code class="language- hljs">using Catalyst # hide
rn = @reaction_network begin
  @species Xtot(t)
  @observables Xtot ~ X1 + X2
  (k1,k2), X1 &lt;--&gt; X2
end
nothing # hide</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../introduction_to_catalyst/introduction_to_catalyst/">« Introduction to Catalyst</a><a class="docs-footer-nextpage" href="../programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 8 March 2024 17:01">Friday 8 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
