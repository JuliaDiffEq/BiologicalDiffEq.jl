var documenterSearchIndex = {"docs":
[{"location":"model_simulation/simulation_plotting/#simulation_plotting","page":"Simulation plotting","title":"Simulation plotting","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Catalyst uses the Plots.jl package for performing all plots. This section provides a brief summary of some useful plotting options, while Plots.jl's documentation provides a more throughout description of how to tune your plots.","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"note: Note\nMakie.jl is a popular alternative to the Plots.jl package. While it is not used within Catalyst's documentation, it is worth considering (especially for users interested in interactivity, or increased control over their plots).","category":"page"},{"location":"model_simulation/simulation_plotting/#simulation_plotting_options","page":"Simulation plotting","title":"Common plotting options","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Let us consider the oscillating Brusselator model. We have previously shown how model simulation solutions can be plotted using the plot function. Here we plot an ODE simulation from the Brusselator:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"using Catalyst, OrdinaryDiffEq, Plots\n\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\nu0 = [:X => 1.0, :Y => 0.0]\ntspan = (0.0, 50.0)\nps = [:A => 1.0, :B => 4.0]\n\noprob = ODEProblem(brusselator, u0, tspan, ps)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Various plotting options can be provided as optional arguments to the plot command. Common options include:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"lw: Determine plot line widths.\nla: Determine plot line's transparency (at la = 0.0 lines are fully transparent, i.e. not visible).\nlinestyle: Determines plot line style.\ncolor: Determines the line colours.\nlegend: Determines the position of the legend/labels.\nlabel: Determines label texts.\nxguide, yguide: Determines x and y axis labels.\ntitle: Determines plot title.\nlegendfontsize, guidefontsize, titlefontsize: Determines the font size of the labels, x and y guides, and title, respectively.","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Here, we re-plot our simulations, utilising some of these options (legend = :none is used to disable the legends).","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; lw = 4, linestyle = :dash, color = :green, xguide = \"Time\", yguide = \"Concentration\", guidefontsize = 14)","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Note that, by default, Catalyst uses xguide = \"t\". Here, however, we modify this to xguide = \"Time\". We also note that the color = :green change both lines' colours to green. To set different colours for each line, we provide these as a vector without , in-between elements (in Julia interpreted as a matrix with its first dimension equal to 1):","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; lw = 4, color = [:green :purple])","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"A full list of available colours can be found here. A full list of possible plotting options can be found here (look at the list of various plot attributes, e.g. \"Series Attributes\"). if there is some option(s) you intend to use multiple times, you can call the default function using these, in which case they will be used for all subsequent plots. E.g. here:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"default(framestyle = :box, grid = false)","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"we designate a box-style frame, and remove the faint background grid, for all subsequent plots in this tutorial.","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"A useful option unique to Catalyst (and other DifferentialEquations.jl-based) plots is idxs. Its input is a vector, listing all the species (or quantities) that should be plotted. I.e.","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; idxs = [:X])","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"can be used to plot X only. When only a single argument is given, the vector form is unnecessary (e.g. idxs = :X could have been used instead). If symbolic species representation is used, this can be used to designate any algebraic expression(s) that should be plotted. E.g. here we plot the total concentration of X + Y throughout the simulation:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; idxs = brusselator.X + brusselator.Y)","category":"page"},{"location":"model_simulation/simulation_plotting/#simulation_plotting_options-2","page":"Simulation plotting","title":"Multi-plot plots","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"It is possible to save plots in variables. These can then be used as input to the plot command. Here, the plot command can be used to create plots containing multiple plots (by providing multiple inputs). E.g. here we plot the concentration of X and Y in separate subplots:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plt_X = plot(sol; idxs = [:X])\nplt_Y = plot(sol; idxs = [:Y])\nplot(plt_X, plt_Y)","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"When working with subplots, the layout and size options are typically useful. Here we use layout to put the first plot above the second one, and size to reshape the plot size:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(plt_X, plt_Y; layout = (2,1), size = (700,500))","category":"page"},{"location":"model_simulation/simulation_plotting/#simulation_plotting_options-3","page":"Simulation plotting","title":"Saving plots","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Once a plot has been saved to a variable, the savefig function can be used to save it to a file. Here we save our Brusselator plot simulation (the first argument) to a file called \"saved_plot.png\" (the second argument):","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plt = plot(sol)\nsavefig(plt, \"saved_plot.png\")\nrm(\"saved_plot.png\") # hide","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"The plot file type is automatically determined from the extension (if none is given, a .png file is created).","category":"page"},{"location":"model_simulation/simulation_plotting/#simulation_plotting_options-4","page":"Simulation plotting","title":"Phase-space plots","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"By default, simulations are plotted as species concentrations over time. However, phase space plots are also possible. This is done by designating the axis arguments using the idxs option, but providing them as a tuple. E.g. here we plot our simulation in X-Y space:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; idxs = (:X, :Y))","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#programmatic_generative_linear_pathway","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"This example will show how to use programmatic, generative, modelling to model a system implicitly. I.e. rather than listing all system reactions explicitly, the reactions are implicitly generated from a simple set of rules. This example is specifically designed to show how programmatic modelling enables generative workflows (demonstrating one of its advantages as compared to DSL-based modelling). In our example, we will model linear pathways, so we will first introduce these. Next, we will model them first using the DSL, and then using a generative programmatic workflow.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#programmatic_generative_linear_pathway_intro","page":"Programmatic, generative, modelling of a linear pathway","title":"Linear pathways","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Linear pathways consists of a series of species (X_0, X_1, X_2, ..., X_n) where each activates the subsequent one. These are often modelled through the following reaction system:","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"X_i-1tauhspace033cm  to X_i\n1tauhspace033cm X_i to ","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"for i = 1  n, where the activation of X_1 depends on some input species X_0. ","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"A common use of these linear pathways is the implementation of time delays. Consider a species X(t) which is activated by species X_0(t). This can be modelled by making the production rate of X(t) a function of the time-delayed value of X_0(t):","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"f(X_0(t-tau))hspace033cm  to X","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"This is a so-called discrete-delay (which will generate a delay differential equation). However, in reality, X(t) probably does not depend on only f(X_0(t-tau)), but rather a distribution of previous X_0(t) values. This can be modelled through a distributed delays","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"f(int_0^inf X_0(t-tau)g(tau) dtau)hspace033cm  to X","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"for some kernel g(tau). Here, a common kernel is a gamma distribution, which generates a gamma-distributed delay:","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"g(tau alpha beta) = fracbeta^alphatau^alpha-1Gamma(alpha)e^-betatau","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"When this is converted to an ODE, this generates an integro-differential equation. These (as well as the simpler delay differential equations) can be difficult to solve and analyse (especially when SDE or jump simulations are desired). Here, the linear chain trick can be used to instead model the delay as a linear pathway of the form described above[1]. A result by Fargue shows that this is equivalent to a gamma-distributed delay, where alpha is equivalent to n (the number of species in our linear pathway) and beta to %\\tau$ (the delay length term)[2]. While modelling time delays using the linear chain trick introduces additional system species, it is often advantageous as it enables simulations using standard ODE, SDE, and Jump methods.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#programmatic_generative_linear_pathway_dsl","page":"Programmatic, generative, modelling of a linear pathway","title":"Modelling linear pathways using the DSL","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"It is known that two linear pathways have similar delays if the following equality holds:","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"frac1tau_1 n_1 = frac1tau_2 n_2","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"However, the shape of the delay depends on the number of intermediaries (n). Here we wish to investigate this shape for two choices of n (n = 3 and n = 10). We do so by implementing two models using the DSL, one for each n. ","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"using Catalyst\n\nlp_n3 = @reaction_network begin\n    1/τ, X0 --> 0\n    (X0/τ, 1/τ), 0 <--> X1\n    (X1/τ, 1/τ), 0 <--> X2\n    (X2/τ, 1/τ), 0 <--> X3\nend\n\nlp_n10 = @reaction_network begin\n    1/τ, X0 --> 0\n    (X0/τ, 1/τ), 0 <--> X1\n    (X1/τ, 1/τ), 0 <--> X2\n    (X2/τ, 1/τ), 0 <--> X3\n    (X3/τ, 1/τ), 0 <--> X4\n    (X4/τ, 1/τ), 0 <--> X5\n    (X5/τ, 1/τ), 0 <--> X6\n    (X6/τ, 1/τ), 0 <--> X7\n    (X7/τ, 1/τ), 0 <--> X8\n    (X8/τ, 1/τ), 0 <--> X9\n    (X9/τ, 1/τ), 0 <--> X10\nend\nnothing # hide","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Next, we prepare an ODE for each model (scaling the initial concentration of X_0 and the value of tau appropriately for each model).","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"using OrdinaryDiffEq, Plots\nu0_n3 = [:X0 => 3*1.0, :X1 => 0.0, :X2 => 0.0, :X3 => 0.0]\nps_n3 = [:τ => 1.0/3]\noprob_n3 = ODEProblem(lp_n3, u0_n3, (0.0, 5.0), ps_n3)\n\nu0_n10 = [:X0 => 10*1.0, :X1 => 0.0, :X2 => 0.0, :X3 => 0.0, :X4 => 0.0, :X5 => 0.0, :X6 => 0.0, :X7 => 0.0, :X8 => 0.0, :X9 => 0.0, :X10 => 0.0]\nps_n10 = [:τ => 1.0/10.0]\noprob_n10 = ODEProblem(lp_n10, u0_n10, (0.0, 5.0), ps_n10)\nnothing # hide","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Finally, we plot the concentration of the final species in each linear pathway, noting that while the two pulses both peak at t = 10, their shapes depend on n.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"sol_n3 = solve(oprob_n3)\nsol_n10 = solve(oprob_n10)\nplot(sol_n3; idxs = :X3, label = \"n = 3\")\nplot!(sol_n10; idxs = :X10, label = \"n = 10\")","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#programmatic_generative_linear_pathway_generative","page":"Programmatic, generative, modelling of a linear pathway","title":"Modelling linear pathways using programmatic, generative, modelling","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Above, we investigated the impact of linear pathways' lengths on their behaviours. Since the models were implemented using the DSL, we had to implement a new model for each pathway (in each case writing out all reactions). Here, we will instead show how programmatic modelling can be used to generate pathways of arbitrary lengths.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"First, we create a function, generate_lp, which creates a linear pathway model of length n. It utilises vector variables to create an arbitrary number of species, and also creates an observable for the final species of the chain.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"using Catalyst # hide\nt = default_t()\n@parameters τ\nfunction generate_lp(n)\n    # Creates a vector `X` with n+1 species.\n    @species X(t)[1:n+1]\n    @species Xend(t)\n\n    # Generate\n    #     (1) A degradation reaction for the input species.\n    #     (2) Production reactions for all intermediary species.\n    #     (2) Degradation reactions for all intermediary species.\n    rxs = [\n        Reaction(1/τ, [X[1]], []);\n        [Reaction(X[i]/τ, [], [X[i+1]]) for i in 1:n];\n        [Reaction(1/τ, [X[i+1]], []) for i in 1:n]     \n    ]\n\n    # Assembly and return a complete `ReactionSystem` (including an observable for the final species).\n    @named lp_n = ReactionSystem(rxs, t; observed = [Xend ~ X[end]])\n    return complete(lp_n)\nend\nnothing # hide","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Next, we create a function that generates an ODEProblem (with appropriate initial conditions and parameter values) for arbitrarily lengthed linear pathway models.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"function generate_oprob(n)\n    lp = generate_lp(n)\n    X_init = fill(0.0, n + 1)\n    X_init[1] = n * 1.0\n    u0 = [lp.X => X_init]\n    ps = [τ => 1.0 / n]\n    return ODEProblem(lp, u0, (0.0, 5.0), ps)\nend\nnothing # hide","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"We can now simulate linear pathways of arbitrary lengths using a simple syntax. We use this to recreate our previous result from the DSL:","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"using OrdinaryDiffEq, Plots # hide\nsol_n3 = solve(generate_oprob(3))\nsol_n10 = solve(generate_oprob(10))\nplot(sol_n3; idxs = :Xend, label = \"n = 3\")\nplot!(sol_n10; idxs = :Xend, label = \"n = 10\")","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"If we wish to investigate the behaviour of a pathway with a different length, we can easily add this to the plot","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"sol_n20 = solve(generate_oprob(20))\nplot!(sol_n20; idxs = :Xend, label = \"n = 20\")","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#References","page":"Programmatic, generative, modelling of a linear pathway","title":"References","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"[1]: J. Metz, O. Diekmann The Abstract Foundations of Linear Chain Trickery (1991).","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"[2]: D. Fargue Reductibilite des systemes hereditaires a des systemes dynamiques (regis par des equations differentielles aux derivees partielles), Comptes rendus de l'Académie des Sciences (1973).","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"[3]: N. Korsbo, H. Jönsson It’s about time: Analysing simplifying assumptions for modelling multi-step pathways in systems biology, PLoS Computational Biology (2020).","category":"page"},{"location":"home/#Catalyst.jl-for-Reaction-Network-Modeling","page":"Home","title":"Catalyst.jl for Reaction Network Modeling","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Catalyst.jl is a symbolic modeling package for analysis and high performance simulation of chemical reaction networks. Catalyst defines symbolic ReactionSystems, which can be created programmatically or easily specified using Catalyst's domain specific language (DSL). Leveraging ModelingToolkit.jl and Symbolics.jl, Catalyst enables large-scale simulations through auto-vectorization and parallelism. Symbolic ReactionSystems can be used to generate ModelingToolkit-based models, allowing the easy simulation and parameter estimation of mass action ODE models, Chemical Langevin SDE models, stochastic chemical kinetics jump process models, and more. Generated models can be used with solvers throughout the broader SciML ecosystem, including higher level SciML packages (e.g. for sensitivity analysis, parameter estimation, machine learning applications, etc).","category":"page"},{"location":"home/#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"A DSL provides a simple and readable format for manually specifying chemical reactions.\nCatalyst ReactionSystems provide a symbolic representation of reaction networks, built on ModelingToolkit.jl and Symbolics.jl.\nNon-integer (e.g. Float64) stoichiometric coefficients are supported for generating ODE models, and symbolic expressions for stoichiometric coefficients are supported for all system types.\nThe Catalyst.jl API provides functionality for extending networks, building networks programmatically, network analysis, and for composing multiple networks together.\nReactionSystems generated by the DSL can be converted to a variety of ModelingToolkit.AbstractSystems, including symbolic ODE, SDE and jump process representations.\nCoupled differential and algebraic constraint equations can be included in Catalyst models, and are incorporated during conversion to ODEs or steady state equations.\nConservation laws can be detected and applied to reduce system sizes, and generate non-singular Jacobians, during conversion to ODEs, SDEs, and steady state equations.\nBy leveraging ModelingToolkit, users have a variety of options for generating optimized system representations to use in solvers. These include construction of dense or sparse Jacobians, multithreading or parallelization of generated derivative functions, automatic classification of reactions into optimized jump types for Gillespie type simulations, automatic construction of dependency graphs for jump systems, and more.\nGenerated systems can be solved using any DifferentialEquations.jl ODE/SDE/jump solver, and can be used within EnsembleProblems for carrying out parallelized parameter sweeps and statistical sampling. Plot recipes are available for visualizing the solutions.\nSymbolics.jl symbolic expressions and Julia Exprs can be obtained for all rate laws and functions determining the deterministic and stochastic terms within resulting ODE, SDE or jump models.\nLatexify can be used to generate LaTeX expressions corresponding to generated mathematical models or the underlying set of reactions.\nGraphviz can be used to generate and visualize reaction network graphs. (Reusing the Graphviz interface created in Catlab.jl.)","category":"page"},{"location":"home/#Packages-Supporting-Catalyst","page":"Home","title":"Packages Supporting Catalyst","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Catalyst ReactionSystems can be imported from SBML files via SBMLToolkit.jl, and from BioNetGen .net files and various stoichiometric matrix network representations using ReactionNetworkImporters.jl.\nMomentClosure.jl allows generation of symbolic ModelingToolkit ODESystems, representing moment closure approximations to moments of the Chemical Master Equation, from reaction networks defined in Catalyst.\nFiniteStateProjection.jl allows the construction and numerical solution of Chemical Master Equation models from reaction networks defined in Catalyst.\nDelaySSAToolkit.jl can augment Catalyst reaction network models with delays, and can simulate the resulting stochastic chemical kinetics with delays models.  \nBondGraphs.jl a package for constructing and analyzing bond graphs models, which can take Catalyst models as input.\nPEtab.jl a package that implements the PEtab format for fitting reaction network ODEs to data. Input can be provided either as SBML files or as Catalyst ReactionSystems.","category":"page"},{"location":"home/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Catalyst can be installed through the Julia package manager:","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Catalyst\")","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"To solve Catalyst models and visualize solutions, it is also recommended to install DifferentialEquations.jl and Plots.jl","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Pkg.add(\"DifferentialEquations\")\nPkg.add(\"Plots\")","category":"page"},{"location":"home/#Illustrative-Example","page":"Home","title":"Illustrative Example","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Here is a simple example of generating, visualizing and solving an SIR ODE model. We first define the SIR reaction model using Catalyst","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"using Catalyst\nrn = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Assuming Graphviz and is installed and command line accessible, the network can be visualized using the Graph command","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Graph(rn)","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"which in Jupyter notebooks will give the figure","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"(Image: SIR Network Graph)","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"To generate and solve a mass action ODE version of the model we use","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"using DifferentialEquations\np     = [:α => .1/1000, :β => .01]\ntspan = (0.0,250.0)\nu0    = [:S => 999.0, :I => 1.0, :R => 0.0]\nop    = ODEProblem(rn, u0, tspan, p)\nsol   = solve(op, Tsit5())       # use Tsit5 ODE solver","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"which we can plot as","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"using Plots\nplot(sol, lw=2)","category":"page"},{"location":"home/#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Catalyst developers are active on the Julia Discourse, and the Julia Slack's #sciml-bridged and #sciml-sysbio channels. For bugs or feature requests open an issue.","category":"page"},{"location":"home/#catalyst_citation","page":"Home","title":"Supporting and Citing Catalyst.jl","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"The software in this ecosystem was developed as part of academic research. If you would like to help support it, please star the repository as such metrics may help us secure funding in the future. If you use Catalyst as part of your research, teaching, or other activities, we would be grateful if you could cite our work:","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"@article{CatalystPLOSCompBio2023,\n    doi = {10.1371/journal.pcbi.1011530},\n    author = {Loman, Torkel E. AND Ma, Yingbo AND Ilin, Vasily AND Gowda, Shashi AND Korsbo, Niklas AND Yewale, Nikhil AND Rackauckas, Chris AND Isaacson, Samuel A.},\n    journal = {PLOS Computational Biology},\n    publisher = {Public Library of Science},\n    title = {Catalyst: Fast and flexible modeling of reaction networks},\n    year = {2023},\n    month = {10},\n    volume = {19},\n    url = {https://doi.org/10.1371/journal.pcbi.1011530},\n    pages = {1-19},\n    number = {10},\n}","category":"page"},{"location":"home/#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#behaviour_optimisation","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"In previous tutorials we have described how to use PEtab.jl and Optimization.jl for parameter fitting. This involves solving an optimisation problem (to find the parameter set yielding the best model-to-data fit). There are, however, other situations that require solving optimisation problems. Typically, these involve the creation of a custom cost function, which optimum can then be found using Optimization.jl. In this tutorial we will describe this process, demonstrating how parameter space can be searched to find values that achieve a desired system behaviour. A more throughout description on how to solve these problems is provided by Optimization.jl's documentation and the literature[1]. ","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#behaviour_optimisation_IFFL_example","page":"Optimization for non-data fitting purposes","title":"Maximising the pulse amplitude of an incoherent feed forward loop","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Incoherent feedforward loops (network motifs where a single component both activates and deactivates a downstream component) are able to generate pulses in response to step inputs[2]. In this tutorial we will consider such an incoherent feedforward loop, attempting to generate a system with as prominent a response pulse as possible.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Our model consists of 3 species: X (the input node), Y (an intermediary), and Z (the output node). In it, X activates the production of both Y and Z, with Y also deactivating Z. When X is activated, there will be a brief time window where Y is still inactive, and Z is activated. However, as Y becomes active, it will turn Z off. This creates a pulse of Z activity. To trigger the system, we create an event, which increases the production rate of X (pX) by a factor of 10 at time t = 10.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"using Catalyst\nincoherent_feed_forward = @reaction_network begin\n    @discrete_events [10.0] => [pX ~ 10*pX]\n    pX, 0 --> X\n    pY*X, 0 --> Y\n    pZ*X/Y, 0 --> Z\n    1.0, (X,Y,Z) --> 0\nend","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"To demonstrate this pulsing behaviour we will simulate the system for an example parameter set. We select an initial condition (u0) so the system begins in a steady state.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"using OrdinaryDiffEq, Plots\nexample_p = [:pX => 0.1, :pY => 1.0, :pZ => 1.0]\ntspan = (0.0, 50.0)\nexample_u0 = [:X => 0.1, :Y => 0.1, :Z => 1.0]\n\noprob = ODEProblem(incoherent_feed_forward, example_u0, tspan, example_p)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Here we note that, while X and Y reach new steady state levels in response to the increase in pX, Z resumes to its initial concentration after the pulse.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"We will now attempt to find the parameter set (pXpYpZ) which maximises the response pulse amplitude (defined by the maximum activity of Z subtracted by its steady state activity). To do this, we create a custom cost function:","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"function pulse_amplitude(p, _)\n    ps = Dict([:pX => p[1], :pY => p[2], :pZ => p[2]])\n    u0_new = [:X => ps[:pX], :Y => ps[:pX]*ps[:pY], :Z => ps[:pZ]/ps[:pY]^2]\n    oprob_local = remake(oprob; u0=  u0_new, p = ps)\n    sol = solve(oprob_local, Tsit5(); verbose = false, maxiters = 10000)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return -(maximum(sol[:Z]) - sol[:Z][1])\nend\nnothing # here","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"This cost function takes two arguments (a parameter value p, and an additional one which we will ignore here but discuss later). It first calculates the new initial steady state concentration for the given parameter set. Next, it creates an updated ODEProblem using the steady state as initial conditions and the, to the cost function provided, input parameter set. While we could create a new ODEProblem within the cost function, cost functions are often called a large number of times during the optimisation process (making performance important). Here, using remake on a previously created ODEProblem is more performant than creating a new one. Just like when using Optimization.jl to fit parameters to data, we use the verbose = false option to prevent unnecessary simulation printouts, and a reduced maxiters value to reduce time spent simulating (for the model) unsuitable parameter sets. We also use SciMLBase.successful_retcode(sol) to check whether the simulation return code indicates a successful simulation (and if it did not, returns a large cost function value). Finally, Optimization.jl finds the function's minimum value, so to find the maximum relative pulse amplitude, we make our cost function return the negative pulse amplitude.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Just like for parameter fitting, we create a OptimizationProblem using our cost function, and some initial guess of the parameter value. We also set upper and lower bounds for each parameter using the lb and ub optional arguments (in this case limiting each parameter's value to the interval (01100)).","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"using Optimization\ninitial_guess = [1.0, 1.0, 1.0]\nopt_prob = OptimizationProblem(pulse_amplitude, initial_guess; lb = [1e-1, 1e-1, 1e-1], ub = [1e1, 1e1, 1e1])","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"note: Note\nAs described in a previous section on Optimization.jl, OptimizationProblems do not support setting parameter values using maps. We must instead set initial_guess values using a vector. Next, in the first line of our cost function, we reshape the parameter values to the common form used across Catalyst (e.g. [:pX => p[1], :pY => p[2], :pZ => p[2]], however, here we use a dictionary to easier compute the steady state initial condition). We also note that the order used in this array corresponds to the order we give each parameter's bounds in lb and ub, and the order in which their values occur in the output solution.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"As previously described, Optimization.jl supports a wide range of optimisation algorithms. Here we use one from BlackBoxOptim.jl:","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"using OptimizationBBO\nopt_sol = solve(opt_prob, BBO_adaptive_de_rand_1_bin_radiuslimited())","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Finally, we plot a simulation using the found parameter set (stored in opt_sol.u):","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"ps_res = Dict([:pX => opt_sol.u[1], :pY => opt_sol.u[2], :pZ => opt_sol.u[2]])\nu0_res = [:X => ps_res[:pX], :Y => ps_res[:pX]*ps_res[:pY], :Z => ps_res[:pZ]/ps_res[:pY]^2]\noprob_res = remake(oprob; u0 = u0_res, p = ps_res)\nsol_res = solve(oprob_res, Tsit5())\nplot(sol_res; idxs=:Z)","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"For this model, it turns out that Z's maximum pulse amplitude is equal to twice its steady state concentration. Hence, the maximisation of its pulse amplitude is equivalent to maximising its steady state concentration.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"note: Note\nEspecially if you check Optimization.jl's documentation, you will note that cost functions have the f(u,p) form. This is because OptimizationProblems (like e.g. ODEProblems) can take both variables (which can be varied in the optimisation problem), but also parameters that are fixed. In our case, the optimisation variables correspond to our model parameters. Hence, our model parameter values are the u input. This is also why we find the optimisation solution (our optimised parameter set) in opt_sol's u field. Our optimisation problem does not actually have any parameters, hence, the second argument of pulse_amplitude is unused (that is why we call it _, a name commonly indicating unused function arguments). There are several modifications to our problem where it would actually have parameters. E.g. our model might have had additional parameters (e.g. a degradation rate) which we would like to keep fixed throughout the optimisation process. If we then would like to run the optimisation process for several different values of these fixed parameters, we could have made them parameters to our OptimizationProblem (and their values provided as a third argument, after initial_guess).","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#behaviour_optimisation_AD","page":"Optimization for non-data fitting purposes","title":"Utilising automatic differentiation","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Optimisation methods can be divided into differentiation-free and differentiation-based optimisation methods. E.g. consider finding the minimum of the function f(x) = x^2, given some initial guess of x. Here, we can simply compute the differential and descend along it until we find x=0 (admittedly, for this simple problem the minimum can be computed directly). This principle forms the basis of optimisation methods such as gradient descent, which utilises information of a function's differential to minimise it. When attempting to find a global minimum, to avoid getting stuck in local minimums, these methods are often augmented by additional routines. While the differentiation of most algebraic functions is trivial, it turns out that even complicated functions (such as the one we used above) can be differentiated computationally through the use of automatic differentiation (AD).","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Through packages such as ForwardDiff.jl, ReverseDiff.jl, and Zygote.jl, Julia supports AD for most code. Specifically for code including simulation of differential equations, differentiation is supported by SciMLSensitivity.jl. Generally, AD can be used without specific knowledge from the user, however, it requires an additional step in the construction of our OptimizationProblem. Here, we create a specialised OptimizationFunction from our cost function. To it, we will also provide our choice of AD method. There are several alternatives, and in our case we will use AutoForwardDiff() (a good choice for small optimisation problems). We can then create a new OptimizationProblem using our updated cost function:","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"opt_func = OptimizationFunction(pulse_amplitude, AutoForwardDiff())\nopt_prob = OptimizationProblem(opt_func, initial_guess; lb = [1e-1, 1e-1, 1e-1], ub = [1e1, 1e1, 1e1])","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Finally, we can find the optimum using some differentiation-based optimisation methods. Here we will use Optim.jl's BFGS method:","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"using OptimizationOptimJL\nopt_sol = solve(opt_prob, OptimizationOptimJL.BFGS())","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#structural_identifiability_citation","page":"Optimization for non-data fitting purposes","title":"Citation","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"If you use this functionality in your research, please cite the following paper to support the authors of the Optimization.jl package:","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"@software{vaibhav_kumar_dixit_2023_7738525,\n\tauthor = {Vaibhav Kumar Dixit and Christopher Rackauckas},\n\tmonth = mar,\n\tpublisher = {Zenodo},\n\ttitle = {Optimization.jl: A Unified Optimization Package},\n\tversion = {v3.12.1},\n\tdoi = {10.5281/zenodo.7738525},\n  \turl = {https://doi.org/10.5281/zenodo.7738525},\n\tyear = 2023\n}","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#References","page":"Optimization for non-data fitting purposes","title":"References","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"[1]: Mykel J. Kochenderfer, Tim A. Wheeler Algorithms for Optimization, The MIT Press (2019).","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"[2]: Lea Goentoro, Oren Shoval, Marc W Kirschner, Uri Alon The incoherent feedforward loop can provide fold-change detection in gene regulation, Molecular Cell (2009).","category":"page"},{"location":"inverse_problems/structural_identifiability/#structural_identifiability","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"During parameter fitting, parameter values are inferred from data. Parameter identifiability refers to whether inferring parameter values for a given model is mathematically feasible. Ideally, parameter fitting should always be accompanied with an identifiability analysis of the problem. ","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Identifiability can be divided into structural and practical identifiability[1]. Structural identifiability considers only the mathematical model, and which parameters are and are not inherently identifiable due to model structure. Practical identifiability also considers the available data, and determines what system quantities can be inferred from it. In the idealised case of an infinite amount of non-noisy data, practical identifiability converges to structural identifiability. Generally, structural identifiability is assessed before parameters are fitted, while practical identifiability is assessed afterwards.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Structural identifiability (which is what this tutorial considers) can be illustrated by the following differential equation: dx over dt = p1*p2*x(t) where, however much data is collected on x, it is impossible to determine the distinct values of p1 and p2. Hence, these parameters are non-identifiable (however, their product, p1*p2, is identifiable).","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Catalyst contains a special extension for carrying out structural identifiability analysis of generated reaction rate equation ODE models using the StructuralIdentifiability.jl package. This enables StructuralIdentifiability's assess_identifiability, assess_local_identifiability, and find_identifiable_functions functions to be called directly on Catalyst ReactionSystems. It also implements specialised routines to make these more efficient when applied to reaction network models (e.g. by improving runtimes). How to use these functions is described in the following tutorial, with StructuralIdentifiability providing a more extensive documentation. ","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Structural identifiability can be divided into local and global identifiability. If a model quantity is locally identifiable, it means that its true value can be determined down to a finite-number of possible options. This also means that there is some limited region around the quantity's true value where this true value is the only possible value (and hence, within this region, the quantity is fully identifiable). Globally identifiable quantities' values, on the other hand, can be uniquely determined. Again, while identifiability can be confirmed structurally for a quantity, it does not necessarily mean that it is practically identifiable for some given data.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Generally, there are three types of quantities for which identifiability can be assessed.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Parameters (e.g. p1 and p2).\nFull variable trajectories (e.g. x(t)).\nVariable initial conditions (e.g. x(0)). ","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"StructuralIdentifiability currently assesses identifiability for the first two only (however, if x(t) is identifiable, then x(0) will be as well).","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"note: Note\nCurrently, the StructuralIdentifiability.jl extension only considers structural identifiability for the ODE generated by the reaction rate equation. It is possible that for the SDE model (generated by the chemical Langevin equation) and the jump model (generated by stochastic chemical kinetics) the identifiability of model quantities is different.","category":"page"},{"location":"inverse_problems/structural_identifiability/#Global-identifiability-analysis","page":"Structural Identifiability Analysis","title":"Global identifiability analysis","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/#Basic-example","page":"Structural Identifiability Analysis","title":"Basic example","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Global identifiability can be assessed using the assess_identifiability function. For each model quantity (parameters and variables), it will assess whether they are:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Globally identifiable.\nLocally identifiable.\nUnidentifiable.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"To it, we provide our ReactionSystem model and a list of quantities that we are able to measure. Here, we consider a Goodwind oscillator (a simple 3-component model, where the three species M, E, and P are produced and degraded, which may exhibit oscillations)[2]. Let us say that we are able to measure the concentration of M, we then designate this using the measured_quantities argument. We can now assess identifiability in the following way:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"using Catalyst, Logging, StructuralIdentifiability\ngwo = @reaction_network begin\n    (pₘ/(1+P), dₘ), 0 <--> M\n    (pₑ*M,dₑ), 0 <--> E\n    (pₚ*E,dₚ), 0 <--> P\nend\nassess_identifiability(gwo; measured_quantities = [:M], loglevel = Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"From the output, we find that E(t), pₑ, and pₚ (the trajectory of E, and the production rates of E and P, respectively) are non-identifiable. Next, dₑ and dₚ (the degradation rates of E and P, respectively) are locally identifiable. Finally, P(t), M(t), pₘ, and dₘ (the trajectories of P and M, and the production and degradation rate of M, respectively) are all globally identifiable. We note that we also imported the Logging.jl package, and provided the loglevel = Logging.Error input argument. StructuralIdentifiability functions generally provide a large number of output messages. Hence, we will use this argument (which requires the Logging package) throughout this tutorial to decrease the amount of printed text.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Next, we also assess identifiability in the case where we can measure all three species concentrations:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"assess_identifiability(gwo; measured_quantities = [:M, :P, :E], loglevel = Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"in which case all species trajectories and parameters become identifiable.","category":"page"},{"location":"inverse_problems/structural_identifiability/#Indicating-known-parameters","page":"Structural Identifiability Analysis","title":"Indicating known parameters","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"In the previous case we assumed that all parameters are unknown, however, this is not necessarily true. If there are parameters with known values, we can supply these using the known_p argument. Providing this additional information might also make other, previously unidentifiable, parameters identifiable. Let us consider the previous example, where we measure the concentration of M only, but now assume we also know the production rate of E (pₑ):","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"assess_identifiability(gwo; measured_quantities = [:M], known_p = [:pₑ], loglevel = Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Not only does this turn the previously non-identifiable pₑ (globally) identifiable (which is obvious, given that its value is now known), but this additional information improve identifiability for several other network components.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"To, in a similar manner, indicate that certain initial conditions are known is a work in progress. Hopefully this feature should be an available in the near future.","category":"page"},{"location":"inverse_problems/structural_identifiability/#Providing-non-trivial-measured-quantities","page":"Structural Identifiability Analysis","title":"Providing non-trivial measured quantities","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Sometimes, ones may not have measurements of species, but rather some combinations of species (or possibly parameters). To account for this, measured_quantities accepts any algebraic expression (and not just single species). To form such expressions, species and parameters have to first be @unpack'ed from the model. Say that we have a model where an enzyme (E) is converted between an active and inactive form, which in turns activates the production of a product, P:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"enzyme_activation = @reaction_network begin\n    (kA,kD), Eᵢ <--> Eₐ\n    (Eₐ, d), 0 <-->P\nend","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"If we can measure the total amount of E (=Eᵢ+Eₐ), as well as the amount of P, we can use the following to assess identifiability:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"@unpack Eᵢ, Eₐ = enzyme_activation\nassess_identifiability(enzyme_activation; measured_quantities = [Eᵢ + Eₐ, :P], loglevel = Logging.Error)\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/#Assessing-identifiability-for-specified-quantities-only","page":"Structural Identifiability Analysis","title":"Assessing identifiability for specified quantities only","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"By default, StructuralIdentifiability assesses identifiability for all parameters and variables. It is, however, possible to designate precisely which quantities you want to check using the funcs_to_check option. This both includes selecting a smaller subset of parameters and variables to check, or defining customised expressions. Let us consider the Goodwind from previously, and say that we would like to check whether the production parameters (pₘ, pₑ, and pₚ) and the total amount of the three species (P + M + E) are identifiable quantities. Here, we would first unpack these (allowing us to form algebraic expressions) and then use the following code:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"@unpack pₘ, pₑ, pₚ, M, E, P = gwo\nassess_identifiability(gwo; measured_quantities = [:M], funcs_to_check = [pₘ, pₑ, pₚ, M + E + P], loglevel = Logging.Error)\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/#Probability-of-correctness","page":"Structural Identifiability Analysis","title":"Probability of correctness","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"The identifiability methods used can, in theory, produce erroneous results. However, it is possible to adjust the lower bound for the probability of correctness using the argument prob_threshold (by default set to 0.99, that is, at least a 99 chance of correctness). We can e.g. increase the bound through:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"assess_identifiability(gwo; measured_quantities=[:M], prob_threshold = 0.999, loglevel = Logging.Error)\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"giving a minimum bound of 999 chance of correctness. In practise, the bounds used by StructuralIdentifiability are very conservative, which means that while the minimum guaranteed probability of correctness in the default case is 99, in practise it is much higher. While increasing the value of prob_threshold increases the certainty of correctness, it will also increase the time required to assess identifiability.","category":"page"},{"location":"inverse_problems/structural_identifiability/#Local-identifiability-analysis","page":"Structural Identifiability Analysis","title":"Local identifiability analysis","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Local identifiability can be assessed through the assess_local_identifiability function. While this is already determined by assess_identifiability, assessing local identifiability only has the advantage that it is easier to compute. Hence, there might be models where global identifiability analysis fails (or takes a prohibitively long time), where instead assess_local_identifiability can be used. This function takes the same inputs as assess_identifiability and returns, for each quantity, true if it is locally identifiable (or false if it is not). Here, for the Goodwind oscillator, we assesses it for local identifiability only:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"assess_local_identifiability(gwo; measured_quantities = [:M], loglevel = Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"We note that the results are consistent with those produced by assess_identifiability (with globally or locally identifiable quantities here all being assessed as at least locally identifiable).","category":"page"},{"location":"inverse_problems/structural_identifiability/#Finding-identifiable-functions","page":"Structural Identifiability Analysis","title":"Finding identifiable functions","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Finally, StructuralIdentifiability provides the find_identifiable_functions function. Rather than determining the identifiability of each parameter and unknown of the model, it finds a set of identifiable functions, such as any other identifiable expression of the model can be generated by these. Let us again consider the Goodwind oscillator, using the find_identifiable_functions function we find that identifiability can be reduced to five globally identifiable expressions:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"find_identifiable_functions(gwo; measured_quantities = [:M], loglevel = Logging.Error)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Again, these results are consistent with those produced by assess_identifiability. There, pₑ and pₚ where found to be globally identifiable. Here, they correspond directly to identifiable expressions. The remaining four parameters (pₘ, dₘ, dₑ, and dₚ) occur as part of more complicated composite expressions.","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"find_identifiable_functions tries to simplify its output functions to create nice expressions. The degree to which it does this can be adjusted using the simplify keywords. Using the :weak, :standard (default), and :strong arguments, increased simplification can be forced (at the expense of longer runtime).","category":"page"},{"location":"inverse_problems/structural_identifiability/#Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems","page":"Structural Identifiability Analysis","title":"Creating StructuralIdentifiability compatible ODE models from Catalyst ReactionSystems","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"While the functionality described above covers the vast majority of analysis that user might want to perform, the StructuralIdentifiability package supports several additional features. While these does not have inherent Catalyst support, we do provide the make_si_ode function to simplify their use. Similar to the previous functions, it takes a ReactionSystem, lists of measured quantities, and known parameter values. The output is a ODE of the standard form supported by StructuralIdentifiability. It can be created using the following syntax:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"si_ode = make_si_ode(gwo; measured_quantities = [:M])\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"and then used as input to various StructuralIdentifiability functions. In the following example we use StructuralIdentifiability's print_for_DAISY function, printing the model as an expression that can be used by the DAISY software for identifiability analysis[3].","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"print_for_DAISY(si_ode)\nnothing # hide","category":"page"},{"location":"inverse_problems/structural_identifiability/#Notes-on-systems-with-conservation-laws","page":"Structural Identifiability Analysis","title":"Notes on systems with conservation laws","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Several reaction network models, such as","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"using Catalyst, Logging, StructuralIdentifiability # hide\nrs = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"contain conservation laws (in this case Γ = X1 + X2, where Γ = X1(0) + X2(0) is a constant). Because the presence of such conservation laws makes structural identifiability analysis prohibitively computationally expensive (for all but the simplest of cases), these are automatically eliminated by Catalyst (removing one ODE from the resulting ODE system for each conservation law). For the assess_identifiability and assess_local_identifiability functions, this will be unnoticed by the user. However, for the find_identifiable_functions and make_si_ode functions, this may result in one, or several, parameters of the form Γ[i] (where i is an integer) appearing in the produced expressions. These correspond to the conservation law constants and can be found through","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"conservedequations(rs)","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"E.g. if you run:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"find_identifiable_functions(rs; measured_quantities = [:X1, :X2])","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"we see that Γ[1] (= X1(0) + X2(0)) is detected as an identifiable expression. If we want to disable this feature for any function, we can use the remove_conserved = false option:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"find_identifiable_functions(rs; measured_quantities = [:X1, :X2], remove_conserved = false)","category":"page"},{"location":"inverse_problems/structural_identifiability/#Systems-with-exponent-parameters","page":"Structural Identifiability Analysis","title":"Systems with exponent parameters","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"Structural identifiability cannot currently be applied to systems with parameters (or species) in exponents. E.g. this","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"rn = @reaction_network begin\n    (hill(X,v,K,n),d), 0 <--> X\nend\nassess_identifiability(rn; measured_quantities = [:X])","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"is currently not possible. Hopefully this will be a supported feature in the future. For now, such expressions will have to be rewritten to not include such exponents. For some cases, e.g. 10^k this is trivial. However, it is also possible generally (but more involved and often includes introducing additional variables). ","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"","category":"page"},{"location":"inverse_problems/structural_identifiability/#structural_identifiability_citation","page":"Structural Identifiability Analysis","title":"Citation","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"If you use this functionality in your research, please cite the following paper to support the authors of the StructuralIdentifiability package:","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"@article{structidjl,\n  author  = {Dong, R. and Goodbrake, C. and Harrington, H. and Pogudin G.},\n  title   = {Differential Elimination for Dynamical Models via Projections with Applications to Structural Identifiability},\n  journal = {SIAM Journal on Applied Algebra and Geometry},\n  url     = {https://doi.org/10.1137/22M1469067},\n  year    = {2023}\n  volume  = {7},\n  number  = {1},\n  pages   = {194-235}\n}","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"","category":"page"},{"location":"inverse_problems/structural_identifiability/#References","page":"Structural Identifiability Analysis","title":"References","text":"","category":"section"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"[1]: Guillaume H.A. Joseph et al., Introductory overview of identifiability analysis: A guide to evaluating whether you have the right type of data for your modeling purpose, Environmental Modelling & Software (2019).","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"[2]: Goodwin B.C., Oscillatory Behavior in Enzymatic Control Processes, Advances in Enzyme Regulation (1965).","category":"page"},{"location":"inverse_problems/structural_identifiability/","page":"Structural Identifiability Analysis","title":"Structural Identifiability Analysis","text":"[3]: Bellu G., et al., DAISY: A new software tool to test global identifiability of biological and physiological systems, Computer Methods and Programs in Biomedicine (2007).","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Global sensitivity analysis (GSA) is used to study the sensitivity of a function's outputs with respect to its input[1]. Within the context of chemical reaction network modelling it is primarily used for two purposes:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"When fitting a model's parameters to data, it can be applied to the cost function of the optimisation problem. Here, GSA helps determine which parameters do, and do not, affect the model's fit to the data. This can be used to identify parameters that are less relevant to the observed data.\nWhen measuring some system behaviour or property, it can help determine which parameters influence that property. E.g. for a model of a biofuel-producing circuit in a synthetic organism, GSA could determine which system parameters have the largest impact on the total rate of biofuel production.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"GSA can be carried out using the GlobalSensitivity.jl package. This tutorial contains a brief introduction of how to use it for GSA on Catalyst models, with GlobalSensitivity providing a more complete documentation.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_global_vs_local_sensitivity","page":"Global Sensitivity Analysis","title":"Global vs local sensitivity","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"A related concept to global sensitivity is local sensitivity. This, rather than measuring a function's sensitivity (with regards to its inputs) across its entire (or large part of its) domain, measures it at a specific point. This is equivalent to computing the function's gradients at a specific point in phase space, which is an important routine for most gradient-based optimisation methods (typically carried out through automatic differentiation). For most Catalyst-related functionalities, local sensitivities are computed using the SciMLSensitivity.jl package. While certain GSA methods can utilise local sensitivities, this is not necessarily the case.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"While local sensitivities are primarily used as a subroutine of other methodologies (such as optimisation schemes), it also has direct uses. E.g., in the context of fitting parameters to data, local sensitivity analysis can be used to, at the parameter set of the optimal fit, determine the cost function's sensitivity to the system parameters.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_basic_example","page":"Global Sensitivity Analysis","title":"Basic example","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We will consider a simple SEIR model of an infectious disease. This is an expansion of the classic SIR model with an additional exposed state, E, denoting individuals who are latently infected but currently unable to transmit their infection to others.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"using Catalyst\nseir_model = @reaction_network begin\n    10^β, S + I --> E + I\n    10^a, E --> I\n    10^γ, I --> R\nend","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We will study the peak number of infected cases's (max(I(t))) sensitivity to the system's three parameters. We create a function which simulates the system from a given initial condition and measures this property:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"using OrdinaryDiffEq\n\nu0 = [:S => 999.0, :I => 1.0, :E => 0.0, :R => 0.0]\np_dummy = [:β => 0.0, :a => 0.0, :γ => 0.0]\noprob_base = ODEProblem(seir_model, u0, (0.0, 10000.0), p_dummy)\n\nfunction peak_cases(p)\n    ps = [:β => p[1], :a => p[2], :γ => p[3]]\n    oprob = remake(oprob_base; p = ps)\n    sol = solve(oprob; maxiters = 100000, verbose = false)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return maximum(sol[:I])\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Now, GSA can be applied to our peak_cases function using GlobalSensitivity's gsa function. It takes 3 mandatory inputs:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"The function for which we wish to carry out GSA.\nA method with which we wish to carry out GSA.\nA domain on which we carry out GSA. This is defined by a vector, which contains one two-valued Tuple for each parameter. These Tuples contain a lower and an upper bound for their respective parameter's value.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"E.g., here we carry out GSA using Morris's method:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"using GlobalSensitivity\nglobal_sens = gsa(peak_cases, Morris(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)])\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"on the domain 10^β  (-30-10), 10^a  (-2000), 10^γ  (-2000) (which corresponds to β  (000101), a  (00110), γ  (00110)). The output of gsa varies depending on which GSA approach is used. GlobalSensitivity implements a range of methods for GSA. Below, we will describe the most common ones, as well as how to apply them and interpret their outputs.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"note: Note\nWe should make a couple of notes about the example above:Here, we write our parameters on the forms 10^β, 10^a, and 10^γ, which transforms them into log-space. As previously described, this is advantageous in the context of inverse problems such as this one.\nFor GSA, where a function is evaluated a large number of times, it is ideal to write it as performant as possible. Hence, we initially create a base ODEProblem, and then apply the remake function to it in each evaluation of peak_cases to generate a problem which is solved for that specific parameter set.\nAgain, as previously described in other inverse problem tutorials, when exploring a function over large parameter spaces, we will likely simulate our model for unsuitable parameter sets. To reduce time spent on these, and to avoid excessive warning messages, we provide the maxiters = 100000 and verbose = false arguments to solve.\nAs we have encountered in a few other cases, the gsa function is not able to take parameter inputs of the map form usually used for Catalyst. Hence, as a first step in peak_cases we convert the parameter vector to this form. Next, we remember that the order of the parameters when we e.g. evaluate the GSA output, or set the parameter bounds, corresponds to the order used in ps = [:β => p[1], :a => p[2], :γ => p[3]].","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_sobol","page":"Global Sensitivity Analysis","title":"Sobol's method-based global sensitivity analysis","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"The most common method for GSA is Sobol's method. This can be carried out using:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens = gsa(peak_cases, Sobol(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)]; samples = 500)\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Note: when Sobol() is used as the method, the samples argument must also be used.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Sobol's method computes so-called Sobol indices, each measuring some combination of input's effect on the output. Here, when Sobol() is used, the first order, second order, and total order Sobol indices are computed. These can be accessed through the following fields:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens.S1: A vector where the i'th element is the output's sensitivity to variations in the i'th input.\nglobal_sens.S2: A matrix where element i-j contains the output's sensitivity to simultaneous variations in the i'th and j'th inputs.\nglobal_sens.ST: A vector where the i'th element is the output's sensitivity to any simultaneous variation of any combination of inputs that contain the i'th input. While only the first and second-order (and the total) Sobol indices are computed, the total order index compounds the information contained in Sobol indices across all orders.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We can plot the first-order Sobol indices to analyse their content:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"using Plots\nbar([\"β\", \"a\", \"γ\"], global_sens.S1; group = [\"β\", \"a\", \"γ\"], fillrange = 1e-3)","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Here, we see that β has a relatively low effect on the peak in infected cases, as compared to a and γ. Plotting the total order indices suggests the same:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"bar([\"β\", \"a\", \"γ\"], global_sens.ST; group = [\"β\", \"a\", \"γ\"], fillrange = 1e-3)","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"GlobalSensitivity implements several versions of Sobol's method, and also provides several options. These are described here. Specifically, it is often recommended to, due to its quick computation time, use the related extended Fourier amplitude sensitivity test (EFAST) version. We can run this using:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens = gsa(peak_cases, eFAST(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)]; samples = 500)\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"It should be noted that when EFAST is used, only the first and total-order Sobol indices are computed (and not the second-order ones).","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_morris","page":"Global Sensitivity Analysis","title":"Morris's method-based global sensitivity analysis","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"An alternative to using Sobol's method is to use Morris's method. The syntax is similar to previously (however, the samples argument is no longer required):","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens = gsa(peak_cases, Morris(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)])\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Morris's method computes, for parameter samples across parameter space, their elementary effect on the output. Next, the output's sensitivity with respect to each parameter is assessed through various statistics on these elementary effects. In practice, the following two fields are considered:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens.means_star (called μ*): Measures each parameter's influence on the output. A large μ* indicates a parameter to which the output is sensitive. \nglobal_sens.variances: Measures the variance of each parameter's influence on the output. A large variance suggests that a parameter's influence on the output is highly dependent on other parameter values.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We can check these values for our example:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"mean_star_plot = bar([\"β\" \"a\" \"γ\"], global_sens.means_star; labels=[\"β\" \"a\" \"γ\"], title=\"μ*\")\nvariances_plot = bar([\"β\" \"a\" \"γ\"], global_sens.variances; labels=[\"β\" \"a\" \"γ\"], title=\"σ²\")\nplot(mean_star_plot, variances_plot)","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"As previously, we note that the peak number of infected cases is more sensitive to a and γ than to β.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"note: Note\nThe syntax for plotting the output using Sobol's and Morris's methods is slightly different. The reason is that global_sens.means_star and global_sens.variances (for Morris's method) are 1x3 Matrices, while for Sobol's method, global_sens.S1 and global_sens.ST are length-3 vectors.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Generally, Morris's method is computationally less intensive, and has easier to interpret output, as compared to Sobol's method. However, if computational resources are available, Sobol's method is more comprehensive.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_other_methods","page":"Global Sensitivity Analysis","title":"Other global sensitivity analysis methods","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"GlobalSensitivity also implements additional methods for GSA, more details on these can be found in the package's documentation.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_nonscalars","page":"Global Sensitivity Analysis","title":"Global sensitivity analysis for non-scalar outputs","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Previously, we have demonstrated GSA on functions with scalar outputs. However, it is also possible to apply it to functions with vector outputs. Let us consider our previous function, but where it provides both the peak number of exposed and infected individuals:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"function peak_cases_2(p)\n    ps = [:β => p[1], :a => p[2], :γ => p[3]]\n    oprob = remake(oprob_base; p = ps)\n    sol = solve(oprob; maxiters = 100000, verbose = false)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return [maximum(sol[:E]), maximum(sol[:I])]\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We can apply gsa to this function as previously:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens = gsa(peak_cases_2, Morris(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)])\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"however, each output field is now a multi-row matrix, containing one row for each of the outputs. E.g., we have","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens.means_star","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Here, the function's sensitivity is evaluated with respect to each output independently. Hence, GSA on peak_cases_2 is equivalent to first carrying out GSA on a function returning the peak number of exposed individuals, and then on one returning the peak number of infected individuals.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_citations","page":"Global Sensitivity Analysis","title":"Citations","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"If you use this functionality in your research, in addition to Catalyst, please cite the following paper to support the authors of the GlobalSensitivity.jl package:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"@article{dixit2022globalsensitivity,\n  title={GlobalSensitivity. jl: Performant and Parallel Global Sensitivity Analysis with Julia},\n  author={Dixit, Vaibhav Kumar and Rackauckas, Christopher},\n  journal={Journal of Open Source Software},\n  volume={7},\n  number={76},\n  pages={4561},\n  year={2022}\n}","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#References","page":"Global Sensitivity Analysis","title":"References","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"[1]: Saltelli, A et al. Global Sensitivity Analysis. The Primer, Wiley (2008).","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#steady_state_solving","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Catalyst ReactionSystem models can be converted to ODEs (through the reaction rate equation). We have previously described how these ODEs' steady states can be found through homotopy continuation. Generally, homotopy continuation (due to its ability to find all of a system's steady states) is the preferred approach. However, Catalyst supports two additional approaches for finding steady states:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Through solving the nonlinear system produced by setting all ODE differentials to 0.\nThrough forward ODE simulation from an initial condition until a steady state has been reached.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"While these approaches only find a single steady state, they offer two advantages as compared to homotopy continuation:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"They are typically much faster.\nThey can find steady states for models that do not produce multivariate, rational, polynomial systems (which is a requirement for homotopy continuation to work). Examples include models with non-integer hill coefficients.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"In practice, model steady states are found through nonlinear system solving by creating a NonlinearProblem, and through forward ODE simulation by creating a SteadyStateProblem. These are then solved through solvers implemented in the NonlinearSolve.jl, package (with the latter approach also requiring the SteadyStateDiffEq.jl package). This tutorial describes how to find steady states through these two approaches. More extensive descriptions of available solvers and options can be found in NonlinearSolve's documentation.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#steady_state_solving_nonlinear","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Steady state finding through nonlinear solving","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Let us consider a simple dimerisation system, where a protein (P) can exist in a monomer and a dimer form. The protein is produced at a constant rate from its mRNA, which is also produced at a constant rate.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using Catalyst\ndimer_production = @reaction_network begin\n    pₘ, 0 --> mRNA\n    pₚ, mRNA --> mRNA + P\n    (k₁, k₂), 2P <--> P₂\n    d, (mRNA, P, P₂) --> 0\nend","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"This system corresponds to the following ODE:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"beginaligned\nfracdmRNAdt = pₘ - d cdot mRNA \nfracdPdt = pₚ cdot mRNA - k₁ cdot P + 2k₂ cdot P₂ - d cdot P \nfracdP₂dt = k₁ cdot P + 2k₂ cdot P₂ \nendaligned","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"To find its steady states we need to solve:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"beginaligned\n0 = pₘ - d cdot mRNA \n0 = pₚ cdot mRNA - k₁ cdot P + 2k₂ cdot P₂ - d cdot P \n0 = k₁ cdot P + 2k₂ cdot P₂ \nendaligned","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"To solve this problem, we must first designate our parameter values, and also make an initial guess of the solution. Generally, for problems with a single solution (like this one), most arbitrary guesses will work fine (the exception typically being systems with conservation laws). Using these, we can create the NonlinearProblem that we wish to solve.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"p = [:pₘ => 0.5, :pₚ => 2.0, :k₁ => 5.0, :k₂ => 1.0, :d => 1.0]\nu_guess = [:mRNA => 1.0, :P => 1.0, :P₂ => 1.0]\nnlprob = NonlinearProblem(dimer_production, u_guess, p)","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Finally, we can solve it using the solve command, returning the steady state solution:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using NonlinearSolve\nsol = solve(nlprob)","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Typically, a good default method is automatically selected for any problem. However, NonlinearSolve does provide a wide range of potential solvers. If we wish to designate one, it can be supplied as a second argument to solve. Here, we use the Newton Trust Region method, and then check that the solution is equal to the previous one.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"sol_ntr = solve(nlprob, TrustRegion())\nsol ≈ sol_ntr","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#steady_state_solving_nonlinear_conservation_laws","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Systems with conservation laws","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"As described in the section on homotopy continuation, when finding the steady states of systems with conservation laws, additional considerations have to be taken. E.g. consider the following two-state system:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using Catalyst, NonlinearSolve # hide\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"It has an infinite number of steady states. To make steady state finding possible, information of the system's conserved quantities (here C = X1 + X2) must be provided. Since these can be computed from system initial conditions (u0, i.e. those provided when performing ODE simulations), designating an u0 is often the best way. There are two ways to do this. First, one can perform forward ODE simulation-based steady state finding, using the initial condition as the initial u guess. Alternatively, any conserved quantities can be eliminated when the NonlinearProblem is created. This feature is supported by Catalyst's conservation law finding and elimination feature.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"To eliminate conservation laws we simply provide the remove_conserved = true argument to NonlinearProblem:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"p = [:k1 => 2.0, :k2 => 3.0]\nu_guess = [:X1 => 3.0, :X2 => 1.0]\nnl_prob = NonlinearProblem(two_state_model, u_guess, p; remove_conserved = true)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"here it is important that the quantities used in u_guess correspond to the conserved quantities we wish to use. E.g. here the conserved quantity X1 + X2 = 30 + 10 = 4 holds for the initial condition, and will hence also hold in the computed steady state as well. We can now find the steady states using solve like before:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"sol = solve(nl_prob)","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"We note that the output only provides a single value. The reason is that the actual system solved only contains a single equation (the other being eliminated with the conserved quantity). To find the values of X1 and X2 we can directly query the solution object for these species' values, using the species themselves as inputs:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"sol[[:X1, :X2]]","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#steady_state_solving_simulation","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding steady states through ODE simulations","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"The NonlinearProblems generated by Catalyst corresponds to ODEs. A common method of solving these is to simulate the ODE from an initial condition until a steady state is reached. Here we do so for the dimerisation system considered in the previous section. First, we declare our model, initial condition, and parameter values.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using Catalyst # hide\ndimer_production = @reaction_network begin\n    pₘ, 0 --> mRNA\n    pₚ, mRNA --> mRNA + P\n    (k₁, k₂), 2P <--> P₂\n    d, (mRNA, P, P₂) --> 0\nend\np = [:pₘ => 0.5, :pₚ => 2.0, :k₁ => 5.0, :k₂ => 1.0, :d => 1.0]\nu0 = [:mRNA => 0.1, :P => 0.0, :P₂ => 0.0]\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Next, we provide these as an input to a SteadyStateProblem","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"ssprob = SteadyStateProblem(dimer_production, u0, p)","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Finally, we can find the steady states using the solver command (which requires loading the SteadyStateDiffEq package).","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using SteadyStateDiffEq\nsolve(ssprob)","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Note that, unlike for nonlinear system solving, u0 is not just an initial guess of the solution, but the initial conditions from which the steady state simulation is carried out. This means that, for a system with multiple steady states, we can determine the steady states associated with specific initial conditions (which is not possible when the nonlinear solving approach is used). This also permits us to easily handle the presence of conservation laws. The forward ODE simulation approach (unlike homotopy continuation and nonlinear solving) cannot find unstable steady states.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"The forward ODE solving approach uses the ODE solvers implemented by the OrdinaryDiffEq.jl package. If this package is loaded, it is possible to designate a specific solver to use. Any available ODE solver can be used, however, it has to be encapsulated by the DynamicSS() function. E.g. here we designate the Rodas5P solver:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using OrdinaryDiffEq\nsolve(ssprob, DynamicSS(Rodas5P()))\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Generally, SteadyStateProblems can be solved using the same options that are available for ODE simulations. E.g. here we designate a specific dt step size:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"solve(ssprob, DynamicSS(Rodas5P()); dt = 0.01)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"It is possible to use solve SteadyStateProblems using a nonlinear solver, and NonlinearProblems using forward ODE simulation solvers:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using NonlinearSolve\nsolve(ssprob, TrustRegion())\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"nlprob = NonlinearProblem(dimer_production, u0, p)\nsolve(nlprob, DynamicSS(Rodas5P()))\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"However, especially when the forward ODE simulation approach is used, it is recommended to use the problem type which corresponds to the intended solver.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#nonlinear_solve_citation","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Citations","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"If you use this functionality in your research, in addition to Catalyst, please cite the following paper to support the authors of the NonlinearSolve.jl package:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"@article{pal2024nonlinearsolve,\n  title={NonlinearSolve. jl: High-Performance and Robust Solvers for Systems of Nonlinear Equations in Julia},\n  author={Pal, Avik and Holtorf, Flemming and Larsson, Axel and Loman, Torkel and Schaefer, Frank and Qu, Qingyu and Edelman, Alan and Rackauckas, Chris and others},\n  journal={arXiv preprint arXiv:2403.16341},\n  year={2024}\n}","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#References","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"References","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"[1]: J. Nocedal, S. J. Wright, Numerical Optimization, Springer (2006).","category":"page"},{"location":"model_creation/chemistry_related_functionality/#chemistry_functionality","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"While Catalyst has primarily been designed around the modelling of biological systems, reaction network models are also common in chemistry. This section describes two types of functionality, that while of general interest, should be especially useful in the modelling of chemical systems.","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"The @compound option, which enables the user to designate that a specific species is composed of certain subspecies.\nThe balance_reaction function, which enables the user to balance a reaction so the same number of components occur on both sides.","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Modelling-with-compound-species","page":"Chemistry-related functionality","title":"Modelling with compound species","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/#Creating-compound-species-programmatically","page":"Chemistry-related functionality","title":"Creating compound species programmatically","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"We will first show how to create compound species through programmatic model construction, and then demonstrate using the DSL. To create a compound species, use the @compound macro, first designating the compound, followed by its components (and their stoichiometries). In this example, we will create a CO₂ molecule, consisting of one C atom and two O atoms. First, we create species corresponding to the components:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"using Catalyst\nt = default_t()\n@species C(t) O(t) ","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Next, we create the CO2 compound species:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound CO2 ~ C + 2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Here, the compound is the first argument to the macro, followed by its component (with the left-hand and right-hand sides separated by a ~ sign). While non-compound species (such as C and O) have their independent variable (in this case t) designated, independent variables are generally not designated for compounds (these are instead directly inferred from their components). Components with non-unitary stoichiometries have this value written before the component (generally, the rules for designating the components of a compound are identical to those of designating the substrates or products of a reaction). The created compound, CO2, is also a species, and can be used wherever e.g. C can be used:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"isspecies(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"In its metadata, however, is stored information of its components, which can be retrieved using the components (returning a vector of its component species) and coefficients (returning a vector with each component's stoichiometry) functions:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"components(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"coefficients(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Alternatively, we can retrieve the components and their stoichiometric coefficients as a single vector using the component_coefficients function:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"component_coefficients(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Finally, it is possible to check whether a species is a compound using the iscompound function:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"iscompound(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Compound components that are also compounds are allowed, e.g. we can create a carbonic acid compound (H₂CO₃) that consists of CO₂ and H₂O:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@species H(t)\n@compound H2O ~ 2H + O\n@compound H2CO3 ~ CO2 + H2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"When multiple compounds are created, they can be created simultaneously using the @compounds macro, e.g. the previous code-block can be re-written as:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@species H(t)\n@compounds begin\n    H2O ~ 2H + O\n    H2CO3 ~ CO2 + H2O\nend","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Creating-compound-species-within-the-DSL","page":"Chemistry-related functionality","title":"Creating compound species within the DSL","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"It is also possible to declare species as compound species within the @reaction_network DSL, using the @compounds options:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rn = @reaction_network begin\n    @species C(t) H(t) O(t)\n    @compounds begin\n        C2O ~ C + 2O\n        H2O ~ 2H + O\n        H2CO3 ~ CO2 + H2O\n    end\n    (k1,k2), H2O + CO2 <--> H2CO3\nend","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"When creating compound species using the DSL, it is important to note that every component must be known to the system as a species, either by being declared using the @species or @compound options, or by appearing in a reaction. E.g. the following is not valid","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rn = @reaction_network begin\n    @compounds begin\n        C2O ~ C + 2O\n        H2O ~ 2H + O\n        H2CO3 ~ CO2 + H2O\n    end\n    (k1,k2), H2O+ CO2 <--> H2CO3\nend","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"as the components C, H, and O are not declared as species anywhere. Please also note that only @compounds can be used as an option in the DSL, not @compound.","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Designating-metadata-and-default-values-for-compounds","page":"Chemistry-related functionality","title":"Designating metadata and default values for compounds","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Just like for normal species, it is possible to designate metadata and default values for compounds. Metadata is provided after the compound name, but separated from it by a ,:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound (CO2, [unit=\"mol\"]) ~ C + 2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Default values are designated using =, and provided directly after the compound name.:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound (CO2 = 2.0) ~ C + 2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"If both default values and meta data are provided, the metadata is provided after the default value:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound (CO2 = 2.0, [unit=\"mol\"]) ~ C + 2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"In all of these cases, the left-hand side must be enclosed within ().","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Compounds-with-multiple-independent-variables","page":"Chemistry-related functionality","title":"Compounds with multiple independent variables","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"While we generally do not need to specify independent variables for compound, if the components (together) have more than one independent variable, this must be done:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"t = default_t()\n@variables s\n@species N(s) O(t) \n@compound NO2(t,s) ~ N + 2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Here, NO2 depend both on a spatial independent variable (s) and a time one (t). This is required since, while multiple independent variables can be inferred, their internal order cannot (and must hence be provided by the user).","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Balancing-chemical-reactions","page":"Chemistry-related functionality","title":"Balancing chemical reactions","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"One use of defining a species as a compound is that they can be used to balance reactions so that the number of components are the same on both sides. Catalyst provides the balance_reaction function, which takes a reaction, and returns a balanced version. E.g. let us consider a reaction when carbon dioxide is formed from carbon and oxide C + O --> CO2. Here, balance_reaction enables us to find coefficients creating a balanced reaction (in this case, where the number of carbon and oxygen atoms are the same on both sides). To demonstrate, we first created the unbalanced reactions:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rx = @reaction k, C + O --> $CO2","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Here, the reaction rate (k) is not involved in the reaction balancing. We use interpolation for CO2, ensuring that the CO2 used in the reaction is the same one we previously defined as a compound of C and O. Next, we call the balance_reaction function","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"balance_reaction(rx)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"which correctly finds the (rather trivial) solution C + 2O --> CO2. Here we note that balance_reaction actually returns a vector. The reason is that, in some cases, the reaction balancing problem does not have a single obvious solution. Typically, a single solution is the obvious candidate (in which case this is the vector's only element). However, when this is not the case, the vector instead contain several reactions (from which a balanced reaction cab be generated).","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Let us consider a more elaborate example, the reaction between ammonia (NH₃) and oxygen (O₂) to form nitrogen monoxide (NO) and water (H₂O). Let us first create the components and the unbalanced reaction:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"using Catalyst # hide\nt = default_t()\n@species N(t) H(t) O(t) \n@compounds begin\n    NH3 ~ N + 3H\n    O2 ~ 2O\n    NO ~ N + O\n    H2O ~ 2H + O\nend\nunbalanced_reaction = @reaction k, $NH3 + $O2 --> $NO + $H2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"We can now create a balanced version (where the amount of H, N, and O is the same on both sides):","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"balanced_reaction = balance_reaction(unbalanced_reaction)[1]","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Reactions declared as a part of a ReactionSystem (e.g. using the DSL) can be retrieved for balancing using the reactions function. Please note that balancing these will not mutate the ReactionSystem, but a new reaction system will need to be created using the balanced reactions.","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"note: Note\nReaction balancing is currently not supported for reactions involving compounds of compounds.","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Balancing-full-systems","page":"Chemistry-related functionality","title":"Balancing full systems","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"It is possible to balance all the reactions of a reaction system simultaneously using the balance_system function. Here, the output is a new system, where all reactions are balanced. E.g. We can use it to balance this system of methane formation/combustion:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rs = @reaction_network begin\n    @species C(t) O(t) H(t)\n    @compounds begin\n        H2(t) ~ 2H\n        CH4(t) ~ C + 4H\n        O2(t) ~ 2O\n        CO2(t) ~ C + 2O\n        H2O(t) ~ 2H + O\n    end\n    1.0, C + H2 --> CH4\n    2.0, CH4 + O2 --> CO2 + H2O\nend\nrs_balanced = balance_system(rs)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Except for the modified reaction stoichiometries, the new system is identical to the previous one.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"When simulating a model, one begins with creating a problem. Next, a simulation is performed on the problem, during which the simulation's state is recorded through an integrator. Finally, the simulation output is returned as a solution. This tutorial describes how to access (or modify) the state (or parameter) values of problem, integrator, and solution structures.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Generally, when we have a structure simulation_struct and want to interface with the unknown (or parameter) x, we use simulation_struct[:x] to access the value, and simulation_struct[:x] = 5.0 to set it to a new value. For situations where a value is accessed (or changed) a large number of times, it can improve performance to first create a specialised getter/setter function.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_problems","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problem objects","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"We begin by demonstrating how we can interface with problem objects. First, we create an ODEProblem representation of a chemical cross-coupling model (where a catalyst, C, couples two substrates, S₁ and S₂, to form a product, P).","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using Catalyst\ncc_system = @reaction_network begin\n    k₁, S₁ + C --> S₁C\n    k₂, S₁C + S₂ --> CP\n    k₃, CP --> C + P\nend\n\nu0 = [:S₁ => 1.0, :C => 0.05, :S₂ => 1.2, :S₁C => 0.0, :CP => 0.0, :P => 0.0]\ntspan = (0., 10.0)\nps = [:k₁ => 5.0, :k₂ => 5.0, :k₃ => 100.0] \noprob = ODEProblem(cc_system, u0, tspan, ps)\nnothing    # hide","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"We can find a species's (or variable's) initial condition value by simply indexing with the species of interest as input. Here we check the initial condition value of C:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[:C]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"An almost identical notation can be used for parameters, however, here we use oprob.ps (rather than oprob): with the notation being identical for parameters:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob.ps[:k₁]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"To retrieve several species initial condition (or parameter) values, simply give a vector input. Here we check the values of the two substrates (S₁ and S₂):","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[[:S₁, :S₂]]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"We can change a species's initial condition value using a similar notation. Here we increase the initial concentration of C (and also confirm that the new value is stored in an updated oprob):","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[:C] = 0.1\noprob[:C]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Again, parameter values can be changed using a similar notation, however, again requiring oprob.ps notation:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob.ps[:k₁] = 10.0\noprob.ps[:k₁]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Finally, vectors can be used to update multiple quantities simultaneously","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[[:S₁, :S₂]] = [0.5, 0.3]\noprob[[:S₁, :S₂]]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Generally, when updating problems, it is often better to use the remake function (especially when several values are updated).","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"warn: Warn\nIndexing should not be used not modify JumpProblems. Here, remake should be used exclusively.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"A problem's time span can be accessed through the tspan field:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob.tspan","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"note: Note\nHere we have used an ODEProblemto demonstrate all interfacing functionality. However, identical workflows work for the other problem types.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_problems_remake","page":"Interfacing problems, integrators, and solutions","title":"Remaking problems using the remake function","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"The remake function offers an (to indexing) alternative approach for updating problems. Unlike indexing, remake creates a new problem (rather than updating the old one). Furthermore, it permits the updating of several values simultaneously. The remake function takes the following inputs:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"The problem that is remakes.\n(optionally) u0: A vector with initial conditions that should be updated. The vector takes the same form as normal initial condition vectors, but does not need to be complete (in which case only a subset of the initial conditions are updated).\n(optionally) tspan: An updated time span (using the same format as time spans normally are given in).\n(optionally) p: A vector with parameters that should be updated. The vector takes the same form as normal parameter vectors, but does not need to be complete (in which case only a subset of the parameters are updated).","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Here we modify our problem to increase the initial condition concentrations of the two substrates (S₁ and S₂), and also confirm that the new problem is different from the old (unchanged) one:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using OrdinaryDiffEq\noprob_new = remake(oprob; u0 = [:S₁ => 5.0, :S₂ => 2.5])\noprob_new == oprob","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Here, we instead use remake to simultaneously update a all three fields:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob_new_2 = remake(oprob; u0 = [:C => 0.2], tspan = (0.0, 20.0), p = [:k₁ => 2.0, :k₂ => 2.0])\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_integrators","page":"Interfacing problems, integrators, and solutions","title":"Interfacing integrator objects","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"During a simulation, the solution is stored in an integrator object. Here, we will describe how to interface with these. The almost exclusive circumstance when integrator-interfacing is relevant is when simulation events are implemented through callbacks. However, to demonstrate integrator indexing in this tutorial, we will create one through the init function (while circumstances where one might want to use init function exist, since integrators are automatically created during simulations, these are rare).","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator = init(oprob)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"We can interface with our integrator using an identical syntax as was used for problems (with the exception that remake is not available). Here we update, and then check the values of, first the species C and then the parameter k₁:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator[:C] = 0.0\nintegrator[:C]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"or a parameter:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator.ps[:k₂] = 1.0\nintegrator.ps[:k₂]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Note that here, species-interfacing yields (or changes) a simulation's current value for a species, not its initial condition.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"If you are interfacing with jump simulation integrators, please read this, highly relevant, section.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_solutions","page":"Interfacing problems, integrators, and solutions","title":"Interfacing solution objects","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Finally, we consider solution objects. First, we simulate our problem:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol = solve(oprob)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Next, we can access the simulation's values using the same notation as previously. When we access a species's, its values across the full simulation is returned as a vector:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol[:P]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Parameter values can also be accessed (however, here we only get a single value):","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol.ps[:k₃]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Unlike for problems and integrators, species or parameter values of solutions cannot be changed. ","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"A vector with the time values for all simulation time steps can be retrieved using","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol.t","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"To find simulation values at a specific time point, simply use this time point as input to your solution object (treating it as a function). I.e. here we get our simulation's values at time t = 10","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol(1.0)","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"This works whenever the simulations actually stopped at time t = 10 (if not, an interpolated value is returned). To get the simulation's values for a specific subset of species, we can use the idxs optional argument. I.e. here we get the value of C at time t = 10","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol(1.0; idxs = [:C])","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_functions","page":"Interfacing problems, integrators, and solutions","title":"Interfacing using specialised getter/setter functions","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Internally, species and parameter values are stored in vectors. Whenever e.g. oprob[:C] is called, Julia must first find which index in the storage vector C is stored in. Next, its value can be retrieved. If oprob[:C] is called a large number of times, this index must be found in each call. If a large number of such accesses are carried out, and performance is essential, it can be worthwhile to pre-compute a function to carry this out.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"There exist four different functions, each returning a function for performing a specific type of interfacing:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"ModelingToolkit.getu: For accessing species values.\nModelingToolkit.getp: For accessing parameter values.\nModelingToolkit.setu: For changing species values.\nModelingToolkit.setp: For changing parameter values.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"For each species (or parameter) we wish to interface with, a new interfacing function must be created. Here we first creates a function for retrieving the value of C, and then use it for this purpose:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"get_C = ModelingToolkit.getu(oprob, :C)\nget_C(oprob)","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Here, getu (as well as getp, setu, and setp) first takes the structure we wish to interface with, and then the target quantity. When using setu and setp, in the second step, we must also provide the update value:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"set_C = ModelingToolkit.setu(oprob, :C)\nset_C(oprob, 0.2)\nget_C(oprob)","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Like when indexing-based interfacing is used, these functions also work with vectors:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"get_S = ModelingToolkit.getu(oprob, [:S₁, :S₂])\nget_S(oprob)","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_symbolic_representation","page":"Interfacing problems, integrators, and solutions","title":"Interfacing using symbolic representations","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"As previously described, when e.g. programmatic modelling is used, species and parameters can be represented as symbolic variables. These can be used to index a problem, just like symbol-based representations can. Here we create a simple two-state model programmatically, and use its symbolic variables to check, and update, an initial condition:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using Catalyst\nt = default_t()\n@species X1(t) X2(t)\n@parameters k1 k2\nrxs = [\n    Reaction(k1, [X1], [X2]),\n    Reaction(k2, [X2], [X1])\n]\n@named two_state_model = ReactionSystem(rxs, t)\ntwo_state_model = complete(two_state_model)\n\nu0 = [X1 => 2.0, X2 => 0.0]\ntspan = (0.0, 1.0)\nps = [k1 => 1.0, k2 => 2.0]\noprob = ODEProblem(two_state_model, u0, tspan, ps)\n\noprob[X1] = 5.0\noprob[X1]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Symbolic variables can be used to access or update species or parameters for all the cases when Symbols can (including when using remake or e.g. getu).","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"An advantage when quantities are represented as symbolic variables is that symbolic expressions can be formed and used to index a structure. E.g. here we check the combined initial concentration of X (X1 + X2) in our two-state problem:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[X1 + X2]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Just like symbolic variables can be used to directly interface with a structure, symbolic variables stored in ReactionSystem models can be used:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[two_state_model.X1 + two_state_model.X2]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"This can be used to form symbolic expressions using model quantities when a model has been created using the DSL (as an alternative to @unpack). Alternatively, creating an observable, and then interface using its Symbol representation, is also possible.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"warn: Warn\nWith interfacing with a simulating structure using symbolic variables stored in a ReactionSystem model, ensure that the model is complete.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Catalyst's core functionality is the creation of chemical reaction network (CRN) models that can be simulated using ODE, SDE, and jump simulations. How such simulations are carried out has already been described in Catalyst's introduction. This page provides a deeper introduction, giving some additional background and introducing various simulation-related options. ","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here we will focus on the basics, with other sections of the simulation documentation describing various specialised features, or giving advice on performance. Anyone who plans on using Catalyst's simulation functionality extensively is recommended to also read the documentation on solution plotting, and on how to interact with simulation problems, integrators, and solutions. Anyone with an application for which performance is critical should consider reading the corresponding page on performance advice for ODEs, SDEs, or jump simulations.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_theory","page":"Model Simulation Introduction","title":"Background to CRN simulations","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"This section provides some brief theory on CRN simulations. For details on how to carry out these simulations in actual code, please skip to the following sections.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"CRNs are defined by a set of species (with the amounts of these determining the system's state during simulations) and a set of reaction events (rules for how the state of the system changes). In real systems, the species amounts are discrete copy-numbers, describing the exact numbers of each species type present in the system (in systems biology this can e.g. be the number of a specific molecule present in a cell). Given rates for these reaction events, stochastic chemical kinetics provides a formula for simulating the system that recreates its real reaction process. During stochastic chemical kinetics simulations, the system's state is defined by discrete copy-numbers (denoting the number of each species present in the system). Next, at the occurrence of individual reaction events, the system's state is updated according to the occurred reaction. The result is a stochastic process. The most well-known approach for simulating stochastic chemical kinetics is Gillespie's algorithm.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"In practice, these jump simulations are computationally expensive. In many cases, copy-numbers are so large that they can be approximated as continuous concentrations, and the time-development of the system as a deterministic process. This creates an ordinary differential equation (ODE), and is the chemical reaction network form most people are most familiar with. The rule for how ODEs are generated from CRNs is called the reaction rate equation (RRE).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here, the RRE enables fast, approximate, and deterministic simulations of CRNs, while stochastic chemical kinetics enables exact, stochastic, simulations of the true process. An intermediary approach is to use the chemical Langevin equation (CLE) to formulate a stochastic differential equation (SDE). This approximates the system's state as continuous concentrations, but does not assume that its time development is deterministic. Generally, the CLE is used when copy-numbers are large enough that the continuous approximation holds, but not so large that the system's behaviour is deterministic. Generally, the advantage of SDE simulations (compared to jump ones) is that they are faster. Also, since the system state is continuous, interpretation of e.g. stability and steady state results from the deterministic (also continuous) domain is easier for SDEs (however one should be careful when making such interpretations).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"These three different approaches are summed up in the following table:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-0pky\">Interpretation</th>\n    <th class=\"tg-0pky\">Reaction rate equation</th>\n    <th class=\"tg-0pky\">Chemical Langevin equation</th>\n    <th class=\"tg-0pky\">Stochastic chemical kinetics</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">Simulation form</td>\n    <td class=\"tg-0pky\">ODE simulations</td>\n    <td class=\"tg-0pky\">SDE simulations</td>\n    <td class=\"tg-0pky\">Jump simulations</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Example simulation methods</td>\n    <td class=\"tg-0pky\"><a href=\"https://en.wikipedia.org/wiki/Euler_method\">Euler</a>, <a href=\"https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods\">Runge-Kutta</a></td>\n    <td class=\"tg-0pky\"><a href=\"https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method\">Euler-Maruyama</a>, <a href=\"https://en.wikipedia.org/wiki/Milstein_method\">Milstein</a></td>\n    <td class=\"tg-0pky\"><a href=\"https://en.wikipedia.org/wiki/Gillespie_algorithm\">Gillespie</a>, <a href=\"https://pubmed.ncbi.nlm.nih.gov/16321569/\">Sorting direct</a></td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Species units</td>\n    <td class=\"tg-0pky\">Concentration</td>\n    <td class=\"tg-0pky\">Concentration</td>\n    <td class=\"tg-0pky\">Copy-numbers</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Deterministic/Stochastic</td>\n    <td class=\"tg-0pky\">Deterministic</td>\n    <td class=\"tg-0pky\">Stochastic</td>\n    <td class=\"tg-0pky\">Stochastic</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Applicability</td>\n    <td class=\"tg-0pky\">Large species amounts</td>\n    <td class=\"tg-0pky\"><span style=\"font-weight:400;font-style:normal\">Non-small species amounts</span></td>\n    <td class=\"tg-0pky\">Any species amounts</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Speed</td>\n    <td class=\"tg-0pky\">Typically fast</td>\n    <td class=\"tg-0pky\">Typically intermediate</td>\n    <td class=\"tg-0pky\">Typically slow</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Simulation package</td>\n    <td class=\"tg-0pky\"><a href=\"https://github.com/SciML/OrdinaryDiffEq.jl\">OrdinaryDiffEq.jl</a></td>\n    <td class=\"tg-0pky\"><a href=\"https://github.com/SciML/StochasticDiffEq.jl\">StochasticDiffEq.jl</a></td>\n    <td class=\"tg-0pky\"><a href=\"https://github.com/SciML/JumpProcesses.jl\">JumpProcesses.jl</a></td>\n  </tr>\n</tbody>\n</table>","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_ODEs","page":"Model Simulation Introduction","title":"Performing (ODE) simulations","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"The following section gives a (more throughout than [previous]) introduction of how to simulate Catalyst models. This is exemplified using ODE simulations (some ODE-specific options will also be discussed). Later on, we will describe things specific to SDE and jump simulations. All ODE simulations are performed using the OrdinaryDiffEq.jl package, which full documentation can be found here. A dedicated section giving advice on how to optimise ODE simulation performance can be found here","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"To perform any simulation, we must first define our model, as well as the simulation's initial conditions, time span, and parameter values. Here we will use a simple two-state model:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Catalyst\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\nu0 = [:X1 => 100.0, :X2 => 200.0]\ntspan = (0.0, 5.0)\nps = [:k1 => 2.0, :k2 => 5.0]\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"To simulate the model we first bundle these up into an ODEProblem:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"oprob = ODEProblem(two_state_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Next, we can simulate the model (requires loading the OrdinaryDiffEq.jl package). Simulations are performed using the solve function.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using OrdinaryDiffEq\nsol = solve(oprob)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Finally, the result can be plotted using the Plots.jl package's plot function:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Plots\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"More information on how to interact with solution structures is provided here and on how to plot them here.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Some additional considerations:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"If a model without parameters has been declared, only the first three arguments must be provided to ODEProblem.\nWhile the first value of tspan will almost always be 0.0, other starting times (both negative and positive) are possible.\nA discussion of various ways to represent species and parameters when designating their values in the u0 and ps vectors can be found here. ","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_solver_options","page":"Model Simulation Introduction","title":"Designating solvers and solver options","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"While good defaults are generally selected, OrdinaryDiffEq enables the user to customise simulations through a long range of options that can be provided to the solve function. This includes specifying a solver algorithm, which can be provided as a second argument to solve (if none is provided, a suitable choice is automatically made). E.g. here we specify that the Rodas5P method should be used:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(oprob, Rodas5P())\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"A full list of available solvers is provided here, and a discussion on optimal solver choices here.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Additional options can be provided as keyword arguments. E.g. the maxiters arguments determines the maximum number of simulation time steps (before the simulation is terminated). This defaults to 1e5, but can be modified through:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(oprob; maxiters = 1e4)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here follows a list of solver options which might be of interest to the user.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"adaptive: Toggles adaptive time stepping for valid methods. Default to true.\ndt: For non-adaptive simulations, sets the step size (also sets the initial step size for adaptive methods).\nsaveat: Determines the time points at which the simulation is saved. E.g. for saveat = 2.0 the simulation is saved every second time unit. If not given, the solution is saved after each time step.\nsave_idxs: Provides a vector of species whose values should be saved during the simulation. E.g. for save_idxs = [:X1], only the value of species X1 is saved. \nmaxiters: The maximum number of time steps of the simulation. If this number is reached, the simulation is terminated.\nseed: Sets a seed for stochastic simulations. Stochastic simulations with the same seed generate identical results.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"A full list of solver options can be found here.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_ODEs_input_forms","page":"Model Simulation Introduction","title":"Alternative problem input forms","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Throughout Catalyst's documentation, we typically provide initial condition and parameter values as vectors. However, these can also be provided as tuples:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"u0 = (:X1 => 100.0, :X2 => 200.0)\ntspan = (0.0, 5.0)\nps = (:k1 => 2.0, :k2 => 5.0)\noprob = ODEProblem(two_state_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"or dictionaries:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"u0 = Dict([:X1 => 100.0, :X2 => 200.0])\ntspan = (0.0, 5.0)\nps = Dict([:k1 => 2.0, :k2 => 5.0])\noprob = ODEProblem(two_state_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"The forms used for u0 and ps does not need to be the same (but can e.g. be a vector and a tuple). ","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"note: Note\nIt is possible to designate specific types for parameters. When this is done, the tuple form for providing parameter values should be preferred.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Throughout Catalyst's documentation, we typically provide the time span as a tuple. However, if the first time point is 0.0 (which is typically the case), this can be omitted. Here, we supply only the simulation endpoint to our ODEProblem:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"tend = 5.0\noprob = ODEProblem(two_state_model, u0, tend, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_SDEs","page":"Model Simulation Introduction","title":"Performing SDE simulations","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Catalyst uses the StochasticDiffEq.jl package to perform SDE simulations. This section provides a brief introduction, with StochasticDiffEq's documentation providing a more extensive description. A dedicated section giving advice on how to optimise SDE simulation performance can be found here. By default, Catalyst generates SDEs from CRN models using the chemical Langevin equation.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"SDE simulations are performed in a similar manner to ODE simulations. The only exception is that an SDEProblem is created (rather than an ODEProblem). Furthermore, the StochasticDiffEq.jl package (rather than the OrdinaryDiffEq package) is required for performing simulations. Here we simulate the two-state model for the same parameter set as previously used:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Catalyst, StochasticDiffEq, Plots\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\nu0 = [:X1 => 100.0, :X2 => 200.0]\ntspan = (0.0, 1.0)\nps = [:k1 => 2.0, :k2 => 5.0]\n\nsprob = SDEProblem(two_state_model, u0, tspan, ps)\nsol = solve(sprob, STrapezoid())\nsol = solve(sprob, STrapezoid(); seed = 123) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"we can see that while this simulation (unlike the ODE ones) exhibits some fluctuations. ","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"note: Note\nUnlike for ODE and jump simulations, there are no good heuristics for automatically selecting suitable SDE solvers. Hence, for SDE simulations a solver must be provided. STrapezoid will work for a large number of cases. When this is not the case, however, please check the list of available SDE solvers for a suitable alternative (making sure to select one compatible with non-diagonal noise and the [Ito interpretation]https://en.wikipedia.org/wiki/It%C3%B4_calculus).","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_SDEs_pitfalls","page":"Model Simulation Introduction","title":"Common SDE simulation pitfalls","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Next, let us reduce species amounts (using remake), thereby also increasing the relative amount of noise, we encounter a problem when the model is simulated:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sprob = remake(sprob; u0 = [:X1 => 0.33, :X2 => 0.66])\nsol = solve(sprob, STrapezoid())\nsol = solve(sprob, STrapezoid(); seed = 1234567) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here, we receive a warning that the simulation was aborted. In the plot, we also see that it is incomplete. In this case we also note that species concentrations are very low (and sometimes, due to the relatively high amount of noise, even negative). This, combined with the early termination, suggests that we are simulating our model for too low species concentration for the assumptions of the CLE to hold. Instead, jump simulations should be used.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Next, let us consider a simulation for another parameter set:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sprob = remake(sprob; u0 = [:X1 => 100.0, :X2 => 200.0], p = [:k1 => 200.0, :k2 => 500.0])\nsol = solve(sprob, STrapezoid())\nsol = solve(sprob, STrapezoid(); seed = 12345) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Again, the simulation is aborted. This time, however, species concentrations are relatively large, so the CLE might still hold. What has happened this time is that the accuracy of the simulations has not reached its desired threshold. This can be deal with by reducing simulation tolerances:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(sprob, STrapezoid(), abstol = 1e-1, reltol = 1e-1)\nsol = solve(sprob, STrapezoid(); seed = 12345, abstol = 1e-1, reltol = 1e-1) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_SDEs_noise_saling","page":"Model Simulation Introduction","title":"Scaling the noise in the chemical Langevin equation","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"When using the CLE to generate SDEs from a CRN, it can sometimes be desirable to scale the magnitude of the noise. This can be done by introducing a noise scaling term, with each noise term generated by the CLE being multiplied with this term. A noise scaling term can be set using the @default_noise_scaling option:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"two_state_model = @reaction_network begin\n    @default_noise_scaling 0.1\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here, we set the noise scaling term to 0.1, reducing the noise with a factor 10 (noise scaling terms 10 increase the noise, while terms 10 reduce the noise). If we re-simulate the model using the low-concentration settings used previously, we see that the noise has been reduced (in fact by so much that the model can now be simulated without issues):","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"u0 = [:X1 => 100.0, :X2 => 200.0]\ntspan = (0.0, 1.0)\nps = [:k1 => 200.0, :k2 => 500.0]\nsprob = SDEProblem(two_state_model, u0, tspan, ps)\nsol = solve(sprob, STrapezoid())\nsol = solve(sprob, STrapezoid(); seed = 123) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"The @default_noise_scaling option can take any expression. This can be used to e.g. designate a noise scaling parameter:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"two_state_model = @reaction_network begin\n    @parameters η\n    @default_noise_scaling η\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Now we can tune the noise through η's value. E.g. here we remove the noise entirely by setting η = 00 (thereby recreating an ODE simulation's behaviour):","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"u0 = [:X1 => 0.33, :X2 => 0.66, :η => 0.0]\ntspan = (0.0, 1.0)\nps = [:k1 => 2.0, :k2 => 5.0]\nsprob = SDEProblem(two_state_model, u0, tspan, ps)\nsol = solve(sprob, STrapezoid())\nsol = solve(sprob, STrapezoid(); seed = 123) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"note: Note\nAbove, Catalyst is unable to infer that η is a parameter from the @default_noise_scaling η option only. Hence, @parameters η is used to explicitly declare η to be a parameter (as discussed in more detail here).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"It is possible to designate specific noise scaling terms for individual reactions through the noise_scaling reaction metadata. Here, CLE noise terms associated with a specific reaction are multiplied by that reaction's noise scaling term. Here we use this to turn off the noise in the X1 to X2 reaction:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"two_state_model = @reaction_network begin\n    k1, X1 --> X2, [noise_scaling = 0.0]\n    k2, X2 --> X1\nend\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"If the @default_noise_scaling option is used, that term is only applied to reactions without noise_scaling metadata.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"While the @default_noise_scaling option is unavailable for programmatically created models, the remake_reactionsystem function can be used to achieve a similar effect.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_jumps","page":"Model Simulation Introduction","title":"Performing jump simulations using stochastic chemical kinetics","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Catalyst uses the JumpProcesses.jl package to perform jump simulations. This section provides a brief introduction, with JumpProcesses's documentation providing a more extensive description. A dedicated section giving advice on how to optimise jump simulation performance can be found here.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Jump simulations are performed using so-called JumpProblems. Unlike ODEs and SDEs (for which the corresponding problem types can be created directly), jump simulations require first creating an intermediary DiscreteProblem. In this example, we first declare our two-state model and its initial conditions, time span, and parameter values.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Catalyst, JumpProcesses, Plots\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\nu0 = [:X1 => 5, :X2 => 10]\ntspan = (0.0, 5.0)\nps = [:k1 => 2.0, :k2 => 5.0]\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"note: Note\nSince jump simulations typically simulate the integer copy-numbers of each species present in the system, we designate our initial conditions for jump simulations as integers. Decimal-numbered initial conditions (and thus jump simulations) are, however, also possible. While ODE and SDE simulations accept integer initial conditions, these will be converted to decimal numbers.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Next, we bundle these into a DiscreteProblem (similarly to how ODEProblems and SDEProblems are created):","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"dprob = DiscreteProblem(two_state_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"This is then used as input to a JumpProblem. The JumpProblem also requires the CRN model and an aggregator as input.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"jprob = JumpProblem(two_state_model, dprob, Direct())\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"The JumpProblem can now be simulated using solve (just like any other problem type).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(jprob, SSAStepper())\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"If we plot the solution we can see how the system's state does not change continuously, but instead in discrete jumps (due to the occurrence of the individual reactions of the system).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Plots\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_jumps_solver_designation","page":"Model Simulation Introduction","title":"Designating aggregators and simulation methods for jump simulations","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Jump simulations (just like ODEs and SDEs) are performed using solver methods. Unlike ODEs and SDEs, jump simulations are carried out by two different types of methods acting in tandem. First, an aggregator method is used to (after each reaction) determine the time to, and type of, the next reaction. Next, a simulation method is used to actually carry out the simulation.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Several different aggregators are available (a full list is provided here). To designate a specific one, provide it as the third argument to the JumpProblem. E.g. to designate that Gillespie's direct method (Direct) should be used, use:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"jprob = JumpProblem(two_state_model, dprob, Direct())\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Especially for large systems, the choice of aggregator is relevant to simulation performance. A guide for aggregator selection is provided here.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Next, a simulation method can be provided (like for ODEs and SDEs) as the second argument to solve. Primarily two alternatives are available, SSAStepper and FunctionMap (other alternatives are only relevant when jump simulations are combined with ODEs/SDEs, which is described in more detail in JumpProcesses's documentation). Generally, FunctionMap is only used when a continuous callback is used (and SSAStepper otherwise). E.g. we can designate that the FunctionMap method should be used through:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(jprob, FunctionMap())\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_jumps_variableratejumps","page":"Model Simulation Introduction","title":"Jump simulations where some rate depends on time","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"For some models, the rate of some reactions depend on time. E.g. consider the following circadian model, where the production rate of some protein (P) depends on a sinusoid function:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"circadian_model = @reaction_network begin\n    A*(sin(2π*f*t - ϕ)+1)/2, 0 --> P\n    d, P --> 0\nend","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"This type of model will generate so called variable rate jumps. Simulation of such model is non-trivial (and Catalyst currently lacks a good interface for this). A detailed description of how to carry out jump simulations for models with time-dependant rates can be found here.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"In the introduction to Catalyst we described how the @reaction_network macro can be used to create chemical reaction network (CRN) models. This macro enables a so-called domain-specific language (DSL) for creating CRN models. This tutorial will give a basic introduction on how to create Catalyst models using this macro (from now onwards called \"the Catalyst DSL\"). A follow-up tutorial will describe some of the DSL's more advanced features.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"The Catalyst DSL generates a ReactionSystem (the julia structure Catalyst uses to represent CRN models). These can be created through alternative methods (e.g. programmatically or compositionally). A summary of the various ways to create ReactionSystemss can be found here. Previous and following tutorials describe how to simulate models once they have been created using the DSL. This tutorial will solely focus on model creation.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Before we begin, we will first load the Catalyst package (which is required to run the code).","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"using Catalyst","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_quick_start","page":"The Catalyst DSL - Introduction","title":"Quick-start summary","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"The DSL is initiated through the @reaction_network macro, which is followed by one line for each reaction. Each reaction consists of a rate, followed lists first of the substrates and next of the products. E.g. a Michaelis-Menten enzyme kinetics system can be written as ","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn = @reaction_network begin\n    (kB,kD), S + E <--> SE\n    kP, SE --> P + E\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, <--> is used to create a bi-directional reaction (with forward rate kP and backward rate kD). Next, the model (stored in the variable rn) can be used as input to various types of simulations.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_basic_syntax","page":"The Catalyst DSL - Introduction","title":"Basic syntax","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"The basic syntax of the DSL is","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"using Catalyst # hide\nrn = @reaction_network begin\n    2.0, X --> Y\n    1.0, Y --> X\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, you start with @reaction_network begin, next list all of the model's reactions, and finish with end. Each reaction consists of","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"A rate.\nA (potentially empty) set of substrates.\nA (potentially empty) set of products.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Each reaction line declares, in order, the rate, the substrate(s), and the product(s). The rate is separated from the substrate(s) by a ,, and the substrate(s) from the production by a --> (other arrows, however, are also possible). In the above example, our model consists of two reactions. In the first one, X (the single substrate) becomes Y (the single product) at rate 2.0. In the second reaction, Y becomes X at rate 1.0.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Finally, rn = is used to store the model in the variable rn (a normal Julia variable, which does not need to be called rn).","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_parameters_basics","page":"The Catalyst DSL - Introduction","title":"Defining parameters and species in the DSL","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Typically, the rates are not constants, but rather parameters (which values can be set e.g. at the beginning of each simulation). To set parametric rates, simply use whichever symbol you wish to represent your parameter with. E.g. to set the above rates to a and b, we use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn1 = @reaction_network begin\n    a, X --> Y\n    b, Y --> X\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here we have used single-character symbols to designate all species and parameters. Multi-character symbols, however, are also permitted. E.g. we could call the rates kX and kY:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn1 = @reaction_network begin\n    kX, X --> Y\n    kY, Y --> X\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Generally, anything that is a permitted Julia variable name can be used to designate a species or parameter in Catalyst.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reactions","page":"The Catalyst DSL - Introduction","title":"Different types of reactions","text":"","category":"section"},{"location":"model_creation/dsl_basics/#dsl_description_reactions_multiples","page":"The Catalyst DSL - Introduction","title":"Reactions with multiple substrates or products","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Previously, our reactions have had a single substrate and a single product. However, reactions with multiple substrates and/or products are possible. Here, all the substrates (or products) are listed and separated by a +. E.g. to create a model where X and Y bind (at rate kB) to form XY (which then can dissociate, at rate kD, to form XY) we use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn2 = @reaction_network begin\n    kB, X + Y --> XY\n    kD, XY --> X + Y\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Reactions can have any number of substrates and products, and their names do not need to have any relationship to each other, as demonstrated by the following mock model:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn3 = @reaction_network begin\n    k, X + Y + Z --> A + B + C + D\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reactions_degradation_and_production","page":"The Catalyst DSL - Introduction","title":"Reactions with degradation or production","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Some reactions have no products, in which case the substrate(s) are degraded (i.e. removed from the system). To denote this, set the reaction's right-hand side to 0. Similarly, some reactions have no substrates, in which case the product(s) are produced (i.e. added to the system). This is denoted by setting the left-hand side to 0. E.g. to create a model where a single species X is both created (in the first reaction) and degraded (in a second reaction), we use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn4 = @reaction_network begin\n    p, 0 --> X\n    d, X --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reactions_stoichiometries","page":"The Catalyst DSL - Introduction","title":"Reactions with non-unitary stoichiometries","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Reactions may include multiple copies of the same reactant (i.e. a substrate or a product). To specify this, the reactant is preceded by a number indicating its number of copies (also called the reactant's stoichiometry). E.g. to create a model where two copies of X dimerise to form X2 (which then dissociate back to two X copies) we use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn5 = @reaction_network begin\n    kB, 2X --> X2\n    kD, X2 --> 2X\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Reactants whose stoichiometries are not defined are assumed to have stoichiometry 1. Any integer number can be used, furthermore, decimal numbers and parameters can also be used as stoichiometries. A discussion of non-unitary (i.e. not equal to 1) stoichiometries affecting the created model can be found here.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Stoichiometries can be combined with () to define them for multiple reactants. Here, the following (mock) model declares the same reaction twice, both with and without this notation:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn6 = @reaction_network begin\n    k, 2X + 3(Y + 2Z) --> 5(V + W)    \n    k, 2X + 3Y + 6Z --> 5V + 5W    \nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reaction_bundling","page":"The Catalyst DSL - Introduction","title":"Bundling of similar reactions","text":"","category":"section"},{"location":"model_creation/dsl_basics/#dsl_description_reaction_bundling_reversible","page":"The Catalyst DSL - Introduction","title":"Bi-directional (or reversible) reactions","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"As is the case for the following two-state model:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn7 = @reaction_network begin\n    k1, X1 --> X2\n    k2, X2 --> X1\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"it is common that reactions occur in both directions (so-called bi-directional reactions). Here, it is possible to bundle the reactions into a single line by using the <--> arrow. When we do this, the rate term must include two separate rates (one for each direction, these are enclosed by a () and separated by a ,). I.e. the two-state model can be declared using:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn7 = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, the first rate (k1) denotes the forward rate and the second rate (k2) the backwards rate.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Catalyst also permits writing pure backwards reactions. These use identical syntax to forward reactions, but with the <-- arrow:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn8 = @reaction_network begin\n    k, X <-- Y\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, the substrate(s) are on the right-hand side and the product(s) are on the left-hand side. Hence, the above model can be written identically using:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn8 = @reaction_network begin\n    k, Y --> X\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Generally, using forward reactions is clearer than backwards ones, with the latter typically never being used.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reaction_bundling_similar","page":"The Catalyst DSL - Introduction","title":"Bundling similar reactions on a single line","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"There exist additional situations where models contain similar reactions (e.g. systems where all system components degrade at identical rates). Reactions which share either rates, substrates, or products can be bundled into a single line. Here, the parts which are different for the reactions are written using (,) (containing one separate expression for each reaction). E.g., let us consider the following model where species X and Y both degrade at the rate d:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn8 = @reaction_network begin\n    d, X --> 0\n    d, Y --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"These share both their rates (d) and products (0), however, the substrates are different (X and Y). Hence, the reactions can be bundled into a single line using the common rate and product expression while providing separate substrate expressions:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn8 = @reaction_network begin\n    d, (X,Y) --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"This declaration of the model is identical to the previous one. Reactions can share any subset of the rate, substrate, and product expression (the cases where they share all or none, however, do not make sense to use). I.e. if the two reactions also have different degradation rates:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn9 = @reaction_network begin\n    dX, X --> 0\n    dY, Y --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"This can be represented using:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn9 = @reaction_network begin\n    (dX,dY), (X,Y) --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is possible to use bundling for any number of reactions. E.g. in the following model we bundle the conversion of a species X between its various forms (where all reactions use the same rate k):","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn10 = @reaction_network begin\n    k, (X0,X1,X2,X3) --> (X1,X2,X3,X4)\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is possible to combine bundling with bi-directional reactions. In this case, the rate is first split into the forward and backwards rates. These may then (or may not) indicate several rates. We exemplify this using the two following two (identical) networks, created with and without bundling.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn11 = @reaction_network begin\n    kf, S --> P1\n    kf, S --> P2\n    kb_1, P1 --> S\n    kb_2, P2 --> S\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn11 = @reaction_network begin\n    (kf, (kb_1, kb_2)), S <--> (P1,P2)\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Like when we designated stoichiometries, reaction bundling can be applied very generally to create some truly complicated reactions:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn12 = @reaction_network begin\n    ((pX, pY, pZ),d), (0, Y0, Z0) <--> (X, Y, Z1+Z2)\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"However, like for the above model, bundling reactions too zealously can reduce (rather than improve) a model's readability.   ","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_nonconstant_rates","page":"The Catalyst DSL - Introduction","title":"Non-constant reaction rates","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"So far we have assumed that all reaction rates are constant (being either a number of a parameter). Non-constant rates that depend on one (or several) species are also possible. More generally, the rate can be any valid expression of parameters and species.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Let us consider a model with an activator (A, which degraded at a constant rate) and a protein (P). The production rate of P depends both on A and a parameter (kP). We model this through:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_13 = @reaction_network begin\n    d, A --> 0\n    kP*A, 0 --> P\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, P's production rate will be reduced as A decays. We can print the ODE this model produces with Latexify:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"using Latexify\nlatexify(rn_13; form=:ode)","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"In this case, we can generate an equivalent model by instead adding A as both a substrate and a product to P's production reaction:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_13_alt = @reaction_network begin\n    d, A --> 0\n    kp, A --> A + P\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"We can confirm that this generates the same ODE:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"latexify(rn_13_alt; form=:ode)","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, while these models will generate identical ODE, SDE, and jump simulations, the chemical reaction network models themselves are not equivalent. Generally, as pointed out in the two notes below, using the second form is preferable.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"warn: Warn\nWhile rn_13 and rn_13_alt will generate equivalent simulations, for jump simulations, the first model will have reduced performance (which generally are more performant when rates are constant).","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"danger: Danger\nCatalyst automatically infers whether quantities appearing in the DSL are species or parameters (as described here). Generally, anything that does not appear as a reactant is inferred to be a parameter. This means that if you want to model a reaction activated by a species (e.g. kp*A, 0 --> P), but that species does not occur as a reactant, it will be interpreted as a parameter. This can be handled by manually declaring the system species.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Above we used a simple example where the rate was the product of a species and a parameter. However, any valid Julia expression of parameters, species, and values can be used. E.g the following is a valid model:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_14 = @reaction_network begin\n    2.0 + X^2, 0 --> X + Y\n    k1 + k2^k3, X --> ∅\n    pi * X/(sqrt(2) + Y), Y → ∅\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_nonconstant_rates_functions","page":"The Catalyst DSL - Introduction","title":"Using functions in rates","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is possible for the rate to contain Julia functions. These can either be functions from Julia's standard library:  ","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_16 = @reaction_network begin\n    d, A --> 0\n    kp*sqrt(A), 0 --> P\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"or ones defined by the user:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"custom_function(p1, p2, X) = (p1 + X) / (p2 + X)\nrn_17 = @reaction_network begin\n    d, A --> 0\n    custom_function(k1,k2,E), 0 --> P\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_nonconstant_rates_available_functions","page":"The Catalyst DSL - Introduction","title":"Pre-defined functions","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Two functions frequently used within systems biology are the Michaelis-Menten and Hill functions. These are pre-defined in Catalyst and can be called using mm(X,v,K) and hill(X,v,K,n). E.g. a self-activation loop where X activates its own production through a Hill function can be created using:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_18 = @reaction_network begin\n    hill(X,v,K,n), 0 --> P\n    d, X --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Catalyst comes with the following predefined functions:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"The Michaelis-Menten function: mm(XvK) = v * X(X + K).\nThe repressive Michaelis-Menten function: mmr(XvK) = v * K(X + K).\nThe Hill function: hill(XvKn) = v * (X^n)(X^n + K^n).\nThe repressive Hill function: hillr(XvKn) = v * (K^n)(X^n + K^n).\nThe activating/repressive Hill function: hillar(XYvKn) = v * (X^n)(X^n + Y^n + K^n).","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_nonconstant_rates_time","page":"The Catalyst DSL - Introduction","title":"Time-dependant rates","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Previously we have assumed that the rates are independent of the time variable, t. However, time-dependent reactions are also possible. Here, simply use t to represent the time variable. E.g., to create a production/degradation model where the production rate decays as time progresses, we can use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_14 = @reaction_network begin\n    kp/(1 + t), 0 --> P\n    d, P --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Like previously, t can be part of any valid expression. E.g. to create a reaction with a cyclic rate (e.g. to represent a circadian system) we can use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_15 = @reaction_network begin\n    A*(sin(2π*f*t - ϕ)+1)/2, 0 --> P\n    d, P --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"warn: Warn\nJump simulations cannot be performed for models with time-dependent rates without additional considerations, which are discussed here.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_stoichiometries","page":"The Catalyst DSL - Introduction","title":"Non-standard stoichiometries","text":"","category":"section"},{"location":"model_creation/dsl_basics/#dsl_description_stoichiometries_decimal","page":"The Catalyst DSL - Introduction","title":"Non-integer stoichiometries","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Previously all stoichiometric constants have been integer numbers, however, decimal numbers are also permitted. Here we create a birth-death model where each production reaction produces 1.5 units of X:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_16 = @reaction_network begin\n    p, 0 --> 1.5X\n    d, X --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is also possible to have non-integer stoichiometric coefficients for substrates. However, in this case the combinatoric_ratelaw = false option must be used. We note that non-integer stoichiometric coefficients do not make sense in most fields, however, this feature is available for use for models where it does make sense.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_stoichiometries_parameters","page":"The Catalyst DSL - Introduction","title":"Parametric stoichiometries","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is possible for stoichiometric coefficients to be parameters. E.g. here we create a generic polymerisation system where n copies of X bind to form Xn:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_17 = @reaction_network begin\n    (kB,kD), n*X <--> Xn\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Now we can designate the value of n through a parameter when we e.g. create an ODEProblem:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"u0 = [:X => 5.0, :Xn => 1.0]\nps = [:kB => 1.0, :kD => 0.1, :n => 4]\noprob = ODEProblem(rn_17, u0, (0.0, 1.0), ps)\nnothing # hide","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_symbols","page":"The Catalyst DSL - Introduction","title":"Using special symbols","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Julia permits any Unicode characters to be used in variable names, thus Catalyst can use these as well. Below we describe some cases where this can be useful. No functionality is, however, tied to this.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_symbols_empty_set","page":"The Catalyst DSL - Introduction","title":"Using ∅ in degradation/production reactions","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Previously, we described how 0 could be used to create degradation or production reactions. Catalyst permits the user to instead use the ∅ symbol. E.g. the production/degradation system can alternatively be written as:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn4 = @reaction_network begin\n    p, ∅ --> X\n    d, X --> ∅\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_symbols_arrows","page":"The Catalyst DSL - Introduction","title":"Using special arrow symbols","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Catalyst uses -->, <-->, and <-- to denote forward, bi-directional, and backwards reactions, respectively. Several unicode representations of these arrows are available. Here,","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":">, →, ↣, ↦, ⇾, ⟶, ⟼, ⥟, ⥟, ⇀, and ⇁ can be used to represent forward reactions.\n↔, ⟷, ⇄, ⇆, ⇌, ⇋, , and ⇔ can be used to represent bi-directional reactions.\n<, ←, ↢, ↤, ⇽, ⟵, ⟻, ⥚, ⥞, ↼, , and ↽ can be used to represent backwards reactions. ","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"E.g. the production/degradation system can alternatively be written as:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn4 = @reaction_network begin\n    p, ∅ → X\n    d, X → ∅\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_symbols_special","page":"The Catalyst DSL - Introduction","title":"Using special symbols to denote species or parameters","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"A range of possible characters are available which can be incorporated into species and parameter names. This includes, but is not limited to:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Greek letters (e.g α, σ, τ, and Ω).\nSuperscript and subscript characters (to create e.g. k₁, k₂, Xₐ, and Xᴾ).\nNon-latin, non-greek, letters (e.g. ä, Д, س, and א).\nOther symbols (e.g. £, ℂ, ▲, and ♠).","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"An example of how this can be used to create a neat-looking model can be found in Schwall et al. (2021) where it was used to model a sigma factor V circuit in the bacteria Bacillus subtilis:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"σᵛ_model = @reaction_network begin\n    v₀ + hill(σᵛ,v,K,n), ∅ → σᵛ + A\n    kdeg, (σᵛ, A, Aσᵛ) → ∅\n    (kB,kD), A + σᵛ ↔ Aσᵛ\n    L, Aσᵛ → σᵛ\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"This functionality can also be used to create less serious models: rn13 = @reactionnetwork begin     🍦, 😢 –> 😃 end","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It should be noted that the following symbols are not permitted to be used as species or parameter names:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"pi and π (used in Julia to denote 3.1415926535897...).\nℯ (used in Julia to denote Euler's constant).\nt (used to denote the time variable).\n∅ (used for production/degradation reactions).\nim (used in Julia to represent complex numbers).\nnothing (used in Julia to denote nothing).\nΓ (used by Catalyst to represent conserved quantities).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Fitting parameters to data involves solving an optimisation problem (that is, finding the parameter set that optimally fits your model to your data, typically by minimising a cost function). The SciML ecosystem's primary package for solving optimisation problems is Optimization.jl. It provides access to a variety of solvers via a single common interface by wrapping a large number of optimisation libraries that have been implemented in Julia.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"This tutorial demonstrates both how to create parameter fitting cost functions using the DiffEqParamEstim.jl package, and how to use Optimization.jl to minimise these. Optimization.jl can also be used in other contexts, such as finding parameter sets that maximise the magnitude of some system behaviour. More details on how to use these packages can be found in their respective documentations.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_basics","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Basic example","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Let us consider a Michaelis-Menten enzyme kinetics model, where an enzyme (E) converts a substrate (S) into a product (P):","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"using Catalyst\nrn = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"From some known initial condition, and a true parameter set (which we later want to recover from the data) we generate synthetic data (on which we will demonstrate the fitting process).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"# Define initial conditions and parameters.\nu0 = [:S => 1.0, :E => 1.0, :SE => 0.0, :P => 0.0]\nps_true = [:kB => 1.0, :kD => 0.1, :kP => 0.5]\n\n# Generate synthetic data.\nusing OrdinaryDiffEq\noprob_true = ODEProblem(rn, u0, (0.0, 10.0), ps_true)\ntrue_sol = solve(oprob_true)\ndata_sol = solve(oprob_true; saveat=1.0)\ndata_ts = data_sol.t[2:end]\ndata_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\n# Plots the true solutions and the (synthetic) data measurements.\nusing Plots\nplot(true_sol; idxs = :P, label = \"True solution\", lw = 8)\nplot!(data_ts, data_vals; label = \"Measurements\", seriestype=:scatter, ms = 6, color = :blue)","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Next, we will use DiffEqParamEstim to build a loss function to measure how well our model's solutions fit the data.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"using DiffEqParamEstim, Optimization\nps_dummy = [:kB => 0.0, :kD => 0.0, :kP => 0.0]\noprob = ODEProblem(rn, u0, (0.0, 10.0), ps_dummy)\nloss_function = build_loss_objective(oprob, Tsit5(), L2Loss(data_ts, data_vals), Optimization.AutoForwardDiff(); \n                                     maxiters = 10000, verbose = false, save_idxs = 4)\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"To build_loss_objective we provide the following arguments:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"oprob: The ODEProblem with which we simulate our model (using some dummy parameter values, since we do not know these).\nTsit5(): The numeric solver we wish to simulate our model with.\nL2Loss(data_ts, data_vals): Defines the loss function. While other alternatives are available, L2Loss is the simplest one (measuring the sum of squared distances between model simulations and data measurements). Its first argument is the time points at which the data is collected, and the second is the data's values.\nOptimization.AutoForwardDiff(): Our choice of automatic differentiation framework.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Furthermore, we can pass any number of additional optional arguments, these are then passed to the internal solve() function (which is used to solve our ODE). Here we provide the following additional arguments:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"maxiters = 10000: If the ODE integrator takes a very large number of steps, that can be a sign of a very poor fit (or stiffness in the ODEs, but that is not a concern for our current example). Reducing the maxiters threshold reduces the time we waste on evaluating such models. \nverbose = false: The simulation of models with highly unsuitable parameter sets typically generate various warnings (such as premature simulation termination due to reaching maxiters time steps). To avoid an overflow of such (here unnecessary) warnings, as we evaluate a large number of parameter sets, we turn warnings off.\nsave_idxs = 4: The measured species (P) is the 4th species in our species vector (species(rn)). Since data is available for P(t), we will only save the value of this species.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Now we can create an OptimizationProblem using our loss_function and some initial guess of parameter values from which the optimiser will start:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"optprob = OptimizationProblem(loss_function, [1.0, 1.0, 1.0])\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"note: Note\nOptimizationProblem cannot currently accept parameter values in the form of a map (e.g. [:kB => 1.0, :kD => 1.0, :kP => 1.0]). These must be provided as individual values (using the same order as the parameters occur in in the parameters(rs) vector). Similarly, build_loss_objective's save_idxs uses the species' indexes, rather than the species directly. These inconsistencies should be remedied in future DiffEqParamEstim releases.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Finally, we can optimise optprob to find the parameter set that best fits our data. Optimization.jl only provides a few optimisation methods natively. However, for each supported optimisation package, it provides a corresponding wrapper-package to import that optimisation package for use with Optimization.jl. E.g., if we wish to use NLopt.jl's Nelder-Mead method, we must install and import the OptimizationNLopt package. A summary of all, by Optimization.jl supported, optimisation packages can be found here. Here, we import the NLopt.jl package and uses it to minimise our cost function (thus finding a parameter set that fits the data):","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"using OptimizationNLopt\noptsol = solve(optprob, NLopt.LN_NELDERMEAD())\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"We can now simulate our model for the corresponding parameter set, checking that it fits our data.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"oprob_fitted = remake(oprob; p = optsol.u)\nfitted_sol = solve(oprob_fitted, Tsit5())\nplot!(fitted_sol; idxs = :P, label = \"Fitted solution\", linestyle = :dash, lw = 6, color = :lightblue)","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"note: Note\nHere, a good exercise is to check the resulting parameter set and note that, while it creates a good fit to the data, it does not actually correspond to the original parameter set. Identifiability is a concept that studies how to deal with this problem.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Say that we instead would like to use the Broyden–Fletcher–Goldfarb–Shannon algorithm, as implemented by the Optim.jl package. In this case we would run:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"using OptimizationOptimJL\nsol = solve(optprob, Optim.LBFGS())\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_multiple_species","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Optimisation problems with data for multiple species","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Imagine that, in our previous example, we had measurements of the concentration of both S and P:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"data_vals_S = (0.8 .+ 0.4*rand(10)) .* data_sol[:S][2:end]\ndata_vals_P = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\nplot(true_sol; idxs=[:S, :P], label=[\"True S\" \"True P\"], lw=8)\nplot!(data_ts, data_vals_S; label=\"Measured S\", seriestype=:scatter, ms=6, color=:blue)\nplot!(data_ts, data_vals_P; label=\"Measured P\", seriestype=:scatter, ms=6, color=:red)","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"In this case we would have to use the L2Loss(data_ts, hcat(data_vals_S, data_vals_P)) and save_idxs=[1, 4] arguments in loss_function:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"loss_function_S_P = build_loss_objective(oprob, Tsit5(), L2Loss(data_ts, Array(hcat(data_vals_S, data_vals_P)')), Optimization.AutoForwardDiff(); maxiters=10000, verbose=false, save_idxs=[1, 4])\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Here, Array(hcat(data_vals_S, data_vals_P)') is required to put the data in the right form (in this case, a 2x10 matrix).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"We can now fit our model to data and plot the results:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"optprob_S_P = OptimizationProblem(loss_function_S_P, [1.0, 1.0, 1.0])\noptsol_S_P = solve(optprob_S_P, Optim.NelderMead())\noprob_fitted_S_P = remake(oprob; p = optsol_S_P.u)\nfitted_sol_S_P = solve(oprob_fitted_S_P)\nplot!(fitted_sol_S_P; idxs=[:S, :P], label=\"Fitted solution\", linestyle = :dash, lw = 6, color = [:lightblue :pink])","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_constraints","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Setting parameter constraints and boundaries","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Sometimes, it is desirable to set boundaries on parameter values. Indeed, this can speed up the optimisation process (by preventing searching through unfeasible parts of parameter space), and can also be a requirement for some optimisation methods. This can be done by passing the lb (lower bounds) and up (upper bounds) arguments to OptimizationProblem. These are vectors (of the same length as the number of parameters), with each argument corresponding to the boundary value of the parameter with the same index (as used in the parameters(rn) vector). If we wish to constrain each parameter to the interval (01 100) this can be done through:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"optprob = OptimizationProblem(loss_function, [1.0, 1.0, 1.0]; lb = [1e-1, 1e-1, 1e-1], ub = [1e1, 1e1, 1e1])\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"In addition to boundaries, Optimization.jl also supports setting linear and non-linear constraints on its output solution for some optimizers.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_known_parameters","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter fitting with known parameters","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"If we from previous knowledge know that kD = 01, and only want to fit the values of kB and kP, this can be achieved through build_loss_objective's prob_generator argument. First, we create a function (fixed_p_prob_generator) that modifies our ODEProblem to incorporate this knowledge:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"fixed_p_prob_generator(prob, p) = remake(prob; p = vcat(p[1], 0.1, p[2]))\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Here, it takes the ODEProblem (prob) we simulate, and the parameter set used, during the optimisation process (p), and creates a modified ODEProblem (by setting a customised parameter vector using remake). Now we create our modified loss function:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"loss_function_fixed_kD = build_loss_objective(oprob, Tsit5(), L2Loss(data_ts, data_vals), Optimization.AutoForwardDiff(); prob_generator = fixed_p_prob_generator, maxiters=10000, verbose=false, save_idxs=4)\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"We can create an OptimizationProblem from this one like previously, but keep in mind that it (and its output results) only contains two parameter values (k* and kP):","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"optprob_fixed_kD = OptimizationProblem(loss_function_fixed_kD, [1.0, 1.0])\noptsol_fixed_kD = solve(optprob_fixed_kD, Optim.NelderMead())\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_log_scale","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Fitting parameters on the logarithmic scale","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Often it can be advantageous to fit parameters on a logarithmic scale (rather than on a linear scale). The best way to do this is to simply replace each parameter in the model definition by its logarithmic version:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"using Catalyst\nrn = @reaction_network begin\n    10^kB, S + E --> SE\n    10^kD, SE --> S + E\n    10^kP, SE --> P + E\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"And then going forward, by keeping in mind that parameter values are logarithmic. Here, setting","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"p_true = [:kB => 0.0, :kD => -1.0, :kP => 10^(0.5)]\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"corresponds to the same true parameter values as used previously ([:kB => 1.0, :kD => 0.1, :kP => 0.5]).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_multiple_experiments","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter fitting to multiple experiments","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Say that we had measured our model for several different initial conditions, and would like to fit our model to all these measurements simultaneously. This can be done by first creating a corresponding EnsembleProblem. How to then create loss functions for these are described in more detail here.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_solver_options","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Optimisation solver options","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"Optimization.jl supports various optimisation solver options that can be supplied to the solve command. For example, to set a maximum number of seconds (after which the optimisation process is terminated), you can use the maxtime argument:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"optsol_fixed_kD = solve(optprob, Optim.NelderMead(); maxtime = 100)\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#structural_identifiability_citation","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Citation","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"If you use this functionality in your research, please cite the following paper to support the authors of the Optimization.jl package:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"@software{vaibhav_kumar_dixit_2023_7738525,\n\tauthor = {Vaibhav Kumar Dixit and Christopher Rackauckas},\n\tmonth = mar,\n\tpublisher = {Zenodo},\n\ttitle = {Optimization.jl: A Unified Optimization Package},\n\tversion = {v3.12.1},\n\tdoi = {10.5281/zenodo.7738525},\n  \turl = {https://doi.org/10.5281/zenodo.7738525},\n\tyear = 2023\n}","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#References","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"References","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","title":"Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl","text":"[1]: Alejandro F. Villaverde, Dilan Pathirana, Fabian Fröhlich, Jan Hasenauer, Julio R. Banga, A protocol for dynamic model calibration, Briefings in Bioinformatics (2023).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The Catalyst tool for the modelling of chemical reaction networks is based in the Julia programming language. While experience in Julia programming is advantageous for using Catalyst, it is not necessary for accessing most of its basic features. This tutorial serves as an introduction to Catalyst for those unfamiliar with Julia, while also introducing some basic Julia concepts. Anyone who plans on using Catalyst extensively is recommended to familiarise oneself more thoroughly with the Julia programming language. A collection of resources for learning Julia can be found here, and a full documentation is available here. A more practical (but also extensive) guide to Julia programming can be found here.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Julia can be downloaded here. Generally, it is recommended to use the juliaup tool to install and update Julia. Furthermore, Visual Studio Code is a good IDE with extensive Julia support, and a good default choice.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Users who are already familiar with Julia can skip to the Introduction to Catalyst tutorial.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Basic-Julia-usage","page":"Introduction to Catalyst and Julia for New Julia users","title":"Basic Julia usage","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"On the surface, Julia has many similarities to languages like MATLAB, Python, and R.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Values can be assigned to variables through = sign. Values (possibly stored in variables) can be used for most basic computations.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"length = 2.0\nwidth = 4.0\narea = length * width","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Functions take one or more inputs (enclosed by ()) and return some output. E.g. the min function returns the minimum of two values.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"min(1.0, 3.0)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Julia has a specific help mode, which can be queried for information about any function (including those defined by Catalyst).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Each Julia variable has a specific type, designating what type of value it contains. While not directly required to use Catalyst, this is useful to be aware of. To learn the type of a specific variable, use the typeof function. More information about types can be found here.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"typeof(1.0)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, Float64 denotes decimal-valued numbers. Integer-valued numbers instead have the Int64 type.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"typeof(1)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"There exists a large number of Julia types (with even more being defined by various packages). Additional examples include Strings (defined by enclosing text within \" \"):","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"\"Hello world!\"","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"and Symbols (defined by pre-appending an expression with :):","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":":Julia","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, we note that the first time some code is run in Julia, it has to be compiled. However, this is only required once per Julia session. Hence, the second time the same code is run, it runs much faster. E.g. try running this line of code first one time, and then one additional time. You will note that the second run is much faster.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"rand(100, 100)^3.5\nnothing # hide","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"(This code creates a random 100x100 matrix, and takes it to the power of 3.5)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"This is useful to know when you e.g. declare, simulate, or plot, a Catalyst model. The first time you run a command there might be a slight delay. However, subsequent runs will be much quicker. This holds even if you make minor adjustments before the second run (such as changing simulation initial conditions).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_intro","page":"Introduction to Catalyst and Julia for New Julia users","title":"Installing and activating packages","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Due to its native package manager (Pkg), and a registry of almost all packages of relevancy, package management in Julia is unusually easy. Here, we will briefly describe how to install and activate Catalyst (and two additional packages relevant to this tutorial).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"To import a Julia package into a session, you can use the using PackageName command (where PackageName is the name of the package you wish to import). However, before you can do so, it must first be installed on your computer. This is done through the Pkg.add(\"PackageName\") command:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg\nPkg.add(\"Catalyst\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, the Julia package manager package (Pkg) is by default installed on your computer when Julia is installed, and can be activated directly. Next, we also wish to install the OrdinaryDiffEq and Plots packages (for numeric simulation of models, and plotting, respectively).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.add(\"OrdinaryDiffEq\")\nPkg.add(\"Plots\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Once a package has been installed through the Pkg.add command, this command does not have to be repeated if we restart our Julia session. We can now import all three packages into our current session with:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Catalyst\nusing OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, if we restart Julia, these using commands must be rerun.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"A more comprehensive (but still short) introduction to package management in Julia is provided at the end of this documentation page. It contains some useful information and is hence highly recommended reading. For a more detailed introduction to Julia package management, please read the Pkg documentation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Simulating-a-basic-Catalyst-model","page":"Introduction to Catalyst and Julia for New Julia users","title":"Simulating a basic Catalyst model","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Now that we have some basic familiarity with Julia, and have installed and imported the required packages, we will create and simulate a basic chemical reaction network model using Catalyst.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Catalyst models are created through the @reaction_network macro. For more information on macros, please read the Julia documentation on macros. This documentation is, however, rather advanced (and not required to use Catalyst). We instead recommend that you simply familiarise yourself with the Catalyst syntax, without studying in detail how macros work and what they are.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The @reaction_network command is followed by the begin keyword, which is followed by one line for each reaction of the model. Each reaction consists of a reaction rate, followed by the reaction itself. The reaction contains a set of substrates and a set of products (what is consumed and produced by the reaction, respectively). These are separated by a --> arrow. Finally, the model ends with the end keyword.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, we create a simple birth-death model, where a single species (X) is created at rate b, and degraded at rate d. The model is stored in the variable rn.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"rn = @reaction_network begin\n    b, 0 --> X\n    d, X --> 0\nend","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"For more information on how to use the Catalyst model creator (also known as the Catalyst DSL), please read the corresponding documentation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Next, we wish to simulate our model. To do this, we need to provide some additional information to the simulator. This is","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The initial condition. That is, the concentration (or copy numbers) of each species at the start of the simulation.\nThe time span. That is, the time frame over which we wish to run the simulation.\nThe parameter values. That is, the values of the model's parameters for this simulation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The initial condition is given as a Vector. This is a type which collects several different values. To declare a vector, the values are specific within brackets, [], and separated by ,. Since we only have one species, the vector holds a single element. In this element, we set the value of X using the :X => 1.0 syntax. Here, we first denote the name of the species (with a : pre-appended, which creates a Symbol), next follows a => and then the value of X. Since we wish to simulate the concentration of X over time, we will let the initial condition be decimal valued.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"u0 = [:X => 1.0]","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The timespan sets the time point at which we start the simulation (typically 0.0 is used) and the final time point of the simulation. These are combined into a two-valued tuple. Tuples are similar to vectors, but are enclosed by () and not []. Again, we will let both time points be decimal valued.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"tspan = (0.0, 10.0)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, the parameter values are, like the initial conditions, given in a vector. Since we have two parameters (b and d), the parameter vector has two values. We use a similar notation for setting the parameter values as the initial condition (first the parameter, then an arrow, then the value).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"params = [:b => 1.0, :d => 0.2]","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Please read here for more information on vectors and tuples.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Next, before we can simulate our model, we bundle all the required information together in a so-called ODEProblem. Note that the order in which the input (the model, the initial condition, the timespan, and the parameter values) is provided to the ODEProblem matters. E.g. the parameter values cannot be provided as the first argument, but have to be the fourth argument. Here, we save our ODEProblem in the oprob variable.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"oprob = ODEProblem(rn, u0, tspan, params)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We can now simulate our model. We do this by providing the ODEProblem to the solve function. We save the output to the sol variable.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"sol = solve(oprob)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, we can plot the solution through the plot function.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"plot(sol)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, the plot shows the time evolution of the concentration of the species X from its initial condition.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"For more information about the numerical simulation package, please see the DifferentialEquations documentation. For more information about the plotting package, please see the Plots documentation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Additional-modelling-example","page":"Introduction to Catalyst and Julia for New Julia users","title":"Additional modelling example","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"To make this introduction more comprehensive, we here provide another example, using a more complicated model. Instead of simulating our model as concentrations evolve over time, we will now simulate the individual reaction events through the Gillespie algorithm (a common approach for adding noise to models).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Remember (unless we have restarted Julia) we do not need to activate our packages (through the using command) again. However, we do need to install, and then import, the JumpProcesses package (just to perform Gillespie, and other jump, simulations)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.add(\"JumpProcesses\")\nusing JumpProcesses","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"This time, we will declare a so-called SIR model for an infectious disease. Note that even if this model does not describe a set of chemical reactions, it can be modelled using the same framework. The model consists of 3 species:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"S\n, the amount of susceptible individuals.\nI\n, the amount of infected individuals.\nR\n, the amount of recovered (or removed) individuals.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"It also has 2 reaction events:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Infection, where a susceptible individual meets an infected individual and also becomes infected.\nRecovery, where an infected individual recovers from the infection.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Each reaction is also associated with a specific rate (corresponding to a parameter).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"b, the infection rate.\nk, the recovery rate.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We declare the model using the @reaction_network macro, and store it in the sir_model variable.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"sir_model = @reaction_network begin\n    b, S + I --> 2I\n    k, I --> R\nend","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Note that the first reaction contains two different substrates (separated by a + sign). While there is only a single product (I), two copies of I are produced. The 2 in front of the product I denotes this.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Next, we declare our initial condition, time span, and parameter values. Since we want to simulate the individual reaction events that discretely change the state of our model, we want our initial conditions to be integer-valued. We will start with a mostly susceptible population, but to which a single infected individual has been introduced.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"u0 = [:S => 50, :I => 1, :R => 0]\ntspan = (0.0, 10.0)\nparams = [:b => 0.2, :k => 1.0]\nnothing # hide","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Previously we have bundled this information into an ODEProblem (denoting a deterministic ordinary differential equation). Now we wish to simulate our model as a jump process (where each reaction event corresponds to a single jump in the state of the system). We do this by first creating a DiscreteProblem, and then using this as an input to a JumpProblem.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using JumpProcesses # hide\ndprob = DiscreteProblem(sir_model, u0, tspan, params)\njprob = JumpProblem(sir_model, dprob, Direct())","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Again, the order in which the inputs are given to the DiscreteProblem and the JumpProblem is important. The last argument to the JumpProblem (Direct()) denotes which simulation method we wish to use. For now, we recommend that users simply use the Direct() option, and then consider alternative ones (see the JumpProcesses.jl docs) when they are more familiar with modelling in Catalyst and Julia.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, we can simulate our model using the solve function, and plot the solution using the plot function. For jump simulations, the solve function also requires a second argument (SSAStepper()). This is a time-stepping algorithm that calls the Direct solver to advance a simulation. Again, we recommend at this stage you simply use this option, and then explore exactly what this means at a later stage.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"sol = solve(jprob, SSAStepper())\nsol = solve(jprob, SSAStepper(); seed=1234) # hide\nplot(sol)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Exercise: Try simulating the model several times. Note that the epidemic doesn't always take off, but sometimes dies out without spreading through the population. Try changing the infection rate (b), determining how this value affects the probability that the epidemic goes through the population.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages","page":"Introduction to Catalyst and Julia for New Julia users","title":"Package management in Julia","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We have previously introduced how to install and activate Julia packages. While this is enough to get started with Catalyst, for long-term users, there are some additional considerations for a smooth experience. These are described here.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_environments","page":"Introduction to Catalyst and Julia for New Julia users","title":"Setting up a new Julia environment","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Whenever you run Julia, it will run in a specific environment. You can specify any folder on your computer as a Julia environment. Some modes of running Julia will automatically use the environment corresponding to the folder you start Julia in. Others (or if you start Julia in a folder without an environment), will use your default environment. In these cases you can, during your session, switch to another environment. While it is possible to not worry about environments (and always use the default one), this can lead to long-term problems as more packages are installed.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"To activate your current folder as an environment, run the following commands:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"This will:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If your current folder (which can be displayed using the pwd() command) is not designated as a possible Julia environment, designate it as such.\nSwitch your current Julia session to use the current folder's environment.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"note: Note\n","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If you check any folder which has been designated as a Julia environment, it contains a Project.toml and a Manifest.toml file. These store all information regarding the corresponding environment. For non-advanced users, it is recommended to never touch these files directly (and instead do so using various functions from the Pkg package, the important ones which are described in the next two subsections).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_installing","page":"Introduction to Catalyst and Julia for New Julia users","title":"Installing and importing packages in Julia","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Package installation and import have been described previously. However, for the sake of this extended tutorial, let us repeat the description by demonstrating how to install the Latexify.jl package (which enables e.g. displaying Catalyst models in Latex format). First, we import the Julia Package manager (Pkg) (which is required to install Julia packages):","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Latexify is a registered package, so it can be installed directly using:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.add(\"Latexify\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, to import Latexify into our current Julia session we use:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Latexify","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, using Latexify must be rerun whenever you restart a Julia session. However, you only need to run Pkg.add(\"Latexify\") once to install it on your computer (but possibly additional times to add it to new environments, see the next section).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_environment_importance","page":"Introduction to Catalyst and Julia for New Julia users","title":"Why environments are important","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We have previously described how to set up new Julia environments, how to install Julia packages, and how to import them into a current session. Let us say that you were to restart Julia in a new folder and activate this as a separate environment. If you then try to import Latexify through using Latexify you will receive an error claiming that Latexify was not found. The reason is that the Pkg.add(\"Latexify\") command actually carries out two separate tasks:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If Latexify is not already installed on your computer, install it.\nAdd Latexify as an available package to your current environment.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, while Catalyst has previously been installed on your computer, it has not been added to the new environment you created. To do so, simply run ","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg\nPkg.add(\"Latexify\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"after which Catalyst can be imported through using Latexify. You can get a list of all packages available in your current environment using:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.status()","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"So, why is this required, and why cannot we simply import any package installed on our computer? The reason is that most packages depend on other packages, and these dependencies may be restricted to only specific versions of these packages. This creates complicated dependency graphs that restrict what versions of what packages are compatible with each other. When you use Pkg.add(\"PackageName\"), only a specific version of that package is actually added (the latest possible version as permitted by the dependency graph). Here, Julia environments both define what packages are available and their respective versions (these versions are also displayed by the Pkg.status() command). By doing this, Julia can guarantee that the packages (and their versions) specified in an environment are compatible with each other.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The reason why all this is important is that it is highly recommended to, for each project, define a separate environment. To these, only add the required packages. General-purpose environments with a large number of packages often, in the long term, produce package incompatibility issues. While these might not prevent you from installing all desired package, they often mean that you are unable to use the latest version of some packages.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"note: Note\n","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"A not-infrequent cause for reported errors with Catalyst (typically the inability to replicate code in tutorials) is package incompatibilities in large environments preventing the latest version of Catalyst from being installed. Hence, whenever an issue is encountered, it is useful to run Pkg.status() to check whenever the latest version of Catalyst is being used.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Some additional useful Pkg commands are:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pk.rm(\"PackageName\") removes a package from the current environment.\nPkg.update(\"PackageName\"): updates the designated package.\nPkg.update(): updates all packages.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"note: Note\n","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"A useful feature of Julia's environment system is that enables the exact definition of what packages and versions were used to execute a script. This supports e.g. reproducibility in academic research. Here, by providing the corresponding Project.toml and Manifest.toml files, you can enable someone to reproduce the exact program used to perform some set of analyses.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Feedback","page":"Introduction to Catalyst and Julia for New Julia users","title":"Feedback","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If you are a new Julia user who has used this tutorial, and there was something you struggled with or would have liked to have explained better, please raise an issue. That way, we can continue improving this tutorial. The same goes for any part of the Catalyst documentation: It is written to help new users understand how to use the package, and if it is not doing so successfully we would like to know!","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#References","page":"Introduction to Catalyst and Julia for New Julia users","title":"References","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"[1]: Jeff Bezanson, Alan Edelman, Stefan Karpinski, Viral B. Shah, Julia: A Fresh Approach to Numerical Computing, SIAM Review (2017).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"[2]: Torkel E. Loman, Yingbo Ma, Vasily Ilin, Shashi Gowda, Niklas Korsbo, Nikhil Yewale, Chris Rackauckas, Samuel A. Isaacson, Catalyst: Fast and flexible modeling of reaction networks, PLOS Computational Biology (2023).","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/#parameter_estimation","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"","category":"section"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"In this example we will use Optimization.jl to fit the parameters of an oscillatory system (the Brusselator) to data. Here, special consideration is taken to avoid reaching a local minimum. Instead of fitting the entire time series directly, we will start with fitting parameter values for the first period, and then use those as an initial guess for fitting the next (and then these to find the next one, and so on). Using this procedure is advantageous for oscillatory systems, and enables us to reach the global optimum.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"First, we fetch the required packages.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"using Catalyst\nusing OrdinaryDiffEq\nusing Optimization\nusing OptimizationOptimisers # Required for the ADAM optimizer.\nusing SciMLSensitivity # Required for `Optimization.AutoZygote()` automatic differentiation option.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we declare our model, the Brusselator oscillator.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"brusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\np_real = [:A => 1., :B => 2.]\nnothing # hide","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"We simulate our model, and from the simulation generate sampled data points (to which we add noise). We will use this data to fit the parameters of our model.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"u0 = [:X => 1.0, :Y => 1.0]\ntspan = (0.0, 30.0)\n\nsample_times = range(tspan[1]; stop = tspan[2], length = 100)\nprob = ODEProblem(brusselator, u0, tspan, p_real)\nsol_real = solve(prob, Rosenbrock23(); tstops = sample_times)\nsample_vals = Array(sol_real(sample_times))\nsample_vals .*= (1 .+ .1 * rand(Float64, size(sample_vals)) .- .05)\nnothing   # hide","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"We can plot the real solution, as well as the noisy samples.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"using Plots\ndefault(; lw = 3, framestyle = :box, size = (800, 400))\n\nplot(sol_real; legend = nothing, color = [:darkblue :darkred])\nscatter!(sample_times, sample_vals'; color = [:blue :red], legend = nothing)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we create a function to fit the parameters using the ADAM optimizer. For a given initial estimate of the parameter values, pinit, this function will fit parameter values, p, to our data samples. We use tend to indicate the time interval over which we fit the model.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"function optimise_p(pinit, tend)\n    function loss(p, _)\n        newtimes = filter(<=(tend), sample_times)\n        newprob = remake(prob; tspan = (0.0, tend), p = p)\n        sol = Array(solve(newprob, Rosenbrock23(); saveat = newtimes))\n        loss = sum(abs2, sol .- sample_vals[:, 1:size(sol,2)])\n        return loss, sol\n    end\n\n    # optimize for the parameters that minimize the loss\n    optf = OptimizationFunction(loss, Optimization.AutoZygote())\n    optprob = OptimizationProblem(optf, pinit)\n    sol = solve(optprob, ADAM(0.1); maxiters = 100)\n\n    # return the parameters we found\n    return sol.u\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we will fit a parameter set to the data on the interval (0, 10).","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p([5.0, 5.0], 10.0)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"We can compare this to the real solution, as well as the sample data","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"newprob = remake(prob; tspan = (0., 10.), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times, sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we use this parameter estimate as the input to the next iteration of our fitting process, this time on the interval (0, 20).","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p(p_estimate, 20.)\nnewprob = remake(prob; tspan = (0., 20.), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times, sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Finally, we use this estimate as the input to fit a parameter set on the full time interval of the sampled data.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p(p_estimate, 30.0)\n\nnewprob = remake(prob; tspan = (0., 30.0), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times, sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"The final parameter estimate is then","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"which is close to the actual parameter set of [1.0, 2.0].","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/#Why-we-fit-the-parameters-in-iterations","page":"Fitting Parameters for an Oscillatory System","title":"Why we fit the parameters in iterations","text":"","category":"section"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"As previously mentioned, the reason we chose to fit the model on a smaller interval to begin with, and then extend the interval, is to avoid getting stuck in a local minimum. Here specifically, we chose our initial interval to be smaller than a full cycle of the oscillation. If we had chosen to fit a parameter set on the full interval immediately we would have obtained poor fit and an inaccurate estimate for the parameters.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p([5.0,5.0], 30.0)\n\nnewprob = remake(prob; tspan = (0.0,30.0), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times,sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/#Steady-state-stability-computation","page":"Steady state stability computation","title":"Steady state stability computation","text":"","category":"section"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"After system steady states have been found using HomotopyContinuation.jl, NonlinearSolve.jl, or other means, their stability can be computed using Catalyst's steady_state_stability function. Systems with conservation laws will automatically have these removed, permitting stability computation on systems with singular Jacobian.","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"warn: Warn\nCatalyst currently computes steady state stabilities using the naive approach of checking whether a system's largest eigenvalue real part is negative. While more advanced stability computation methods exist (and would be a welcome addition to Catalyst), there is no direct plans to implement these. Furthermore, Catalyst uses a tolerance tol = 10*sqrt(eps()) to determine whether a computed eigenvalue is far away enough from 0 to be reliably used. This threshold can be changed through the tol keyword argument.","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/#Basic-examples","page":"Steady state stability computation","title":"Basic examples","text":"","category":"section"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Let us consider the following basic example:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"using Catalyst\nrn = @reaction_network begin \n    (p,d), 0 <--> X\nend","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"It has a single (stable) steady state at X = pd. We can confirm stability using the steady_state_stability function, to which we provide the steady state, the reaction system, and the parameter values:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"ps = [:p => 2.0, :d => 0.5]\nsteady_state = [:X => 4.0]\nsteady_state_stability(steady_state, rn, ps)","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Next, let us consider the following self-activation loop:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"sa_loop = @reaction_network begin \n    (hill(X,v,K,n),d), 0 <--> X\nend","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"For certain parameter choices, this system exhibits multi-stability. Here, we can find the steady states using homotopy continuation:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"import HomotopyContinuation\nps = [:v => 2.0, :K => 0.5, :n => 3, :d => 1.0]\nsteady_states = hc_steady_states(sa_loop, ps)","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Next, we can apply steady_state_stability to each steady state yielding a vector of their stabilities:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"[steady_state_stability(sstate, sa_loop, ps) for sstate in steady_states]","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Finally, as described above, Catalyst uses an optional argument, tol, to determine how strict to make the stability check.  I.e. below we set the tolerance to 1e-6 (a larger value, that is stricter, than the default of 10*sqrt(eps()))","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"[steady_state_stability(sstate, sa_loop, ps; tol = 1e-6) for sstate in steady_states]\nnothing# hide","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/#Pre-computing-the-Jacobian-to-increase-performance-when-computing-stability-for-many-steady-states","page":"Steady state stability computation","title":"Pre-computing the Jacobian to increase performance when computing stability for many steady states","text":"","category":"section"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Catalyst uses the system Jacobian to compute steady state stability, and the Jacobian is computed once for each call to steady_state_stability. If you repeatedly compute stability for steady states of the same system, pre-computing the Jacobian and supplying it to the steady_state_stability function can improve performance. ","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"In this example we use the self-activation loop from previously, pre-computes its Jacobian, and uses it to multiple steady_state_stability calls:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"ss_jac = steady_state_jac(sa_loop)\n\nps_1 = [:v => 2.0, :K => 0.5, :n => 3, :d => 1.0]\nsteady_states_1 = hc_steady_states(sa_loop, ps)\nstabs_1 = [steady_state_stability(st, sa_loop, ps_1; ss_jac) for st in steady_states_1]\n\nps_2 = [:v => 4.0, :K => 1.5, :n => 2, :d => 1.0]\nsteady_states_2 = hc_steady_states(sa_loop, ps)\nstabs_2 = [steady_state_stability(st, sa_loop, ps_2; ss_jac) for st in steady_states_2]\nnothing # hide","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"warn: Warn\nFor systems with conservation laws, steady_state_jac must be supplied a u0 vector (indicating species concentrations for conservation law computation). This is required to eliminate the conserved quantities, preventing a singular Jacobian. These are supplied using the u0 optional argument.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Within the Catalyst DSL, each line can represent either a reaction or an option. The previous DSL tutorial described how to create reactions. This one will focus on options. These are typically used to supply a model with additional information. Examples include the declaration of initial condition/parameter default values, or the creation of observables. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"All option designations begin with a declaration starting with @, followed by its input. E.g. the @observables option allows for the generation of observables. Each option can only be used once within each use of @reaction_network. A full list of options can be found here, with most (but not all) being described in more detail below. This tutorial will also describe some additional advanced DSL features that do not involve using an option. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"As a first step, we import Catalyst (which is required to run the tutorial):","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_declaring_species_and_parameters","page":"The Catalyst DSL - Advanced Features and Options","title":"Explicit specification of network species and parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Previously, we mentioned that the DSL automatically determines which symbols correspond to species and which to parameters. This is done by designating everything that appears as either a substrate or a product as a species, and all remaining quantities as parameters (i.e. those only appearing within rates or stoichiometric constants). Sometimes, one might want to manually override this default behaviour for a given symbol. I.e. consider the following model, where the conversion of a protein P from its inactive form (Pᵢ) to its active form (Pₐ) is catalysed by an enzyme (E). Using the most natural description:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"catalysis_sys = @reaction_network begin\n    k*E, Pᵢ --> Pₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"E (as well as k) will be considered a parameter, something we can confirm directly:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"parameters(catalysis_sys)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"If we want E to be considered a species, we can designate this using the @species option:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"catalysis_sys = @reaction_network begin\n    @species E(t)\n    k*E, Pᵢ --> Pₐ\nend\nparameters(catalysis_sys)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"note: Note\nWhen declaring species using the @species option, the species symbol must be followed by (t). The reason is that species are time-dependent variables, and this time-dependency must be explicitly specified (designation of non-t dependant species is also possible).","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Similarly, the @parameters option can be used to explicitly designate something as a parameter:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"catalysis_sys = @reaction_network begin\n    @parameters k\n    k*E, Pᵢ --> Pₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Here, while k is explicitly defined as a parameter, no information is provided about E. Hence, the default case will be used (setting E to a parameter). The @species and @parameter options can be used simultaneously (although a quantity cannot be declared both as a species and a parameter). They may be followed by a full list of all species/parameters, or just a subset.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"While designating something which would default to a parameter as a species is straightforward, the reverse (creating a parameter which occurs as a substrate or product) is more involved. This is, however, possible, and described here.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Rather than listing all species/parameters on a single line after the options, a begin ... end block can be used (listing one species/parameter on each line). E.g. in the following example we use this notation to explicitly designate all species and parameters of the system:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"catalysis_sys = @reaction_network begin\n    @species begin \n        E(t)\n        Pᵢ(t)\n        Pₐ(t)\n    end\n    @parameters begin\n        k\n    end\n    k*E, Pᵢ --> Pₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A side-effect of using the @species and @parameter options is that they specify the order in which the species and parameters are stored. I.e. lets check the order of the parameters in the parameters in the following dimerisation model:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"dimerisation = @reaction_network begin\n    (p,d), 0 <--> X\n    (kB,kD), 2X <--> X2\nend\nparameters(dimerisation)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"The default order is typically equal to the order with which the parameters (or species) are encountered in the DSL (this is, however, not guaranteed). If we specify the parameters using @parameters, the order used within the option is used instead:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"dimerisation = @reaction_network begin\n    @parameters kB kD p d\n    (p,d), 0 <--> X\n    (kB,kD), 2X <--> X2\nend\nparameters(dimerisation)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"danger: Danger\nGenerally, Catalyst and the SciML ecosystem do not guarantee that parameter and species order are preserved throughout various operations on a model. Writing programs that depend on these orders is strongly discouraged. There are, however, some legacy packages which still depend on order (one example can be found here). In these situations, this might be useful. However, in these cases, it is recommended that the user is extra wary, and also checks the order manually. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"note: Note\nThe syntax of the @species and @parameters options is identical to that used by the @species and @parameters macros used in programmatic modelling in Catalyst (for e.g. designating metadata or initial conditions). Hence, if one has learnt how to specify species/parameters using either approach, that knowledge can be transferred to the other one.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Generally, there are four main reasons for specifying species/parameters using the @species and @parameters options:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"To designate a quantity, that would otherwise have defaulted to a parameter, as a species.\nTo designate default values for parameters/species initial conditions (described here).\nTo designate metadata for species/parameters (described here).\nTo designate a species or parameters that do not occur in reactions, but are still part of the model (e.g a parametric initial condition)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"!!!! warn     Catalyst's DSL automatically infer species and parameters from the input. However, it only does so for quantities that appear in reactions. Until now this has not been relevant. However, this tutorial will demonstrate cases where species/parameters that are not part of reactions are used. These must be designated using either the @species or @parameters options (or the @variables option, which is described later).","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_default_vals","page":"The Catalyst DSL - Advanced Features and Options","title":"Setting default values for species and parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"When declaring species/parameters using the @species and @parameters options, one can also assign them default values (by appending them with = followed by the desired default value). E.g here we set X's default initial condition value to 10, and p and d's default values to 10 and 02, respectively:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @species X(t)=1.0\n    @parameters p=1.0 d=0.1\n    (p,d), 0 <--> X\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Next, if we simulate the model, we do not need to provide values for species or parameters that have default values. In this case all have default values, so both u0 and ps can be empty vectors:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using OrdinaryDiffEq, Plots\nu0 = []\ntspan = (0.0, 10.0)\np = []\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is still possible to provide values for some (or all) initial conditions/parameters in u0/ps (in which case these overrides the default values):","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"u0 = [:X => 4.0]\np = [:d => 0.5]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is also possible to declare a model with default values for only some initial conditions/parameters:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @species X(t)=1.0\n    (p,d), 0 <--> X\nend\n\ntspan = (0.0, 10.0)\np = [:p => 1.0, :d => 0.2]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"API for checking the default values of species and parameters can be found here.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_parametric_initial_conditions","page":"The Catalyst DSL - Advanced Features and Options","title":"Setting parametric initial conditions","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"In the previous section, we designated default values for initial conditions and parameters. However, the right-hand side of the designation accepts any valid expression (not only numeric values). While this can be used to set up some advanced default values, the most common use case is to designate a species's initial condition as a parameter. E.g. in the following example we represent the initial condition of X using the parameter X₀. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @species X(t)=X₀\n    @parameters X₀\n    (p,d), 0 <--> X\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Please note that as the parameter X₀ does not occur as part of any reactions, Catalyst's DSL cannot infer whether it is a species or a parameter. This must hence be explicitly declared. We can now simulate our model while providing X's value through the X₀ parameter:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"u0 = []\np = [:X₀ => 1.0, :p => 1.0, :d => 0.5]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is still possible to designate X's value in u0, in which case this overrides the default value.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"u0 = [:X => 0.5]\np = [:X₀ => 1.0, :p => 1.0, :d => 0.5]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Please note that X₀ is still a parameter of the system, and as such its value must still be designated to simulate the model (even if it is not actually used).","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_species_and_parameters_metadata","page":"The Catalyst DSL - Advanced Features and Options","title":"Designating metadata for species and parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Catalyst permits the user to define metadata for species and parameters. This permits the user to assign additional information to these, which can be used for a variety of purposes. Some Catalyst features depend on using metadata (with each such case describing specifically how this is done). Here we will introduce how to set metadata, and describe some common metadata types. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Whenever a species/parameter is declared using the @species/@parameters options, it can be followed by a [] within which the metadata is given. Each metadata entry consists of the metadata's name, followed by a =, followed by its value. E.g. the description metadata allows you to attach a String to a species/parameter. Here we create a simple model where we add descriptions to all species and parameters.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\ntwo_state_system = @reaction_network begin\n    @species Xi(t) [description=\"The X's inactive form\"] Xa(t) [description=\"The X's active form\"]\n    @parameters kA [description=\"X's activation rate\"] kD [description=\"X's deactivation rate\"]\n    (ka,kD), Xi <--> Xa\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A metadata can be given to only a subset of a system's species/parameters, and a quantity can be given several metadata entries. To give several metadata, separate each by a ,. Here we only provide a description for kA, for which we also provide a bounds metadata,","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"two_state_system = @reaction_network begin\n    @parameters kA [description=\"X's activation rate\", bounds=(0.01,10.0)]\n    (ka,kD), Xi <--> Xa\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is possible to add both default values and metadata to a parameter/species. In this case, first provide the default value, and next the metadata. I.e. to in the above example set kA's default value to 10 we use","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"two_state_system = @reaction_network begin\n    @parameters kA=1.0 [description=\"X's activation rate\", bounds=(0.01,10.0)]\n    (ka,kD), Xi <--> Xa\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"When designating metadata for species/parameters in begin ... end blocks the syntax changes slightly. Here, a , must be inserted before the metadata (but after any potential default value). I.e. a version of the previous example can be written as","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"two_state_system = @reaction_network begin\n    @parameters begin\n        kA, [description=\"X's activation rate\", bounds=(0.01,10.0)]\n        kD = 1.0, [description=\"X's deactivation rate\"]\n    end\n    (kA,kD), Xi <--> Xa\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Each metadata has its own getter functions. E.g. we can get the description of the parameter kA using ModelingToolkit.getdescription (here we use system indexing to access the parameter):","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"ModelingToolkit.getdescription(two_state_system.kA)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is not possible for the user to directly designate their own metadata. These have to first be added to Catalyst. Doing so is somewhat involved, and described in detail here. A full list of metadata that can be used for species and/or parameters can be found here.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_constant_species","page":"The Catalyst DSL - Advanced Features and Options","title":"Designating constant-valued/fixed species parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Catalyst enables the designation of parameters as constantspecies. These parameters can be used as species in reactions, however, their values are not changed by the reaction and remain constant throughout the simulation (unless changed by e.g. the [occurrence of an event]@ref ref). Practically, this is done by setting the parameter's isconstantspecies metadata to true. Here, we create a simple reaction where the species X is converted to Xᴾ at rate k. By designating X as a constant species parameter, we ensure that its quantity is unchanged by the occurrence of the reaction.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @parameters X [isconstantspecies=true]\n    k, X --> Xᴾ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"We can confirm that Xᴾ is the only species of the system:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"species(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Here, the produced model is actually identical to if X had simply been a parameter in the reaction's rate:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    k*X, 0 --> Xᴾ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A common use-case for constant species is when modelling systems where some species are present in such surplus that their amounts the reactions' effect on it is negligible. A system which is commonly modelled this way is the Brusselator.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_parameter_types","page":"The Catalyst DSL - Advanced Features and Options","title":"Designating parameter types","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Sometimes it is desired to designate that a parameter should have a specific type. When supplying this parameter's value to e.g. an ODEProblem, that parameter will then be restricted to that specific type. Designating a type is done by appending the parameter with :: followed by its type. E.g. in the following example we specify that the parameter n (the number of X molecules in the Xn polymer) must be an integer (Int64)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\npolymerisation_network = @reaction_network begin\n    @parameters n::Int64\n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Generally, when simulating models with mixed parameter types, it is recommended to declare parameter values as tuples, rather than vectors, e.g.:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"ps = (:kB => 0.2, :kD => 1.0, :n => 2)\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"If a parameter has a type, metadata, and a default value, they are designated in the following order:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"polymerisation_network = @reaction_network begin\n    @parameters n::Int64 = 2 [description=\"Parameter n, which is an integer and defaults to the value 2.\"]\n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_vector_variables","page":"The Catalyst DSL - Advanced Features and Options","title":"Vector-valued species or parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Sometimes, one wishes to declare a large number of similar parameters or species. This can be done by creating them as vectors. E.g. below we create a two-state system. However, instead of declaring X1 and X2 (and k1 and k2) as separate entities, we declare them as vectors:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\ntwo_state_model = @reaction_network begin\n    @parameters k[1:2]\n    @species X(t)[1:2]\n    (k[1],k[2]), X[1] <--> X[2]\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Now, we can also declare our initial conditions and parameter values as vectors as well:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using OrdinaryDiffEq, Plots # hide\nu0 = [:X => [0.0, 2.0]]\ntspan = (0.0, 1.0)\nps = [:k => [1.0, 2.0]]\noprob = ODEProblem(two_state_model, u0, tspan, ps)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_naming","page":"The Catalyst DSL - Advanced Features and Options","title":"Naming reaction networks","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Each reaction network model has a name. It can be accessed using the nameof function. By default, some generic name is used:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    (p,d), 0 <--> X\nend\nnameof(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A specific name can be given as an argument between the @reaction_network and the begin. E.g. to name a network my_network we can use:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network my_network begin\n    (p,d), 0 <--> X\nend\nnameof(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A consequence of generic names being used by default is that networks, even if seemingly identical, by default are not. E.g.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn1 = @reaction_network begin\n    (p,d), 0 <--> X\nend\nrn2 = @reaction_network begin\n    (p,d), 0 <--> X\nend\nrn1 == rn2","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"The reason can be confirmed by checking that their respective (randomly generated) names are different:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"nameof(rn1) == nameof(rn2)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"By designating the networks to have the same name, however, identity is achieved.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn1 = @reaction_network my_network begin\n    (p,d), 0 <--> X\nend\nrn2 = @reaction_network my_network begin\n    (p,d), 0 <--> X\nend\nrn1 == rn2","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Setting model names is primarily useful for hierarchical modelling, where network names are appended to the display names of subnetworks' species and parameters.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_observables","page":"The Catalyst DSL - Advanced Features and Options","title":"Creating observables","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Sometimes one might want to use observable variables. These are variables with values that can be computed directly from a system's state (rather than having their values implicitly given by reactions or equations). Observables can be designated using the @observables option. Here, the @observables option is followed by a begin ... end block with one line for each observable. Each line first gives the observable, followed by a ~ (not a =!), followed by an expression describing how to compute it.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Let us consider a model where two species (X and Y) can bind to form a complex (XY, which also can dissociate back into X and Y). If we wish to create a representation for the total amount of X and Y in the system, we can do this by creating observables Xtot and Ytot:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @observables begin\n        Xtot ~ X + XY\n        Ytot ~ Y + XY\n    end\n    (kB,kD), X + Y <--> XY\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"We can now simulate our model using normal syntax (initial condition values for observables should not, and can not, be provided):","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using OrdinaryDiffEq\nu0 = [:X => 1.0, :Y => 2.0, :XY => 0.0]\ntspan = (0.0, 10.0)\nps = [:kB => 1.0, :kD => 1.5]\noprob = ODEProblem(rn, u0, tspan, ps)\nsol = solve(oprob, Tsit5())\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Next, we can use symbolic indexing of our solution object, but with the observable as input. E.g. we can use ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"sol[:Xtot]","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"to get a vector with Xtot's value throughout the simulation. We can also use","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Plots\nplot(sol; idxs = :Xtot)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"to plot the observables (rather than the species).","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Observables can be defined using complicated expressions containing species, parameters, and variables (but not other observables). In the following example (which uses a parametric stoichiometry) X polymerises to form a complex Xn containing n copies of X. Here, we create an observable describing the total number of X molecules in the system:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @observables Xtot ~ X + n*Xn\n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"!!!     If only a single observable is declared, the begin .. end block is not required and the observable can be declared directly after the @observables option.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Metadata can be supplied to an observable directly after its declaration (but before its formula). If so, the metadata must be separated from the observable with a ,, and the observable plus the metadata encapsulated by (). E.g. to add a description metadata to our observable we can use","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @observables (Xtot, [description=\"The total amount of X in the system.\"]) ~ X + n*Xn\n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Observables are by default considered variables (not species). To designate them as a species, they can be pre-declared using the @species option. I.e. Here Xtot becomes a species:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @species Xtot(t)\n    @observables Xtot ~ X + n*Xn  \n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Some final notes regarding observables:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"The left-hand side of the observable declaration must contain a single symbol only (with the exception of metadata, which can also be supplied).\nAll quantities appearing on the right-hand side must be declared elsewhere within the @reaction_network call (either by being part of a reaction, or through the @species, @parameters, or @variables options).\nObservables may not depend on other observables.\nObservables have their dependent variable(s) automatically assigned as the union of the dependent variables of the species and variables on which it depends.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_ivs","page":"The Catalyst DSL - Advanced Features and Options","title":"Specifying non-time independent variables","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"As described elsewhere, Catalyst's ReactionSystem models depend on a time independent variable, and potentially one or more spatial independent variables. By default, the independent variable t is used. We can declare another independent variable (which is automatically used as the default one) using the @ivs option. E.g. to use τ instead of t we can use","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @ivs τ\n    (ka,kD), Xi <--> Xa\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"We can confirm that Xi and Xa depend on τ (and not t):","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"species(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is possible to designate several independent variables using @ivs. If so, the first one is considered the default (time) independent variable, while the following one(s) are considered spatial independent variable(s). If we want some species to depend on a non-default independent variable, this has to be explicitly declared:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @ivs τ x\n    @species X(τ) Y(x)\n    (p1,d1), 0 <--> X\n    (p2,d2), 0 <--> Y\nend\nspecies(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is also possible to have species which depends on several independent variables:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @ivs t x\n    @species Xi(t,x) Xa(t,x)\n    (ka,kD), Xi <--> Xa\nend\nspecies(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"note: Note\nSetting spatial independent variables is primarily intended for the modelling of spatial systems on continuous domains. Catalyst's support for this is currently under development. Hence, the utility of specifying spatial independent variables is limited.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_reaction_metadata","page":"The Catalyst DSL - Advanced Features and Options","title":"Setting reaction metadata","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is possible to supply reactions with metadata, containing some additional information of the reaction. A reaction's metadata follows after its declaration (first using the metadata's name, then a =, then its value) and is encapsulated by [] (where individual entries are separated by ,). Here, we add a description metadata to the reactions of a birth-death process:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nbd_model = @reaction_network begin\n    p, 0 --> X, [description=\"A production reaction\"]\n    d, X --> 0, [description=\"A degradation reaction\"]\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"When bundling reactions, reaction metadata can be bundled using the same rules as rates. Bellow we re-declare our birth-death process, but on a single line:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"bd_model = @reaction_network begin\n    (p,d), 0 --> X, ([description=\"A production reaction\"], [description=\"A degradation reaction\"])\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Here we declare a model where we also provide a misc metadata (which can hold any quantity we require) to our birth reaction:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"bd_model = @reaction_network begin\n    p, 0 --> X, [description=\"A production reaction\", misc=:value]\n    d, X --> 0, [description=\"A degradation reaction\"]\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A reaction's metadata can be accessed using specific functions, e.g. Catalyst.hasdescription and Catalyst.getdescription can be used to check if a reaction have a description metadata, and to retrieve it, respectively:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rx = @reaction p, 0 --> X, [description=\"A production reaction\"]\nCatalyst.getdescription(rx)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A list of all available reaction metadata can be found here.","category":"page"}]
}
